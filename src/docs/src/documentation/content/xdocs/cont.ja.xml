<?xml version="1.0" encoding="UTF-8"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and limitations under the License.
-->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document>
  <header>
    <title>制御構造</title>
  </header>
  <body>
  

<!-- ============================================ -->       
<section id="embed-python">
<title>埋め込み Pig - Python と JavaScript </title>
   
<p>制御構造を有効にするためには、 Pig Latin 文と Pig コマンドを Python か JavaScript などスクリプト言語に埋め込みます。埋め込み Pig は、 JDBC のようなコンパイル・バインド・実行のモデルを使います。 Python では、 Jython の JAR ファイルをクラスパスに含めます。 JavaScript では、 Rhino の JAR ファイルをクラスパスに含めます。</p>

<p>埋め込み先のホスト言語と、埋め込み Pig が使う UDF の言語は完全に直交です。たとえば、 Python UDF を登録する Pig Latin 文は Python, JavaScript, Java のいずれにも組み込めます。例外は「複合」スクリプトで、この場合はホスト言語と UDF の言語が一致する必要があります (<a href="udf.html#python-advanced">Python の高度な話題</a> と <a href="udf.html#js-advanced">JavaScript の高度な話題</a> を見てください) 。</p>


<!-- ============================================== -->
<section id="invocation-basics">
<title>呼び出しの基礎</title>
<p>埋め込み Pig が使えるのはバッチモードだけです。対話モードでは使えません。 Pig コマンドラインで <code>--embedded</code> オプションを指定することで埋め込み Pig が使えます。このオプションには、引数として埋め込み先の言語 (Python か JavaScript) が指定できます。引数を指定しない場合には、リファレンス実装である Python が指定されたものとみなされます。</p>

 <p><strong>Python</strong></p>
 <source>
 $ pig myembedded.py
OR
$ java -cp &lt;jython jars&gt;:&lt;pig jars&gt;; [--embedded python] /tmp/myembedded.py
 </source>
 <p></p>
 <p>Pig はスクリプトの <code>#!/usr/bin/python</code> という行を認識します。</p>
 
  <source>
#!/usr/bin/python 

# Pig クラスをインポート
from org.apache.pig.scripting import Pig 

# コンパイル: compile メソッドはパイプラインを表す Pig オブジェクトを戻します
P = Pig.compile("a = load '$in'; store a into '$out';")

input = 'original'
output = 'output'

# 束縛して実行
result = P.bind({'in':input, 'out':output}).runSingle()

if result.isSuccessful() :
    print 'Pig job succeeded'
else :
    raise 'Pig job failed'
 </source>

<p><strong>JavaScript</strong></p>
<source>
$ pig myembedded.js
OR
$ java -cp &lt;rhino jars&gt;:&lt;pig jars&gt;; [--embedded javascript] /tmp/myembedded.js
</source>
<p>Pig は *.js の拡張子を認識します。</p>
<source>
importPackage(Packages.org.apache.pig.scripting.js) 

Pig = org.apache.pig.scripting.js.JSPig

function main() {
    input = "original"
    output = "output"

    P = Pig.compile("A = load '$in'; store A into '$out';") 

    result = P.bind({'in':input, 'out':output}).runSingle() 

    if (result.isSuccessful()) {
        print("Pig job succeeded")
    } else {
        print("Pig job failed")
    }   
}
</source>

<p><strong>呼び出しプロセス</strong></p>

<p>ホスト言語から <a href="#pig-Object">Pig オブジェクト</a>を通じて Pig を呼び出します。</p>  

<p><strong>コンパイル:</strong> compile は Pig クラスの静的関数です。パイプラインを定義する Pig Latin を引数に取ります:</p>

<source>
# コンパイル: compile メソッドはパイプラインを表す Pig オブジェクトを戻します
P = Pig.compile("""A = load '$in'; store A into '$out';""")
</source>

<p>コンパイルによって Pig オブジェクトを生成します。 Pig オブジェクトは未確定値を含むことができます。たとえば、入力ファイルの場所を確定しない状態のパラメータとしてパイプラインを作成することが考えられます。パラメータはドル記号で始まり、英数字・アンダースコアの連なりで構成します。パラメータの値は Pig オブジェクトの bind() メソッドを呼び出すことで束縛します。すべてのパラメータを束縛していない状態で Pig オブジェクトの run() メソッドを呼ぶとエラーになります。</p>

<p><strong>束縛:</strong> bind メソッドを呼び出してパラメータを変数の値に束縛します。</p>

<source>
input = "original”
output = "output”

# 束縛: bind メソッドは変数に値を束縛し、 BoundScript オブジェクトを戻します。
Q = P.bind({'in':input, 'out':output}) 
</source>

<p>bind メソッドの呼び出しではすべてのパラメータを束縛する必要があります。束縛されていないパラメータがあると、スクリプトの実行はエラーになります。また、スクリプトのコンパイル時に未確定のパラメータがなかったとしても、 bind メソッドはパラメータ無しで呼ぶ必要があります。</p>

<p><strong>実行:</strong> bind メソッドは <a href="#BoundScript-Object">BoundScript オブジェクト</a>を戻します。 BoundScript オブジェクトはパイプラインを実行するのに使えます。パイプラインを実行するための最も単純な方法は、 runSingle メソッドを呼ぶことです。ただし後述するように、 runSingle メソッドが成功するのはパラメータに単一の変数セットを束縛している場合のみです。複数の変数セットを束縛している場合に runSingle メソッドを呼ぶと例外が投げられます。</p>

<source>
result = Q.runSingle()
</source>

<p>runSingle メソッドは <a href="#PigStats-Object">PigStats オブジェクト</a>を戻します。 PigStats オブジェクトは実行が成功したか失敗したかを表します。成功した場合は、実行統計情報も得られます。</p>


<p><strong>Python 埋め込みの例</strong></p>
<p>埋め込み Pig の完全な例です。</p>
<source>
#!/usr/bin/python

# Pig クラスをインポートします。
from org.apache.pig.scripting import Pig

# コンパイル: compile メソッドはパイプラインを表す Pig オブジェクトを戻します
P = Pig.compile("""A = load '$in'; store A into '$out';""")

input = "original”
output = "output”

# 束縛: bind メソッドは変数に値を束縛し、 BoundScript オブジェクトを戻します。
Q = P.bind({'in':input, 'out':output}) 

# ここでは 1 つの変数セットをパイプラインに束縛しているので、 runSingle メソッドは PigStats オブジェクトを戻します。
# 複数の変数セットを束縛した場合には、代わりに run メソッドを呼びます。
# run メソッドは PigStats のリストを戻します。
result = Q.runSingle()

# 結果チェック
if result.isSuccessful():
    print "Pig job succeeded"
else:
    raise "Pig job failed"    
</source>

<p>あるいは、単に次のようにします。</p>

<source>
#!/usr/bin/python

# Pig クラスをインポートします。
from org.apache.pig.scripting import Pig

in = "original”
out = "output”

# パラメータをローカル変数の値に暗黙的に束縛します
result= Pig.compile("""A = load '$in'; store A into '$out';""").bind().runSingle() 

if result.isSuccessful():
    print "Pig job succeeded"
else:
    raise "Pig job failed"
</source>
</section> 

<!-- ============================================== -->
<section id="invocation-details">
<title>呼び出しの詳細</title>
<p>前節で述べた 3 つの API (compile, bind, run) はいずれも、やりたいことに応じていくつかの変種があります。</p>

<section>
<title>コンパイル</title>
<p>前節で述べたように、基本的なメソッドである compile メソッドは、単にパイプラインを表す Pig Latin 文を引数に取ります。加えて、 compile メソッドはパイプラインの名前も取ることができます。この名前は、 PigRunner Java API 経由で組み込みスクリプトが実行された時にのみ使われます (この章で後述します) 。</p>

<source>
P = Pig.compile("P1", """A = load '$in'; store A into '$out';""")
</source>

<p>文字列として Pig スクリプトを与える以外に、スクリプトをファイルに保存して、そのファイル名を指定してコンパイルすることもできます:</p>
<source>
P = Pig.compileFromFile("myscript.pig")
</source>

<p>パイプラインに名前を付けることもできます:</p>
<source>
P = Pig.compileFromFile("P2", "myscript.pig")
</source>
</section>


<section>
<title>束縛</title>
<p>もっとも単純な形では、 bind メソッドは引数を取らずに呼び出せます。この場合、暗黙的なパラメータの束縛が行われます。 Pig は、スクリプト内で指定された名前の変数から、内部的にパラメータのマップを構築します。</p>

<source>
Q = P.bind() 
</source>

<p>最後に、 1 つのパイプラインを複数のパラメータセット、たとえば複数の日付に対して並行して実行することができます。この場合、 bind メソッドは 1 回の呼び出しでパラメータのマップのリストを取ります。次の例では、パイプラインを US, UK, ブラジル について呼び出しています。</p>

<source>
P = Pig.compile("""A = load '$in';
                   B = filter A by user is not null;
                   ...
                   store Z into '$out';
                """)

Q = P.bind([{'in':'us_raw','out':'us_processed'},
        {'in':'uk_raw','out':'uk_processed'},
        {'in':'brazil_raw','out':'brazil_processed'}])

results = Q.run() # it blocks until all pipelines are completed

for i in [0, 1, 2]:
    result = results[i]
    ... # check result for each pipeline

</source>
</section>

<section>
<title>実行</title>

<p>これまで見てきたように、スクリプトを実行するために最も単純なやり方は runSingle メソッドを引数なしで呼び出すことです。これに加えて、 Java の Properties オブジェクトか、プロパティのリストを格納したファイルを引数として渡すこともできます。引数として渡したプロパティは、コマンドラインから渡したプロパティと同様に扱われます。</p>

<source>
# Jython スクリプト

from java.util import Properties
... ...

props = Properties()
props.put(key1, val1)  
props.put(key2, val2) 
... ... 

Pig.compile(...).bind(...).runSingle(props)
</source>
<p>より汎用的な run メソッドを使うと、複数のパイプラインを同時に動かすことができます。この場合、それぞれのパイプラインの結果を表す PigStats のリストが戻ります。メソッドの使い方については前節の例を見てください。</p>
<p>runSingle と同様に、 Java プロパティかプロパティファイルを渡して呼び出すこともできます。</p>
</section>

<section>
<title>スクリプトにパラメータを渡す</title>
<p>スクリプトの中でパラメータを定義し、コマンドラインからパラメータを渡すことができます。パラメータをスクリプトに渡すには 2 つの方法があります:</p>
<p><strong>1. -param</strong></p>
<p>通常の Pig のパラメータ置換と同じように、 Pig のコマンドラインから -param オプションか -param_file オプションを指定することで、パラメータを渡すことができます。 Pig Latin スクリプトに変数を束縛する時、渡したパラメータは束縛変数として扱われます。たとえば、下記の Python スクリプトは次のように呼び出せます: pig -param loadfile=student.txt script.py</p>
<source>
#!/usr/bin/python
from org.apache.pig.scripting import Pig

P = Pig.compile("""A = load '$loadfile' as (name, age, gpa);
store A into 'output';""")

Q = P.bind()

result = Q.runSingle()
</source>

<p><strong>2. コマンドライン引数</strong></p>
<p>これは Python のみで利用できる機能ですが、スクリプトファイル名の後のコマンドライン引数を Python に与えることができます。 Python プログラムの中では sys.argv としてコマンドライン引数が得られます。たとえば次のように起動します: pig script.py student.txt 。対応するスクリプトは次のとおりです:</p>
<source>
#!/usr/bin/python
import sys
from org.apache.pig.scripting import Pig

P = Pig.compile("A = load '" + sys.argv[1] + "' as (name, age, gpa);" +
"store A into 'output';");

Q = P.bind()

result = Q.runSingle()
</source>
</section>

</section> 

<section id="pigrunner-api">
<title>PigRunner API</title>

<p>Pig 0.8 以降、 Oozie のようなアプリケーションはコマンドラインから Pig を実行する代わりに Java の PigRunner クラスを使って Pig を実行します。これらアプリケーションのため、 PigRunner インタフェースは埋め込み Pig と適合するように拡張されています。 PigRunner は Python と JavaScript のスクリプトを入力として受け入れます。埋め込みスクリプトは複数のパイプラインを含んでいる可能性があるため、すべてのパイプラインの結果を戻す方法が必要となりました。</p>

<p>後方互換性を維持しながらこれを可能にするため、 PigStats と関連するオブジェクトは次のように拡張されています:</p>
<ul>

<li id="PigStats">PigStats は抽象クラスになりました (これまでの PigStats は SimplePigStats になりました) 。</li>


<li id="SimplePigStats">SimplePigStats は PigStats を継承したクラスです。 SimplePigStats.getAllStats() は null を戻します。</li>

<li id="EmbeddedPigStats">EmbeddedPigStats は PigStats を継承したクラスです。次に挙げる以外のメソッドはすべて null を戻します。</li>


<li id="isembedded">isEmbedded() は埋め込み Pig 用の抽象メソッドです。</li>

<li id="stats-messages">PigStats クラスには getAllStats() と getAllErrorMessages() メソッドが追加されています。 getAllStats() メソッドの戻り値であるマップのキーは、 compile メソッドで指定したパイプラインの名前です。 compile メソッドで名前が指定されていない場合は、内部的に生成された ID が使われます。</li>

<li id="PigProgressNotificationListener2">PigProgressNotificationListener インタフェースのすべてのメソッドはスクリプト ID を引数に取る様になりました。</li>
</ul>
<p>詳細については <a href="#java-objects">Java オブジェクト</a> を見てください。</p>

</section> 


<section>
<title>使用例</title>

<section id="pig-files">
<title>Pig スクリプトを渡す</title>
<p>次の例では、 Pig スクリプト全体を compile メソッドに渡しています。</p>

<source>
#!/usr/bin/python

from org.apache.pig.scripting import Pig

P = Pig.compileFromFile("""myscript.pig""")

input = "original"
output = "output"

result = p.bind({'in':input, 'out':output}).runSingle()
if result.isSuccessful():
    print "Pig job succeeded"
else:
    raise "Pig job failed" 
</source>
</section> 

<section id="convergence">
<title>収束</title>
<p>解くべき問題によっては、必要な値が得られるまでパイプラインを複数回実行する必要があり、その回数があらかじめ分からないことがあります。たとえば機械学習、グラフ走査、そして内挿・外挿・回帰など多くの数値解析などの問題です。次の Python の例では、 Pig スクリプトで反復計算を行っています。</p>

<source>
#!/usr/bin/python

# Pig クラスをインポート
from org.apache.pig.scripting import Pig

P = Pig.compile("""A = load '$input' as (user, age, gpa);
                   B = group A all;
                   C = foreach B generate AVG(A.gpa);
                   store C into '$output';
                """)
# 初期出力
input = "studenttab5"
output = "output-5"
final = "final-output"

for i in range(1, 4):
    # Pig Latin 中の $input と $output に Python の input 変数と output 変数を関連付けます
    Q = P.bind({'input':input, 'output':output})
    results = Q.runSingle()

    if results.isSuccessful() == "FAILED":
        raise "Pig job failed"
    iter = results.result("C").iterator()
    if iter.hasNext():
        tuple = iter.next()
        value = tuple.get(0)
        if float(str(value)) &lt; 3:
            print "value: " + str(value)
            input = "studenttab" + str(i+5)
            output = "output-" + str(i+5)
            print "output: " + output
        else:
           Pig.fs("mv " + output + " " + final)
           break
</source>
</section>

<section id="automated-pig-latin">
<title>Pig Latin の自動生成</title>
<p>多くのフレームワークは Pig Latin を自動生成します。たとえば、データロード時に適切な日付を設定するなどのためです。</p>

<source>
today = sys.argv[1]
P = Pig.compile("""A = load 'fact' using HowlLoader();
                   B = filter A by datestamp = '$date';
                   ...
                   store Z into 'aggregated' using HowlStorage('datestamp = $date');
                """)
P.bind({'date':today}).runSingle()
</source>
</section>


<section>
<title>条件付きコンパイル</title>
<p>コード自動生成のユースケースの一つに、条件付きコンパイルがあります。たとえば、平日と週末で実行すべき処理が違うなどの場合です。</p>

<source>
str = "A = load 'input';" 
if today.isWeekday():
    str = str + "B = filter A by weekday_filter(*);" 
else:
    str = str + "B = filter A by weekend_filter(*);" 
str = str + "C = group B by user;" 
results = Pig.compile(str).bind().runSingle()
</source>
</section>

<section>
<title>並列実行</title>
<p>コード自動生成のその他のユースケースには、同一のパイプラインを並列実行することがあります。たとえば、ひとつのパイプラインを複数のデータセットについて並行して実行したいということがあります。次の例では、パイプラインを US, UK, ブラジルについて実行しています。</p>

<source>
P = Pig.compile("""A = load '$in';
                   B = filter A by user is not null;
                   ...
                   store Z into '$out';
                """)

Q = P.bind([{'in':'us_raw','out':'us_processed'},
        {'in':'uk_raw','out':'uk_processed'},
        {'in':'brazil_raw','out':'brazil_processed'}])

# すべてのパイプラインが完了するまでブロックします
results = Q.run()

for i in [0, 1, 2]:
    result = results[i]
    ... # check result for each pipeline
</source>
</section>

</section> 
   
   
<!-- ====================================================================== -->
 <section id="java-objects">
<title>Java オブジェクト</title>

<!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
 <section id="pig-object">
<title>Pig オブジェクト</title>
<source>
public class Pig {    
    /**
     * ファイルシステムコマンドを実行します。
     * コマンドの実行結果は標準出力か標準エラーへと適切に出力されます。
     *
     * @param cmd
     *     ファイルシステムコマンドと引数をひとつの文字列にしたもの。
     * @throws IOException
     */
    public static void fs(String cmd) throws IOException {...}
    
    /**
     * Pig で使う JAR ファイルを登録します。
     * このメソッドを実行すると、後続するすべてのパイプラインに対して JAR ファイルが登録されます。
     * JAR ファイルをひとつのパイプラインだけに対して登録したい場合は、
     * パイプラインの定義中で REGISTER 文を実行してください。
     *
     * @param jarfile
     *     登録する JAR ファイルのパス。
     * @throws IOException
     *     指定した JAR ファイルが見つからなかった時。
     */
    public static void registerJar(String jarfile) throws IOException {...}
    
    /**
     * Pig で使うスクリプト UDF を登録します。
     * このメソッドを実行すると、スクリプト中のすべての UDF が、
     * 後続するすべてのパイプラインから使用可能になります。
     * UDF をひとつのパイプラインだけに対して登録したい場合は、
     * パイプラインの定義中で REGISTER 文を実行してください。
     *
     * @param udffile
     *     UDF スクリプトのパス。
     * @param namespace
     *     UDF の名前空間。
     * @throws IOException
     */
    public static void registerUDF(String udffile, String namespace) throws IOException {...}
    
    /**
     * UDF あるいはストリーミングコマンドに別名を定義します。
     * この定義は後続するすべてのパイプラインに対して有効になります。
     * 別名をひとつのパイプラインだけに対して定義したい場合は、
     * パイプラインの定義中で DEFINE 文を実行してください。
     *
     * @param alias
     *     定義する別名。
     * @param definition
     *     別名が適宜される対象。
     */
    public static void define(String alias, String definition) throws IOException {...}

    /**
     * Pig Latin 中で使う変数に値を格納します。
     * 格納した値は後続するすべてのパイプラインについて有効になります。
     * ひとつのパイプラインに対してだけ変数を格納したい場合は、
     * パイプラインの定義中で格納してください。
     *
     * @param var
     *     値を格納する変数。
     * @param value
     *     格納する値。
     */
    public static void set(String var, String value) throws IOException {...}
            
    /**
     * Pig のパイプラインを定義します。
     * 
     * @param pl
     *     Pig Latin によるパイプラインの定義。
     * @return
     *     パイプラインを表す Pig オブジェクト。
     * @throws IOException
     *     Pig Latin がコンパイルできない時。
     */
    public static Pig compile(String pl) throws IOException {...}

    /**
     * 名前付きの Pig パイプラインを定義します。
     * この名前を使って他のパイプラインにインポートできるようになります。
     * 
     * @param name
     *     パイプラインの名前。パイプラインの名前空間はグローバルです。
     * @param pl
     *     Pig Latin によるパイプラインの定義。
     * @return
     *     パイプラインを表す Pig オブジェクト。
     * @throws IOException
     *     Pig Latin がコンパイルできない時。
     */
    public static Pig compile(String name, String pl) throws IOException {...}

    /**
     * Pig Latin ファイルから Pig パイプラインを定義します。
     *
     * @param filename
     *     Pig Latin が格納されたファイル。
     *     これは純粋な Pig Latin ファイルである必要があります。
     *     ホスト言語を含むことはできません。
     * @return
     *     パイプラインを表す Pig オブジェクト。
     * @throws IOException
     *     Pig Latin がコンパイルできない時、あるいはファイルが見つからない時。
     */
    public static Pig compileFromFile(String filename) throws IOException {...}

    /**
     * Pig Latin ファイルから Pig パイプラインを定義します。
     * 名前を使って他のパイプラインにインポートできるようになります。
     *
     * @param name
     *     パイプラインの名前。パイプラインの名前空間はグローバルです。
     * @param filename
     *     Pig Latin が格納されたファイル。
     *     これは純粋な Pig Latin ファイルである必要があります。
     *     ホスト言語を含むことはできません。
     * @return
     *     パイプラインを表す Pig オブジェクト。
     * @throws IOException
     *     Pig Latin がコンパイルできない時、あるいはファイルが見つからない時。
     */
    public static Pig compileFromFile(String name, String filename) throws IOException {...}
    
    /**
     * 変数の値を束縛します。
     * すべての Pig Latin パラメータに対して値が与えられる必要があります。
     *
     * @param vars
     *     束縛する変数セットのマップ。
     *     キーは Pig Latin で定義されているパラメータの名前です。
     *     値はパラメータの値を表す文字列です。
     *     ホスト言語中ではこれらの値は定数でも変数でも構いません。
     *     変数である場合は、文字列変数である必要があります。
     * @return
     *     {@link BoundScript} オブジェクト。
     * @throws IOException
     *     いずれかのパラメータに対応するキーがなかった場合、
     *     あるいはサポートされない型の値が与えられた場合。
     */
    public BoundScript bind(Map&lt;String, String&gt; vars) throws IOException {...}
        
    /**
     * 複数の変数セットを束縛します。
     * Pig Latin スクリプトは変数セットごとに並列で実行されます。
     *
     * @param vars
     *     束縛する変数セットのマップのリスト。
     *     キーは Pig Latin で定義されているパラメータの名前です。
     *     値はパラメータの値を表す文字列です。
     *     ホスト言語中ではこれらの値は定数でも変数でも構いません。
     *     変数である場合は、文字列変数である必要があります。
     * @return
     *     {@link BoundScript} オブジェクト。
     * @throws IOException
     *     いずれかのパラメータに対応するキーがなかった場合、
     *     あるいはサポートされない型の値が与えられた場合。
     */
    public BoundScript bind(List&lt;Map&lt;String, String&gt;&gt; vars) throws IOException {...}

    /**
     * ホスト言語中の変数を束縛します (オプショナルな操作) 。
     * これはホスト言語中の変数から Pig Latin パラメータへの暗黙的なマッピングを行います。
     * たとえば、ユーザが Pig Latin 文
     * p = Pig.compile("A = load '$input';");
     * を定義して、 p に対してこのメソッドを呼ぶと、このメソッドはホスト言語中の「input」
     * という変数を探します。
     * 束縛する変数を選択するには、ホスト言語のスコーピング規則が使われます。
     * すべてのホスト言語で、スコープ中の変数を得る機能があるとは限らないため、
     * このメソッドはオプショナルです。
     *
     * @throws IOException
     *     Pig Latin パラメータに対応するホスト言語の変数が存在しない場合、
     *     あるいは変数にサポートされない型の値が入っていた場合。
     */
    public BoundScript bind() throws IOException {...}

}
</source>
</section>

<!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
<section id="BoundScript-Object">
<title>BoundScript Object</title>
<source>
public class BoundScript {
    
    /**
     * パイプラインを Hadoop 上で実行します。
     * 束縛されたクエリがない時は、何も実行されません。
     *
     * @return
     *     {@link PigStats}, または、束縛されたクエリがない時は null。
     * @throws IOException
     */
    public PigStats runSingle() throws IOException {...}
     
    /**
     * パイプラインを Hadoop 上で実行します。
     * 束縛されたクエリがない時は、何も実行されません。
     *
     * @param prop
     *     スクリプトを実行する際に Pig が設定するプロパティのマップ。
     *     This is intended for use with scripting languages that do not support
     *     the Properties object.
     * @return
     *     {@link PigStats}, または、束縛されたクエリがない時は null。
     * @throws IOException
     */
    public PigStats runSingle(Properties prop) throws IOException {...}
    
    /**
     * パイプラインを Hadoop 上で実行します。
     * 束縛されたクエリがない時は、何も実行されません。
     *
     * @param propfile
     *     スクリプトを実行する際に Pig が設定するプロパティを格納したファイル。
     * @return
     *     {@link PigStats}, または、束縛されたクエリがない時は null。
     * @throws IOException
     */
    public PigStats runSingle(String propfile) throws IOException {...}

    /**
     * 複数のパイプラインを Hadoop 上で並列に実行します。
     * 束縛されたクエリがない時は、何も実行されません。
     * 変数セットのリストに対して bind メソッドが呼ばれていることを前提とします。
     *
     * @return
     *     bind メソッドに渡されたそれぞれの変数セットのマップに対応する {@link PigStats} のリスト。
     * @throws IOException
     */    
    public List&lt;PigStats&gt; run() throws IOException {...}
    
    /**
     * 複数のパイプラインを Hadoop 上で並列に実行します。
     *
     * @param prop
     *     スクリプトを実行する際に Pig が設定するプロパティのマップ。
     *     This is intended for use with scripting languages that do not support
     *     the Properties object.
     * @return
     *     bind メソッドに渡されたそれぞれの変数セットのマップに対応する {@link PigStats} のリスト。
     * @throws IOException
     */
    public List&lt;PigStats&gt;  run(Properties prop) throws IOException {...}
    
    /**
     * 複数のパイプラインを Hadoop 上で並列に実行します。
     *
     * @param propfile
     *     スクリプトを実行する際に Pig が設定するプロパティを格納したファイル。
     * @return
     *     bind メソッドに渡されたそれぞれの変数セットのマップに対応する {@link PigStats} のリスト。
     * @throws IOException
     */
    public List&lt;PigStats&gt;  run(String propfile) throws IOException {...}

    /**
     * パイプラインに対する ILLUSTRATE を実行します。
     * 結果は標準出力に表示されます。
     *
     * @throws IOException
     *     ILLUSTRATE が失敗した時。
     */
    public void illustrate() throws IOException {...}

    /**
     * パイプラインの実行計画を表示します。
     * 結果は標準出力に表示されます。
     *
     * @throws IOException
     *     EXPLAIN が失敗した時。
     */
    public void explain() throws IOException {...}

    /**
     * パイプライン中の別名のスキーマを表示します。
     * 結果は標準出力に表示されます。
     *
     * @param alias
     *     スキーマを表示する対象の別名。
     * @throws IOException
     *     DESCRIBE が失敗した時。
     */
    public void describe(String alias) throws IOException {...}

}
</source>
</section>  

<!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
<section id="PigStats-Object">
<title>PigStats オブジェクト</title>
<source>
public abstract class PigStats {
    public abstract boolean isEmbedded();
    
    /**
     * 埋め込みスクリプトは 1 つ以上のパイプラインを含む場合があります。
     * スクリプト中で名前が付けられたパイプラインについては、その名前が戻り値のマップのキーになります。
     * パイプラインに名前が付けられていない場合は、パイプラインの ID が戻り値のマップのキーになります。
     */
    public abstract Map&lt;String, List&lt;PigStats&gt;&gt; getAllStats();
    
    public abstract List&lt;String&gt; getAllErrorMessages();      
}
</source>
</section>  

<!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
<section id="PigProgressNotificationListener">
<title>PigProgressNotificationListener オブジェクト</title>
<source>
public interface PigProgressNotificationListener extends java.util.EventListener {

    /** 
     * スクリプトから生成された MapReduce ジョブが実行される直前に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param numJobsToLaunch
     *     スクリプトから生成された MapReduce ジョブの数。
     */
    public void launchStartedNotification(String scriptId, int numJobsToLaunch);
    
    /**
     * MapReduce ジョブのバッチを投入する直前に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param numJobsSubmitted
     *     スクリプトから生成された MapReduce ジョブの数。
     */
    public void jobsSubmittedNotification(String scriptId, int numJobsSubmitted);
    
    /**
     * MapReduce ジョブが実行された後に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param assignedJobId
     *     MapReduce ジョブの ID。
     */
    public void jobStartedNotification(String scriptId, String assignedJobId);
    
    /**
     * MapReduce ジョブが成功した直後に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param jobStats
     *     MapReduce ジョブに紐づく {@link JobStats} オブジェクト。
     */
    public void jobFinishedNotification(String scriptId, JobStats jobStats);
    
    /**
     * MapReduce ジョブが失敗した時に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param jobStats
     *     MapReduce ジョブに紐づく {@link JobStats} オブジェクト。
     */
    public void jobFailedNotification(String scriptId, JobStats jobStats);
    
    /**
     * 結果の出力が成功した直後に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param outputStats
     *     出力に紐づく {@link OutputStats} オブジェクト。
     */
    public void outputCompletedNotification(String scriptId, OutputStats outputStats);
    
    /**
     * 実行の進捗状況が更新された時に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param progress
     *     実行の進捗状況のパーセンテージ。
     */
    public void progressUpdatedNotification(String scriptId, int progress);
    
    /**
     * スクリプトから生成された MapReduce ジョブがすべて完了した直後に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param numJobsSucceeded
     *     成功した MapReduce ジョブの数。
     */
    public void launchCompletedNotification(String scriptId, int numJobsSucceeded);
}
</source>
</section>  
</section>    
</section> 


 <!-- ============================================ -->    
<section id="embed-java">
<title>埋め込み Pig - Java </title>

<p>フロー制御を行うため、 Pig Latin 文と Pig コマンドを Java プログラムに埋め込むことができます。</p>

<p>ホスト言語と、 埋め込み Pig に読み込む UDF の言語は、完全に直交する概念です。たとえば、 Java UDF を登録する Pig Latin 文は Python, JavaScript, Java のいずれにも埋め込めます。このルールの例外は複合スクリプトです。複合スクリプトでは、二つの言語は一致する必要があります (<a href="udf.html#python-advanced">Python の高度な話題</a>と <a href="udf.html#js-advanced">JavaScript の高度な話題</a>を見てください) 。</p>

<section id="pigserver">
<title>PigServer インタフェース</title>
<p><a href="http://pig.apache.org/docs/r0.10.0/api/org/apache/pig/PigServer.html">PigServer</a> は Java 埋め込み Pig の中心となるインタフェースです。 PigServer は複数のスレッドからインスタンスできます (かつては、 PigServer が静的なデータを参照していたため、アプリケーション中の複数のスレッドから生成することができませんでした) 。 PigServer はスレッドセーフでは「ありません」。ひとつのオブジェクトを、スレッドをまたがって共有することはできません。</p>
</section>

<section>
<title>使用例</title>
<!-- ++++++++++++++++++++++++++++++++++ -->
<p><strong>ローカルモード</strong></p>
<p>idlocal.java - /etc/passwd ファイルからユーザ ID を抽出する Pig Latin 文を実行するプログラムです。まず、 /etc/passwd ファイルを作業ディレクトリにコピーしてください。</p>
<source>
import java.io.IOException;
import org.apache.pig.PigServer;
public class idlocal{ 
    public static void main(String[] args) {
        try {
            PigServer pigServer = new PigServer("local");
            runIdQuery(pigServer, "passwd");
        }
        catch(Exception e) {
        }
     }
    public static void runIdQuery(PigServer pigServer, String inputFile) throws IOException {
        pigServer.registerQuery("A = load '" + inputFile + "' using PigStorage(':');");
        pigServer.registerQuery("B = foreach A generate $0 as id;");
        pigServer.store("B", "id.out");
    }
}
</source>

<p>現在の作業ディレクトリでプログラムをコンパイルします (現在の作業ディレクトリに idlocal.class が出力されます。したがって、プログラムを実行する際には “.” をクラスパスに含めます) 。</p>
<source>
$ javac -cp pig.jar idlocal.java
</source>
<p>現在の作業ディレクトリでプログラムを実行します。実行結果については、出力ファイル id.out を見てください。</p>
<source>
Unix:   $ java -cp pig.jar:. idlocal
Cygwin: $ java -cp '.;pig.jar' idlocal
</source>

<!-- ++++++++++++++++++++++++++++++++++ -->
<p><strong>Mapreduce モード</strong></p>
<p>$HADOOPDIR が hadoop-site.xml が含まれるディレクトリを指すように設定します。</p>
<source>
$ export HADOOPDIR=/yourHADOOPsite/conf 
</source>
<p>idmapreduce.java - /etc/passwd ファイルからユーザ ID を抽出する Pig Latin 文を実行するプログラムです。まず、 /etc/passwd ファイルを HDFS 上のホームディレクトリにコピーしてください。</p>
<source>
import java.io.IOException;
import org.apache.pig.PigServer;
public class idmapreduce{
    public static void main(String[] args) {
        try {
            PigServer pigServer = new PigServer("mapreduce");
            runIdQuery(pigServer, "passwd");
        }
        catch(Exception e) {
        }
    }
    public static void runIdQuery(PigServer pigServer, String inputFile) throws IOException {
        pigServer.registerQuery("A = load '" + inputFile + "' using PigStorage(':');")
        pigServer.registerQuery("B = foreach A generate $0 as id;");
        pigServer.store("B", "idout");
    }
}
</source>
<p>現在の作業ディレクトリでプログラムをコンパイルします (現在の作業ディレクトリに idmapreduce.class が出力されます。したがって、プログラムを実行する際には “.” をクラスパスに含めます) 。</p>
<source>
$ javac -cp pig.jar idmapreduce.java
</source>
<p>現在の作業ディレクトリでプログラムを実行します。実行結果については、 Hadoop 上の idout ディレクトリを見てください。</p>
<source>
Unix:   $ java -cp pig.jar:.:$HADOOPDIR idmapreduce
Cygwin: $ java -cp '.;pig.jar;$HADOOPDIR' idmapreduce
</source>

</section>
</section>


 <!-- ============================================ -->    
   <section id="macros">
   <title>Pig マクロ</title> 
   <p>Pig Latin ではマクロの定義・展開・インポートができます。</p>

  <!-- ========================== -->
  <section id="define-macros">
   <title>DEFINE (マクロ)</title>
   <p>Pig のマクロを定義します。</p>
   
 <section>
   <title>文法</title>
   <p>マクロ定義</p>
   <table>
      <tr> 
            <td>
               <p>DEFINE macro_name (param [, param ...]) RETURNS {void | alias [, alias ...]} { pig_latin_fragment }; </p>
            </td>
      </tr> 
   </table>
    <p id="expand-macros">マクロ展開</p>
      <table>
      <tr> 
            <td>
               <p>alias [, alias ...] = macro_name (param [, param ...]) ; </p>
            </td>
      </tr> 
   </table>
 </section>   
   
<section>
   <title>定義</title>
   <table>
      <tr>
            <td>
               <p>macro_name</p>
            </td>
            <td>
               <p>マクロの名前。マクロの名前はグローバルです。</p>
            </td>
      </tr>
            <tr>
            <td>
               <p>param</p>
            </td>
            <td>
               <p>(オプショナル) カンマ区切りで括弧に括られた引数列です。 Pig の関係の別名を入力として指定できます。引数は Pig Latin 断片内で置き換えられます。</p>
               <p>ユーザ定義関数 (UDF) と異なり、 Pig のマクロは次の型を引数として取ります:</p>
               <ul>
               <li>別名 (識別子)</li>
               <li>整数</li>
               <li>浮動小数点数</li>
               <li>文字列リテラル (引用符に括られた文字列)</li>
               </ul>
               <p>型は引数の定義に含まれません。マクロを書く人の責任で、引数の型をドキュメント化するべきです。</p>
            </td>
      </tr>
      <tr>
            <td>
               <p>void</p>
            </td>
            <td>
               <p>マクロに戻り値としての別名がなければ、 void を指定します。</p>
            </td>
      </tr>
            <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>(オプショナル) 1 つ以上の、 Pig Latin 断片中に出現する関係の別名の、カンマで区切られたリスト。別名はマクロ中で $&lt;alias&gt; という形式で出現する必要があります。</p>
               <p>マクロに戻り値としての別名がなければ、 void を指定します。</p>
            </td>
      </tr>
      <tr>
            <td>
               <p>pig_latin_fragment</p>
            </td>
            <td>
               <p>1 つ以上の、中括弧で括られた Pig Latin 文。</p>
            </td>
      </tr>
    </table>
   </section>
    
   <section>
   <title>用法</title>
<!-- +++++++++++++++++++++++++++++++++++++++++++++++ --> 
   <p><strong>マクロ定義</strong></p>
   <p>マクロ定義は最初の使用箇所以前であれば Pig スクリプト中のどこにでも書けます。マクロ定義は、自身よりも前に定義された他のマクロを参照することができます。再帰的な参照はできません。</p>
   
   <p>次の制限事項があります:</p>
   <ul>
   <li>マクロはネストした <a href="basic.html#nested-block">FOREACH</a> 文のブロックの中では使えません。</li>
   <li>マクロの中に書けるのは <a href="start.html#pl-statements">Pig Latin 文</a>だけです。 <a href="basic.html#register">REGISTER</a> 文は使えません。 Grunt で使われる<a href="cmds.html#shell-cmds">シェルコマンド</a>も使えません。</li>
   <li>マクロ定義の中では、マクロ中の関係の別名と同じ名前のフィールドを持つユーザ定義スキーマを定義することはできません。</li>
   <li>マクロ中で<a href="#parameter-sub">パラメータ置換</a>はできません。マクロに対しては明示的に引数を渡す必要があります。パラメータ置換ができるのはトップレベルだけです。</li>
   </ul>

<p>次の例では my_macro という名前のマクロを作っています。マクロを外から見ると別名 A と C だけが見えます。別名 B は外からは見えません。</p>
<source>
DEFINE my_macro(A, sortkey) RETURNS C {
    B = FILTER $A BY my_filter(*);
    $C = ORDER B BY $sortkey;
}
</source>

<!-- +++++++++++++++++++++++++++++++++++++++++++++++ -->
<p><strong>マクロの展開</strong></p>

<p>マクロはマクロ展開構文を使ってインライン展開できます。次の点に注意してください:</p>
<ul>
<li>マクロ中にある外側から見えない別名は、衝突を防ぐためにマクロの名前と連番が前置されます。</li>
<li>マクロ展開は完全な関数呼び出しとして使えるものではありません。再帰的展開はできません。</li>
</ul>
<p>次の例では my_macro (前の例で定義済み) が展開されます。別名 B は外側から見えないので、 macro_my_macro_B_0 という名前に置き換えられます。</p>

<source>
/* 展開前 */

X = LOAD 'users' AS (user, address, phone);
Y = my_macro(X, user);
STORE Y into 'bar';

/* 展開後 */

X = LOAD 'users' AS (user, address, phone);
macro_my_macro_B_0 = FILTER X BY my_filter(*);
Y = ORDER macro_my_macro_B_0  BY user;
STORE Y INTO 'output';
</source>

<!-- +++++++++++++++++++++++++++++++++++++++++++++++ -->
<p><strong>マクロのインポート</strong></p>
<p>他の Pig スクリプト中のマクロをインポートすることもできます (<a href="#import-macros">IMPORT (マクロ)</a> を見てください) 。</p>
</section> 


 <section>
 <title>例</title>
<p>次の例は引数なしのマクロです。</p>
<source>
DEFINE my_macro() returns B {
   D = LOAD 'data' AS (a0:int, a1:int, a2:int);   
   $B = FILTER D BY ($1 == 8) OR (NOT ($0+$2 > $1));
};

X = my_macro();
STORE X INTO 'output';
</source>

<p>次の例では、引数を取って戻り値を戻しています。</p>
<source>
DEFINE group_and_count (A, group_key, reducers) RETURNS B {
   D = GROUP $A BY $group_key PARALLEL $reducers;
   $B = FOREACH D GENERATE group, COUNT($A);
};

X = LOAD 'users' AS (user, age, zip);
Y = group_and_count (X, user, 20);
Z = group_and_count (X, age, 30);
STORE Y into 'byuser';
STORE Z into 'byage';
</source>

<p>次の例では、マクロは別名を戻さないため、 void を指定しています。</p>
<source>
DEFINE my_macro(A, sortkey) RETURNS void {     
      B = FILTER $A BY my_filter(*);     
      C = ORDER B BY $sortkey;
      STORE C INTO 'my_output';  
};

/* このマクロを展開するには、次のようにします */

my_macro(alpha, 'user');
</source>

<p>次の例では名前の衝突が起きます。 B という文字が関係の別名とユーザ定義のスキーマの双方に使われているためです。名前衝突を検出すると、 Pig は例外を投げます。</p>
<source>
DEFINE my_macro(A, sortkey) RETURNS E {     
      B = FILTER $A BY my_filter(*);     
      C = ORDER B BY $sortkey;
      D = LOAD 'in' as (B:bag{});
      $E = FOREACH D GENERATE COUNT(B); 
};
</source>

<p>次の例は、マクロを使う際に引数の型を知ることの重要性を示しています。 my_macro1 から my_macro2 を呼ぶ時に、引数 $outfile を引用符でくくっていることに注意してください。</p>
<source>
-- A: 別名
-- outfile: 出力先のパス (引用符でくくられた文字列)
DEFINE my_macro1(A, outfile) RETURNS void {     
       STORE $A INTO '$outfile'; 
};

-- A: 別名
-- sortkey: 列名 (引用符でくくられた文字列)
-- outfile: 出力先のパス (引用符でくくられた文字列)
DEFINE my_macro2(A, sortkey, outfile) RETURNS void {     
      B = FILTER $A BY my_filter(*);     
      C = ORDER B BY $sortkey;
      my_macro1(C, '$outfile');
   };

   alpha = Load 'input' as (user, age, gpa);
   my_macro2(alpha, 'age', 'order_by_age.txt');
</source>


<p>次の例ではマクロ (group_with_parallel) が他のマクロ (foreach_count) を参照しています。</p>
<source>
DEFINE foreach_count(A, C) RETURNS B {
   $B = FOREACH $A GENERATE group, COUNT($C);
};

DEFINE group_with_parallel (A, group_key, reducers) RETURNS B {
   C = GROUP $A BY $group_key PARALLEL $reducers;
   $B = foreach_count(C, $A);
};
       
/* 展開前 */
 
X = LOAD 'users' AS (user, age, zip);
Y = group_with_parallel (X, user, 23);
STORE Y INTO 'byuser';

/* 展開後 */

X = LOAD 'users' AS (user, age, zip);
macro_group_with_parallel_C_0 = GROUP X by (user) PARALLEL 23;
Y = FOREACH macro_group_with_parallel_C_0 GENERATE group, COUNT(X);
STORE Y INTO 'byuser';
</source>
</section> 
   
  </section>    
   
   
  <!-- ========================== -->
   <section id="import-macros">
   <title>IMPORT (マクロ)</title>   
   <p>他のファイルに定義されたマクロをインポートします。</p>
    <section>
   <title>文法</title>
   <table>
      <tr> 
            <td>
               <p>IMPORT 'file-with-macro';</p>
            </td>
      </tr> 
   </table>
   </section>
     
   <section>
   <title>定義</title>
   <table>
      <tr>
            <td>
               <p>file-with-macro</p>
            </td>
            <td>
	       <p>1 つ以上のマクロ定義を含んだファイルの名前を単一引用符にくくって指定します。たとえば、 'my_macro.pig' や 'mypath/my_macro.pig' のようにします。</p>
               <p>マクロ名はグローバルなので、すべてのマクロは同じ名前空間を共有します。ファイルには複数のマクロ定義が含められますが、実行コンテキスト中に同じ名前のマクロが 2 つあったら、エラーが発生します。</p>
               <p>ファイルは (1) 与えられたファイルパス、 (2) Pig プロパティ pig.import.search.path に指定されたインポートパス、のいずれかを基点としてインポートされます。与えられたファイルパスが、絶対パスか、カレントディレクトリを基点とする相対パス (. か .. から始まる) だった場合、インポートパスは無視されます。</p>
            </td>
         </tr>
      </table>   
   </section>
      
   <section>
   <title>用法</title>
   <p>IMPORT コマンドは、他のファイルに定義されたマクロを Pig スクリプトにインポートするために使います。</p>
   <p>IMPORT はマクロ定義を Pig Latin の名前空間に追加します。インポートしたマクロは同じファイル中に定義されているのと同じように呼び出せます。</p>
   <p>マクロ中で使えるのは Pig Latin 文だけです。 Grunt シェルのコマンドは使えません。</p>
   
   <p><a href="#define-macros">DEFINE (マクロ)</a> も見てください。</p>
     </section> 
     
   <section>
   <title>例</title>
   <p>次の例では、パスが与えられていないので、 pig は <code>pig.import.search.path</code> で指定されたインポートパスを使います。</p>
<source>
/* myscript.pig */
...
...
IMPORT 'my_macro.pig';
...
...
</source>
   
    </section> 
   </section>   
   </section> 

  
 <!-- =========================================== -->    
   <section id="parameter-sub">
   <title>パラメータ置換</title>
   <section>
   
   <!-- ++++++++++++++++++++++++++++++++++ -->
   <title>解説</title>
   <p>実行時にパラメータの値を置換します。</p>
   
   <section>
   <title>文法: Pig コマンドラインでパラメータを指定する</title>
   <table>
      <tr>
            <td>
               <p>pig {-param param_name = param_value | -param_file file_name} [-debug | -dryrun] script</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>文法: Pig スクリプト中のプリプロセッサ文でパラメータを指定する</title>
   <table>
      <tr>
            <td>
               <p>{%declare | %default} param_name param_value</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
      <tr>
            <td>
               <p>pig</p>
            </td>
            <td>
               <p>キーワード</p>
               <p>注記: exec コマンド、 run コマンド、 EXPLAIN 文も同様にパラメータ置換をサポートします。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>-param</p>
            </td>
            <td>
               <p>パラメータをコマンドラインから渡す時にこのオプションを使います。</p>
               <p>パラメータは複数個指定できます。同じパラメータが複数回指定された時は、最後に指定された値が使われますが、警告が表示されます。</p>
               <p>コマンドラインによるパラメータの指定と、パラメータファイルによる指定を併用した時は、コマンドラインによる指定が優先されます。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>param_name</p>
            </td>
            <td>
               <p>パラメータ名。</p>
               <p>パラメータ名の構造は Pig Latin の識別子と同じです。アルファベットまたはアンダースコアから始まって、任意の数のアルファベット、数字、アンダースコアが続きます。</p>
               <p>パラメータ名は大文字・小文字を区別しません。</p>
               <p>スクリプト中で使われていないパラメータを渡した時は、パラメータは単に無視されて、警告も表示されません。スクリプト中で使われているパラメータに対して置換する値を指定しなかった時は、エラーが発生します。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>param_value</p>
            </td>
            <td>
               <p>パラメータの値。</p>
               <p>パラメータの値は 2 種類の形式が取れます:</p>
               <ul>
                  <li>
                     <p>単一引用符か二重引用符で括った文字列。この場合、引用符が外された値がパラメータ置換に使われます。値の中に引用符を含めたい場合は、バックスラッシュ ( \ ) でエスケープします。「%」や「=」のような特殊文字を含まない、単一の単語からなる値は、引用符なしでも指定できます。</p>
                  </li>
                  <li>
                     <p>バッククオートで括ったコマンド。</p>
                  </li>
               </ul>
	       <p>どちらの形式でも、パラメータの値の中で他のパラメータを使うことができます。ただし、依存先のパラメータは事前に定義されている必要があります。</p>
               <p>メモリが許す限りに置いて、値の長さに特に制限はありません。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>-param_file</p>
            </td>
            <td>
               <p>パラメータをファイルに格納する場合にこのオプションを使います。</p>
               <p>ファイルは複数個指定できます。同じパラメータが 1 つのファイルの中で複数回指定されている場合は、最後に出現する値が使われますが、警告が表示されます。同じパラメータが複数のファイルに格納されていた場合は、最後のファイルの値が使われますが、警告が表示されます。</p>
               <p>コマンドラインによるパラメータの指定と、パラメータファイルによる指定を併用した時は、コマンドラインによる指定が優先されます。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>file_name</p>
            </td>
            <td>
               <p>1 つ以上のパラメータを含むファイルの名前。</p>
               <p>パラメータファイルはパラメータを 1 行ずつ格納します。空行を入れることもできます。 Perl と同じように、「#」で始まるコメント行を入れることもできます。コメントを入れる場合は、行の最初の文字を「#」とし、一行全体がコメントになります。パラメータ行は「param_name = param_value」という書式で書きます。「=」に隣接して空白を入れても構いませんし、入れなくても構いません。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>-debug</p>
            </td>
            <td>
	       <p>このオプションを指定すると、スクリプトが実行されるのと同時に、パラメータ置換が最後まで行われた結果のスクリプトが、現在の作業ディレクトリ下に「&lt;元のスクリプト名&gt;.substituted」という名前で生成されます。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>-dryrun</p>
            </td>
            <td>
               <p>このオプションを指定すると、スクリプトは実行されません。パラメータ置換が最後まで行われた結果のスクリプトが、現在の作業ディレクトリ下に「&lt;元のスクリプト名&gt;.substituted」という名前で生成されます。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>script</p>
            </td>
            <td>
               <p>Pig スクリプト。 Pig スクリプトはコマンドラインの最後の要素に置きます。</p>
               <ul>
                  <li>
                     <p>コマンドラインかパラメータファイルでパラメータを指定した時には、スクリプト中に出現する $param_name が置換されます。</p>
                  </li>
                  <li>
                     <p>スクリプト中でパラメータ名を展開したくない場合には、パラメータ名をバックスラッシュ ( \ ) でエスケープします。</p>
                  </li>
               </ul>
            </td>
         </tr>
         <tr>
            <td>
               <p>%declare</p>
            </td>
            <td>
               <p>Pig スクリプト中のプリプロセッサ文。</p>
               <p>パラメータの値を定義します。値の中で他のパラメータを使うこともできます。</p>
               <p>declare 文は Pig スクリプトを実行する前に処理されます。</p>
               <p>declare 文で定義されたパラメータの値のスコープは、 declare 文に後続するすべての行です。ただし、同じ名前のパラメータを定義する declare 文がもうひとつある場合は、その文の前までです。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>%default</p>
            </td>
            <td>
               <p>Pig スクリプト中のプリプロセッサ文。</p>
               <p>パラメータのデフォルト値を定義するために使います。デフォルト値はもっとも低い優先度を持ち、他の方法で値が指定されていない場合に限って使われます。</p>
               <p>default 文は Pig スクリプトを実行する前に処理されます。</p>
               <p>スコープは %declare と同じです。</p>
            </td>
         </tr>
   </table>
   </section></section>
   
   <!-- ++++++++++++++++++++++++++++++++++ -->
   <section>
   <title>用法</title>
   <p>パラメータ置換を使うことで、 Pig スクリプトにパラメータを含ませて、実行時に値を与えることができます。たとえば、当日の日付のデータを使うジョブを毎日走らせる必要がある場合を考えてみてください。この時、日付をパラメータとして取るスクリプトを書けば、サポートされているいずれかの方法で、当日の日付をパラメータの値に指定してスクリプトを実行することができます。</p>
   
   <section>
   <title>パラメータを指定する</title>
   <p>パラメータ名とパラメータの値は次のように指定できます:</p>
   <ul>
      <li>
         <p>コマンドライン中で指定する。</p>
      </li>
      <li>
         <p>コマンドラインで指定したパラメータファイル中で指定する。</p>
      </li>
      <li>
         <p>Pig スクリプト中の declare 文で指定する。</p>
      </li>
      <li>
         <p>Pig スクリプト中の default 文で指定する。</p>
      </li>
   </ul>
   <p>パラメータ置換はマクロの中では使えません。パラメータの値をマクロ中で使う場合は、トップレベルの呼び出しで明示的にパラメータ置換を行い、マクロに引数として渡す必要があります (<a href="#define-macros">DEFINE (マクロ)</a> を見てください) 。</p>
   </section>
   
   <section>
   <title>優先順位</title>
   <p>パラメータの優先順位は次の通りです:</p>
   <ul>
      <li>
         <p>最高 - declare 文で定義したパラメータ</p>
      </li>
      <li>
         <p>次点 - コマンドラインで指定したパラメータ</p>
      </li>
      <li>
         <p>最低 - パラメータファイルで指定したパラメータ</p>
      </li>
   </ul>
   </section>
   
   <section>
   <title>処理順序と優先順位</title>
   <p>パラメータは次のように処理されます:</p>
   <ul>
      <li>
         <p>コマンドラインで指定した順番でパラメータが読み込まれます。</p>
      </li>
      <li>
         <p>コマンドラインで指定した順番でパラメータファイルが読み込まれます。それぞれのファイルについて、出現順にパラメータが処理されます。</p>
      </li>
      <li>
         <p>プリプロセッサ文の declare と default が、 Pig スクリプト中での出現順に処理されます。</p>
      </li>
   </ul>
   </section></section>
  
  
    <!-- ++++++++++++++++++++++++++++++++++ --> 
     <section>
   <title>使用例</title> 
   <section>
   <title>コマンドラインでパラメータを指定する</title>
   <p>データファイル 'mydata' と Pig スクリプト 'myscript.pig' が次のような内容だとします。</p>

<p>mydata </p>
<source>
1       2       3
4       2       1
8       3       4
</source>
 
 <p>myscript.pig</p>
<source>
A = LOAD '$data' USING PigStorage() AS (f1:int, f2:int, f3:int);
DUMP A;
</source>

<p>次の例では、パラメータ data にコマンドラインで値 mydata を指定しています。もしコマンドラインで指定したパラメータ名 data と、スクリプト中のパラメータ名 $data が一致しなかったら、このスクリプトは実行できません。パラメータで指定された値 (mydata) が見つからなかった場合、エラーが発生します。</p>
<source>
$ pig -param data=mydata myscript.pig

(1,2,3)
(4,2,1)
(8,3,4)
</source>
 </section> 
   
<!-- ++++++++++++++++++++++++++++++++++ --> 
   <section>
   <title>パラメータファイルでパラメータを指定する</title>
   <p>'myparams' という名前のパラメータファイルの内容が次のとおりだとします。</p>
<source>
# my parameters
data1 = mydata1
cmd = `generate_name`
</source>

   
   <p>次の例では、パラメータとそれに紐づく値をパラメータファイルを通じて指定しています。</p>
<source>
$ pig -param_file myparams script2.pig
</source>
   
   </section>
 
 <!-- ++++++++++++++++++++++++++++++++++ -->   
   <section>
   <title>declare 文でパラメータを指定する</title>
   <p>次の例では、コマンド (generate_date) を実行した結果の標準出力の内容をパラメータの値として使っています。</p>
<source>
%declare CMD `generate_date`;
A = LOAD '/data/mydata/$CMD';
B = FILTER A BY $0>'5';

<em>以下続く ... </em>
</source>
   
   </section>

<!-- ++++++++++++++++++++++++++++++++++ -->    
   <section>
   <title>default 文でパラメータを指定する</title>
   <p>次の例では、パラメータ DATE に、 Pig スクリプト中の default 文を使ってデフォルト値 '20090101' を指定しています。もし DATE の値が他の場所で指定されていなければ、デフォルト値 '20090101' が使われます。</p>
<source>
%default DATE '20090101';
A = load '/data/mydata/$DATE';

<em>以下続く ... </em>
</source>

   </section>
   
   <!-- ++++++++++++++++++++++++++++++++++ --> 
   <section>
   <title>文字列をパラメータの値として指定する</title>
   <p>次の例のように、文字列 (ここでは「Joe's URL」) は単一引用符か二重引用符で括って指定できます。文字列中の引用符はエスケープできます。</p>
<source>
%declare DES 'Joe\'s URL';
A = LOAD 'data' AS (name, description, url);
B = FILTER A BY description == '$DES';
 
<em>以下続く ... </em>
</source>
   
   <p>次の例の「mydata」のように、特殊文字を含まず 1 語からなる値は、引用符に括る必要はありません。</p>
<source>
$ pig -param data=mydata myscript.pig
</source>   
</section>
   
   <!-- ++++++++++++++++++++++++++++++++++ --> 
   <section>
   <title>コマンドの結果をパラメータの値として指定する</title>
   <p>次の例では、コマンドをバッククオートに括って指定しています。パラメータ mycmd と date は、 declare 文の中で置換されます。そして、展開結果のコマンドが実行され、 LOAD 文を実行する前にコマンドの標準出力がパス中で展開されます。</p>
<source>
%declare CMD `$mycmd $date`;
A = LOAD '/data/mydata/$CMD';
B = FILTER A BY $0>'5';
 
<em>以下続く ... </em>
</source>
   </section>
   </section>
   </section>


</body>
</document>

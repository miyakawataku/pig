<?xml version="1.0" encoding="UTF-8"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and limitations under the License.
-->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document>
  <header>
    <title>制御構造</title>
  </header>
  <body>
  

<!-- ============================================ -->       
<section id="embed-python">
<title>埋め込み Pig - Python と JavaScript </title>
   
<p>制御構造を有効にするためには、 Pig Latin 文と Pig コマンドを Python か JavaScript などスクリプト言語に埋め込みます。埋め込み Pig は、 JDBC のようなコンパイル・バインド・実行のモデルを使います。 Python では、 Jython の JAR ファイルをクラスパスに含めます。 JavaScript では、 Rhino の JAR ファイルをクラスパスに含めます。</p>

<p>埋め込み先のホスト言語と、埋め込み Pig が使う UDF の言語は完全に直行です。たとえば、 Python UDF を登録する Pig Latin 文は Python, JavaScript, Java のいずれにも組み込めます。例外は「複合」スクリプトで、この場合はホスト言語と UDF の言語が一致する必要があります (<a href="udf.html#python-advanced">Python の高度な話題</a> と <a href="udf.html#js-advanced">JavaScript の高度な話題</a> を見てください) 。</p>


<!-- ============================================== -->
<section id="invocation-basics">
<title>呼び出しの基礎</title>
<p>埋め込み Pig が使えるのはバッチモードだけです。対話モードでは使えません。 Pig コマンドラインで <code>--embedded</code> オプションを指定することで埋め込み Pig が使えます。このオプションには、引数として埋め込み先の言語 (Python か JavaScript) が指定できます。引数を指定しない場合には、リファレンス実装である Python が指定されたものとみなされます。</p>

 <p><strong>Python</strong></p>
 <source>
 $ pig myembedded.py
OR
$ java -cp &lt;jython jars&gt;:&lt;pig jars&gt;; [--embedded python] /tmp/myembedded.py
 </source>
 <p></p>
 <p>Pig はスクリプトの <code>#!/usr/bin/python</code> という行を認識します。</p>
 
  <source>
#!/usr/bin/python 

# Pig クラスをインポート
from org.apache.pig.scripting import Pig 

# コンパイル: compile メソッドはパイプラインを表す Pig オブジェクトを戻します
P = Pig.compile("a = load '$in'; store a into '$out';")

input = 'original'
output = 'output'

# 束縛して実行
result = P.bind({'in':input, 'out':output}).runSingle()

if result.isSuccessful() :
    print 'Pig job succeeded'
else :
    raise 'Pig job failed'
 </source>

<p><strong>JavaScript</strong></p>
<source>
$ pig myembedded.js
OR
$ java -cp &lt;rhino jars&gt;:&lt;pig jars&gt;; [--embedded javascript] /tmp/myembedded.js
</source>
<p>Pig は *.js の拡張子を認識します。</p>
<source>
importPackage(Packages.org.apache.pig.scripting.js) 

Pig = org.apache.pig.scripting.js.JSPig

function main() {
    input = "original"
    output = "output"

    P = Pig.compile("A = load '$in'; store A into '$out';") 

    result = P.bind({'in':input, 'out':output}).runSingle() 

    if (result.isSuccessful()) {
        print("Pig job succeeded")
    } else {
        print("Pig job failed")
    }   
}
</source>

<p><strong>呼び出しプロセス</strong></p>

<p>You invoke Pig in the host scripting language through an embedded <a href="#pig-Object">Pig object</a>. </p>  
<p>ホスト言語から <a href="#pig-Object">Pig オブジェクト</a>を通じて Pig を呼び出します。</p>  

<p><strong>コンパイル:</strong> compile は Pig クラスの静的関数です。パイプラインを定義する Pig Latin を引数に取ります:</p>

<source>
# コンパイル: compile メソッドはパイプラインを表す Pig オブジェクトを戻します
P = Pig.compile("""A = load '$in'; store A into '$out';""")
</source>

<p>コンパイルによって Pig オブジェクトを生成します。 Pig オブジェクトは未確定値を含むことができます。たとえば、入力ファイルの場所を確定しない状態のパラメータとしてパイプラインを作成することが考えられます。パラメータはドル記号で始まり、英数字・アンダースコアの連なりで構成します。パラメータの値は Pig オブジェクトの bind() メソッドを呼び出すことで束縛します。すべてのパラメータを束縛していない状態で Pig オブジェクトの run() メソッドを呼ぶとエラーになります。</p>

<p><strong>束縛:</strong> bind メソッドを呼び出してパラメータを変数の値に束縛します。</p>

<source>
input = "original”
output = "output”

# 束縛: bind メソッドは変数に値を束縛し、 BoundScript オブジェクトを戻します。
Q = P.bind({'in':input, 'out':output}) 
</source>

<p>bind メソッドの呼び出しではすべてのパラメータを束縛する必要があります。束縛されていないパラメータがあると、スクリプトの実行はエラーになります。また、スクリプトのコンパイル時に未確定のパラメータがなかったとしても、 bind メソッドはパラメータ無しで呼ぶ必要があります。</p>

<p><strong>実行:</strong> bind メソッドは <a href="#BoundScript-Object">BoundScript オブジェクト</a>を戻します。 BoundScript オブジェクトはパイプラインを実行するのに使えます。パイプラインを実行するための最も単純な方法は、 runSingle メソッドを呼ぶことです。ただし後述するように、 runSingle メソッドが成功するのはパラメータに単一の変数セットを束縛している場合のみです。複数の変数セットを束縛している場合に runSingle メソッドを呼ぶと例外が投げられます。</p>

<source>
result = Q.runSingle()
</source>

<p>runSingle メソッドは <a href="#PigStats-Object">PigStats オブジェクト</a>を戻します。 PigStats オブジェクトは実行が成功したか失敗したかを表します。成功した場合は、実行統計情報も得られます。</p>


<p><strong>Python 埋め込みの例</strong></p>
<p>埋め込み Pig の完全な例です。</p>
<source>
#!/usr/bin/python

# Pig クラスをインポートします。
from org.apache.pig.scripting import Pig

# コンパイル: compile メソッドはパイプラインを表す Pig オブジェクトを戻します
P = Pig.compile("""A = load '$in'; store A into '$out';""")

input = "original”
output = "output”

# 束縛: bind メソッドは変数に値を束縛し、 BoundScript オブジェクトを戻します。
Q = P.bind({'in':input, 'out':output}) 

# ここでは 1 つの変数セットをパイプラインに束縛しているので、 runSingle メソッドは PigStats オブジェクトを戻します。
# 複数の変数セットを束縛した場合には、代わりに run メソッドを呼びます。
# run メソッドは PigStats のリストを戻します。
result = Q.runSingle()

# 結果チェック
if result.isSuccessful():
    print "Pig job succeeded"
else:
    raise "Pig job failed"    
</source>

<p>あるいは、単に次のようにします。</p>

<source>
#!/usr/bin/python

# Pig クラスをインポートします。
from org.apache.pig.scripting import Pig

in = "original”
out = "output”

# パラメータをローカル変数の値に暗黙的に束縛します
result= Pig.compile("""A = load '$in'; store A into '$out';""").bind().runSingle() 

if result.isSuccessful():
    print "Pig job succeeded"
else:
    raise "Pig job failed"
</source>
</section> 

<!-- ============================================== -->
<section id="invocation-details">
<title>呼び出しの詳細</title>
<p>前節で述べた 3 つの API (compile, bind, run) はいずれも、やりたいことに応じていくつかの変種があります。</p>

<section>
<title>コンパイル</title>
<p>前節で述べたように、基本的なメソッドである compile メソッドは、単にパイプラインを表す Pig Latin 文を引数に取ります。加えて、 compile メソッドはパイプラインの名前も取ることができます。この名前は、 PigRunner Java API 経由で組み込みスクリプトが実行された時にのみ使われます (この章で後述します) 。</p>

<source>
P = Pig.compile("P1", """A = load '$in'; store A into '$out';""")
</source>

<p>文字列として Pig スクリプトを与える以外に、スクリプトをファイルに保存して、そのファイル名を指定してコンパイルすることもできます:</p>
<source>
P = Pig.compileFromFile("myscript.pig")
</source>

<p>パイプラインに名前を付けることもできます:</p>
<source>
P = Pig.compileFromFile("P2", "myscript.pig")
</source>
</section>


<section>
<title>束縛</title>
<p>もっとも単純な形では、 bind メソッドは引数を取らずに呼び出せます。この場合、暗黙的なパラメータの束縛が行われます。 Pig は、スクリプト内で指定された名前の変数から、内部的にパラメータのマップを構築します。</p>

<source>
Q = P.bind() 
</source>

<p>最後に、 1 つのパイプラインを複数のパラメータセット、たとえば複数の日付に対して並行して実行することができます。この場合、 bind メソッドは 1 回の呼び出しでパラメータのマップのリストを取ります。次の例では、パイプラインを US, UK, ブラジル について呼び出しています。</p>

<source>
P = Pig.compile("""A = load '$in';
                   B = filter A by user is not null;
                   ...
                   store Z into '$out';
                """)

Q = P.bind([{'in':'us_raw','out':'us_processed'},
        {'in':'uk_raw','out':'uk_processed'},
        {'in':'brazil_raw','out':'brazil_processed'}])

results = Q.run() # it blocks until all pipelines are completed

for i in [0, 1, 2]:
    result = results[i]
    ... # check result for each pipeline

</source>
</section>

<section>
<title>実行</title>

<p>これまで見てきたように、スクリプトを実行するために最も単純なやり方は runSingle メソッドを引数なしで呼び出すことです。これに加えて、 Java の Properties オブジェクトか、プロパティのリストを格納したファイルを引数として渡すこともできます。引数として渡したプロパティは、コマンドラインから渡したプロパティと同様に扱われます。</p>

<source>
# Jython スクリプト

from java.util import Properties
... ...

props = Properties()
props.put(key1, val1)  
props.put(key2, val2) 
... ... 

Pig.compile(...).bind(...).runSingle(props)
</source>
<p>より汎用的な run メソッドを使うと、複数のパイプラインを同時に動かすことができます。この場合、それぞれのパイプラインの結果を表す PigStats のリストが戻ります。メソッドの使い方については前節の例を見てください。</p>
<p>runSingle と同様に、 Java プロパティかプロパティファイルを渡して呼び出すこともできます。</p>
</section>

<section>
<title>スクリプトにパラメータを渡す</title>
<p>スクリプトの中でパラメータを定義し、コマンドラインからパラメータを渡すことができます。パラメータをスクリプトに渡すには 2 つの方法があります:</p>
<p><strong>1. -param</strong></p>
<p>通常の Pig のパラメータ置換と同じように、 Pig のコマンドラインから -param オプションか -param_file オプションを指定することで、パラメータを渡すことができます。 Pig Latin スクリプトに変数を束縛する時、渡したパラメータは束縛変数として扱われます。たとえば、下記の Python スクリプトは次のように呼び出せます: pig –param loadfile=student.txt script.py</p>
<source>
#!/usr/bin/python
from org.apache.pig.scripting import Pig

P = Pig.compile("""A = load '$loadfile' as (name, age, gpa);
store A into 'output';""")

Q = P.bind()

result = Q.runSingle()
</source>

<p><strong>2. コマンドライン引数</strong></p>
<p>これは Python のみで利用できる機能ですが、スクリプトファイル名の後のコマンドライン引数を Python に与えることができます。 Python プログラムの中では sys.argv としてコマンドライン引数が得られます。たとえば次のように起動します: pig script.py student.txt 。対応するスクリプトは次のとおりです:</p>
<source>
#!/usr/bin/python
import sys
from org.apache.pig.scripting import Pig

P = Pig.compile("A = load '" + sys.argv[1] + "' as (name, age, gpa);" +
"store A into 'output';");

Q = P.bind()

result = Q.runSingle()
</source>
</section>

</section> 

<section id="pigrunner-api">
<title>PigRunner API</title>

<p>Pig 0.8 以降、 Oozie のようなアプリケーションはコマンドラインから Pig を実行する代わりに Java の PigRunner クラスを使って Pig を実行します。これらアプリケーションのため、 PigRunner インタフェースは埋め込み Pig と適合するように拡張されています。 PigRunner は Python と JavaScript のスクリプトを入力として受け入れます。埋め込みスクリプトは複数のパイプラインを含んでいる可能性があるため、すべてのパイプラインの結果を戻す方法が必要となりました。</p>

<p>後方互換性を維持しながらこれを可能にするため、 PigStats と関連するオブジェクトは次のように拡張されています:</p>
<ul>

<li id="PigStats">PigStats は抽象クラスになりました (これまでの PigStats は SimplePigStats になりました) 。</li>


<li id="SimplePigStats">SimplePigStats は PigStats を継承したクラスです。 SimplePigStats.getAllStats() は null を戻します。</li>

<li id="EmbeddedPigStats">EmbeddedPigStats は PigStats を継承したクラスです。次に挙げる以外のメソッドはすべて null を戻します。</li>


<li id="isembedded">isEmbedded() は埋め込み Pig 用の抽象メソッドです。</li>

<li id="stats-messages">PigStats クラスには getAllStats() と getAllErrorMessages() メソッドが追加されています。 getAllStats() メソッドの戻り値であるマップのキーは、 compile メソッドで指定したパイプラインの名前です。 compile メソッドで名前が指定されていない場合は、内部的に生成された ID が使われます。</li>

<li id="PigProgressNotificationListener2">PigProgressNotificationListener インタフェースのすべてのメソッドはスクリプト ID を引数に取る様になりました。</li>
</ul>
<p>詳細については <a href="#java-objects">Java オブジェクト</a> を見てください。</p>

</section> 


<section>
<title>使用例</title>

<section id="pig-files">
<title>Pig スクリプトを渡す</title>
<p>次の例では、 Pig スクリプト全体を compile メソッドに渡しています。</p>

<source>
#!/usr/bin/python

from org.apache.pig.scripting import Pig

P = Pig.compileFromFile("""myscript.pig""")

input = "original"
output = "output"

result = p.bind({'in':input, 'out':output}).runSingle()
if result.isSuccessful():
    print "Pig job succeeded"
else:
    raise "Pig job failed" 
</source>
</section> 

<section id="convergence">
<title>収束</title>
<p>解くべき問題によっては、必要な値が得られるまでパイプラインを複数回実行する必要があり、その回数があらかじめ分からないことがあります。たとえば機械学習、グラフ走査、そして内挿・外挿・回帰など多くの数値解析などの問題です。次の Python の例では、 Pig スクリプトで反復計算を行っています。</p>

<source>
#!/usr/bin/python

# Pig クラスをインポート
from org.apache.pig.scripting import Pig

P = Pig.compile("""A = load '$input' as (user, age, gpa);
                   B = group A all;
                   C = foreach B generate AVG(A.gpa);
                   store C into '$output';
                """)
# 初期出力
input = "studenttab5"
output = "output-5"
final = "final-output"

for i in range(1, 4):
    # Pig Latin 中の $input と $output に Python の input 変数と output 変数を関連付けます
    Q = P.bind({'input':input, 'output':output})
    results = Q.runSingle()

    if results.isSuccessful() == "FAILED":
        raise "Pig job failed"
    iter = results.result("C").iterator()
    if iter.hasNext():
        tuple = iter.next()
        value = tuple.get(0)
        if float(str(value)) &lt; 3:
            print "value: " + str(value)
            input = "studenttab" + str(i+5)
            output = "output-" + str(i+5)
            print "output: " + output
        else:
           Pig.fs("mv " + output + " " + final)
           break
</source>
</section>

<section id="automated-pig-latin">
<title>Pig Latin の自動生成</title>
<p>多くのフレームワークは Pig Latin を自動生成します。たとえば、データロード時に適切な日付を設定するなどのためです。</p>

<source>
today = sys.argv[1]
P = Pig.compile("""A = load 'fact' using HowlLoader();
                   B = filter A by datestamp = '$date';
                   ...
                   store Z into 'aggregated' using HowlStorage('datestamp = $date');
                """)
P.bind({'date':today}).runSingle()
</source>
</section>


<section>
<title>条件付きコンパイル</title>
<p>コード自動生成のユースケースの一つに、条件付きコンパイルがあります。たとえば、平日と週末で実行すべき処理が違うなどの場合です。</p>

<source>
str = "A = load 'input';" 
if today.isWeekday():
    str = str + "B = filter A by weekday_filter(*);" 
else:
    str = str + "B = filter A by weekend_filter(*);" 
str = str + "C = group B by user;" 
results = Pig.compile(str).bind().runSingle()
</source>
</section>

<section>
<title>並列実行</title>
<p>コード自動生成のその他のユースケースには、同一のパイプラインを並列実行することがあります。たとえば、ひとつのパイプラインを複数のデータセットについて並行して実行したいということがあります。次の例では、パイプラインを US, UK, ブラジルについて実行しています。</p>

<source>
P = Pig.compile("""A = load '$in';
                   B = filter A by user is not null;
                   ...
                   store Z into '$out';
                """)

Q = P.bind([{'in':'us_raw','out':'us_processed'},
        {'in':'uk_raw','out':'uk_processed'},
        {'in':'brazil_raw','out':'brazil_processed'}])

# すべてのパイプラインが完了するまでブロックします
results = Q.run()

for i in [0, 1, 2]:
    result = results[i]
    ... # check result for each pipeline
</source>
</section>

</section> 
   
   
<!-- ====================================================================== -->
 <section id="java-objects">
<title>Java オブジェクト</title>

<!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
 <section id="pig-object">
<title>Pig オブジェクト</title>
<source>
public class Pig {    
    /**
     * ファイルシステムコマンドを実行します。
     * コマンドの実行結果は標準出力か標準エラーへと適切に出力されます。
     *
     * @param cmd
     *     ファイルシステムコマンドと引数をひとつの文字列にしたもの。
     * @throws IOException
     */
    public static void fs(String cmd) throws IOException {...}
    
    /**
     * Pig で使う JAR ファイルを登録します。
     * このメソッドを実行すると、後続するすべてのパイプラインに対して JAR ファイルが登録されます。
     * JAR ファイルをひとつのパイプラインだけに対して登録したい場合は、
     * パイプラインの定義中で REGISTER 文を実行してください。
     *
     * @param jarfile
     *     登録する JAR ファイルのパス。
     * @throws IOException
     *     指定した JAR ファイルが見つからなかった時。
     */
    public static void registerJar(String jarfile) throws IOException {...}
    
    /**
     * Pig で使うスクリプト UDF を登録します。
     * このメソッドを実行すると、スクリプト中のすべての UDF が、
     * 後続するすべてのパイプラインから使用可能になります。
     * UDF をひとつのパイプラインだけに対して登録したい場合は、
     * パイプラインの定義中で REGISTER 文を実行してください。
     *
     * @param udffile
     *     UDF スクリプトのパス。
     * @param namespace
     *     UDF の名前空間。
     * @throws IOException
     */
    public static void registerUDF(String udffile, String namespace) throws IOException {...}
    
    /**
     * UDF あるいはストリーミングコマンドに別名を定義します。
     * この定義は後続するすべてのパイプラインに対して有効になります。
     * 別名をひとつのパイプラインだけに対して定義したい場合は、
     * パイプラインの定義中で DEFINE 文を実行してください。
     *
     * @param alias
     *     定義する別名。
     * @param definition
     *     別名が適宜される対象。
     */
    public static void define(String alias, String definition) throws IOException {...}

    /**
     * Pig Latin 中で使う変数に値を格納します。
     * 格納した値は後続するすべてのパイプラインについて有効になります。
     * ひとつのパイプラインに対してだけ変数を格納したい場合は、
     * パイプラインの定義中で格納してください。
     *
     * @param var
     *     値を格納する変数。
     * @param value
     *     格納する値。
     */
    public static void set(String var, String value) throws IOException {...}
            
    /**
     * Pig のパイプラインを定義します。
     * 
     * @param pl
     *     Pig Latin によるパイプラインの定義。
     * @return
     *     パイプラインを表す Pig オブジェクト。
     * @throws IOException
     *     Pig Latin がコンパイルできない時。
     */
    public static Pig compile(String pl) throws IOException {...}

    /**
     * 名前付きの Pig パイプラインを定義します。
     * この名前を使って他のパイプラインにインポートできるようになります。
     * 
     * @param name
     *     パイプラインの名前。パイプラインの名前空間はグローバルです。
     * @param pl
     *     Pig Latin によるパイプラインの定義。
     * @return
     *     パイプラインを表す Pig オブジェクト。
     * @throws IOException
     *     Pig Latin がコンパイルできない時。
     */
    public static Pig compile(String name, String pl) throws IOException {...}

    /**
     * Pig Latin ファイルから Pig パイプラインを定義します。
     *
     * @param filename
     *     Pig Latin が格納されたファイル。
     *     これは純粋な Pig Latin ファイルである必要があります。
     *     ホスト言語を含むことはできません。
     * @return
     *     パイプラインを表す Pig オブジェクト。
     * @throws IOException
     *     Pig Latin がコンパイルできない時、あるいはファイルが見つからない時。
     */
    public static Pig compileFromFile(String filename) throws IOException {...}

    /**
     * Pig Latin ファイルから Pig パイプラインを定義します。
     * 名前を使って他のパイプラインにインポートできるようになります。
     *
     * @param name
     *     パイプラインの名前。パイプラインの名前空間はグローバルです。
     * @param filename
     *     Pig Latin が格納されたファイル。
     *     これは純粋な Pig Latin ファイルである必要があります。
     *     ホスト言語を含むことはできません。
     * @return
     *     パイプラインを表す Pig オブジェクト。
     * @throws IOException
     *     Pig Latin がコンパイルできない時、あるいはファイルが見つからない時。
     */
    public static Pig compileFromFile(String name, String filename) throws IOException {...}
    
    /**
     * 変数の値を束縛します。
     * すべての Pig Latin パラメータに対して値が与えられる必要があります。
     *
     * @param vars
     *     束縛する変数セットのマップ。
     *     キーは Pig Latin で定義されているパラメータの名前です。
     *     値はパラメータの値を表す文字列です。
     *     ホスト言語中ではこれらの値は定数でも変数でも構いません。
     *     変数である場合は、文字列変数である必要があります。
     * @return
     *     {@link BoundScript} オブジェクト。
     * @throws IOException
     *     いずれかのパラメータに対応するキーがなかった場合、
     *     あるいはサポートされない型の値が与えられた場合。
     */
    public BoundScript bind(Map&lt;String, String&gt; vars) throws IOException {...}
        
    /**
     * 複数の変数セットを束縛します。
     * Pig Latin スクリプトは変数セットごとに並列で実行されます。
     *
     * @param vars
     *     束縛する変数セットのマップのリスト。
     *     キーは Pig Latin で定義されているパラメータの名前です。
     *     値はパラメータの値を表す文字列です。
     *     ホスト言語中ではこれらの値は定数でも変数でも構いません。
     *     変数である場合は、文字列変数である必要があります。
     * @return
     *     {@link BoundScript} オブジェクト。
     * @throws IOException
     *     いずれかのパラメータに対応するキーがなかった場合、
     *     あるいはサポートされない型の値が与えられた場合。
     */
    public BoundScript bind(List&lt;Map&lt;String, String&gt;&gt; vars) throws IOException {...}

    /**
     * ホスト言語中の変数を束縛します (オプショナルな操作) 。
     * これはホスト言語中の変数から Pig Latin パラメータへの暗黙的なマッピングを行います。
     * たとえば、ユーザが Pig Latin 文
     * p = Pig.compile("A = load '$input';");
     * を定義して、 p に対してこのメソッドを呼ぶと、このメソッドはホスト言語中の「input」
     * という変数を探します。
     * 束縛する変数を選択するには、ホスト言語のスコーピング規則が使われます。
     * すべてのホスト言語で、スコープ中の変数を得る機能があるとは限らないため、
     * このメソッドはオプショナルです。
     *
     * @throws IOException
     *     Pig Latin パラメータに対応するホスト言語の変数が存在しない場合、
     *     あるいは変数にサポートされない型の値が入っていた場合。
     */
    public BoundScript bind() throws IOException {...}

}
</source>
</section>

<!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
<section id="BoundScript-Object">
<title>BoundScript Object</title>
<source>
public class BoundScript {
    
    /**
     * パイプラインを Hadoop 上で実行します。
     * 束縛されたクエリがない時は、何も実行されません。
     *
     * @return
     *     {@link PigStats}, または、束縛されたクエリがない時は null。
     * @throws IOException
     */
    public PigStats runSingle() throws IOException {...}
     
    /**
     * パイプラインを Hadoop 上で実行します。
     * 束縛されたクエリがない時は、何も実行されません。
     *
     * @param prop
     *     スクリプトを実行する際に Pig が設定するプロパティのマップ。
     *     This is intended for use with scripting languages that do not support
     *     the Properties object.
     * @return
     *     {@link PigStats}, または、束縛されたクエリがない時は null。
     * @throws IOException
     */
    public PigStats runSingle(Properties prop) throws IOException {...}
    
    /**
     * パイプラインを Hadoop 上で実行します。
     * 束縛されたクエリがない時は、何も実行されません。
     *
     * @param propfile
     *     スクリプトを実行する際に Pig が設定するプロパティを格納したファイル。
     * @return
     *     {@link PigStats}, または、束縛されたクエリがない時は null。
     * @throws IOException
     */
    public PigStats runSingle(String propfile) throws IOException {...}

    /**
     * 複数のパイプラインを Hadoop 上で並列に実行します。
     * 束縛されたクエリがない時は、何も実行されません。
     * 変数セットのリストに対して bind メソッドが呼ばれていることを前提とします。
     *
     * @return
     *     bind メソッドに渡されたそれぞれの変数セットのマップに対応する {@link PigStats} のリスト。
     * @throws IOException
     */    
    public List&lt;PigStats&gt; run() throws IOException {...}
    
    /**
     * 複数のパイプラインを Hadoop 上で並列に実行します。
     *
     * @param prop
     *     スクリプトを実行する際に Pig が設定するプロパティのマップ。
     *     This is intended for use with scripting languages that do not support
     *     the Properties object.
     * @return
     *     bind メソッドに渡されたそれぞれの変数セットのマップに対応する {@link PigStats} のリスト。
     * @throws IOException
     */
    public List&lt;PigStats&gt;  run(Properties prop) throws IOException {...}
    
    /**
     * 複数のパイプラインを Hadoop 上で並列に実行します。
     *
     * @param propfile
     *     スクリプトを実行する際に Pig が設定するプロパティを格納したファイル。
     * @return
     *     bind メソッドに渡されたそれぞれの変数セットのマップに対応する {@link PigStats} のリスト。
     * @throws IOException
     */
    public List&lt;PigStats&gt;  run(String propfile) throws IOException {...}

    /**
     * パイプラインに対する ILLUSTRATE を実行します。
     * 結果は標準出力に表示されます。
     *
     * @throws IOException
     *     ILLUSTRATE が失敗した時。
     */
    public void illustrate() throws IOException {...}

    /**
     * パイプラインの実行計画を表示します。
     * 結果は標準出力に表示されます。
     *
     * @throws IOException
     *     EXPLAIN が失敗した時。
     */
    public void explain() throws IOException {...}

    /**
     * パイプライン中の別名のスキーマを表示します。
     * 結果は標準出力に表示されます。
     *
     * @param alias
     *     スキーマを表示する対象の別名。
     * @throws IOException
     *     DESCRIBE が失敗した時。
     */
    public void describe(String alias) throws IOException {...}

}
</source>
</section>  

<!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
<section id="PigStats-Object">
<title>PigStats オブジェクト</title>
<source>
public abstract class PigStats {
    public abstract boolean isEmbedded();
    
    /**
     * 埋め込みスクリプトは 1 つ以上のパイプラインを含む場合があります。
     * スクリプト中で名前が付けられたパイプラインについては、その名前が戻り値のマップのキーになります。
     * パイプラインに名前が付けられていない場合は、パイプラインの ID が戻り値のマップのキーになります。
     */
    public abstract Map&lt;String, List&lt;PigStats&gt;&gt; getAllStats();
    
    public abstract List&lt;String&gt; getAllErrorMessages();      
}
</source>
</section>  

<!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
<section id="PigProgressNotificationListener">
<title>PigProgressNotificationListener オブジェクト</title>
<source>
public interface PigProgressNotificationListener extends java.util.EventListener {

    /** 
     * スクリプトから生成された MapReduce ジョブが実行される直前に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param numJobsToLaunch
     *     スクリプトから生成された MapReduce ジョブの数。
     */
    public void launchStartedNotification(String scriptId, int numJobsToLaunch);
    
    /**
     * MapReduce ジョブのバッチを投入する直前に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param numJobsSubmitted
     *     スクリプトから生成された MapReduce ジョブの数。
     */
    public void jobsSubmittedNotification(String scriptId, int numJobsSubmitted);
    
    /**
     * MapReduce ジョブが実行された後に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param assignedJobId
     *     MapReduce ジョブの ID。
     */
    public void jobStartedNotification(String scriptId, String assignedJobId);
    
    /**
     * MapReduce ジョブが成功した直後に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param jobStats
     *     MapReduce ジョブに紐づく {@link JobStats} オブジェクト。
     */
    public void jobFinishedNotification(String scriptId, JobStats jobStats);
    
    /**
     * MapReduce ジョブが失敗した時に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param jobStats
     *     MapReduce ジョブに紐づく {@link JobStats} オブジェクト。
     */
    public void jobFailedNotification(String scriptId, JobStats jobStats);
    
    /**
     * 結果の出力が成功した直後に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param outputStats
     *     出力に紐づく {@link OutputStats} オブジェクト。
     */
    public void outputCompletedNotification(String scriptId, OutputStats outputStats);
    
    /**
     * 実行の進捗状況が更新された時に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param progress
     *     実行の進捗状況のパーセンテージ。
     */
    public void progressUpdatedNotification(String scriptId, int progress);
    
    /**
     * スクリプトから生成された MapReduce ジョブがすべて完了した直後に呼び出されます。
     *
     * @param scriptId
     *     スクリプトの ID。
     * @param numJobsSucceeded
     *     成功した MapReduce ジョブの数。
     */
    public void launchCompletedNotification(String scriptId, int numJobsSucceeded);
}
</source>
</section>  
</section>    
</section> 


 <!-- ============================================ -->    
<section id="embed-java">
<title>埋め込み Pig - Java </title>

<p>フロー制御を行うため、 Pig Latin 文と Pig コマンドを Java プログラムに埋め込むことができます。</p>

<p>ホスト言語と、 埋め込み Pig に読み込む UDF の言語は、完全に直交する概念です。たとえば、 Java UDF を登録する Pig Latin 文は Python, JavaScript, Java のいずれにも埋め込めます。このルールの例外は複合スクリプトです。複合スクリプトでは、二つの言語は一致する必要があります (<a href="udf.html#python-advanced">Python の高度な話題</a>と <a href="udf.html#js-advanced">JavaScript の高度な話題</a>を見てください) 。</p>

<section id="pigserver">
<title>PigServer インタフェース</title>
<p><a href="http://pig.apache.org/docs/r0.10.0/api/org/apache/pig/PigServer.html">PigServer</a> は Java 埋め込み Pig の中心となるインタフェースです。 PigServer は複数のスレッドからインスタンスできます (かつては、 PigServer が静的なデータを参照していたため、アプリケーション中の複数のスレッドから生成することができませんでした) 。 PigServer はスレッドセーフでは「ありません」。ひとつのオブジェクトを、スレッドをまたがって共有することはできません。</p>
</section>

<section>
<title>使用例</title>
<!-- ++++++++++++++++++++++++++++++++++ -->
<p><strong>ローカルモード</strong></p>
<p>idlocal.java - /etc/passwd ファイルからユーザ ID を抽出する Pig Latin 文を実行するプログラムです。まず、 /etc/passwd ファイルを作業ディレクトリにコピーしてください。</p>
<source>
import java.io.IOException;
import org.apache.pig.PigServer;
public class idlocal{ 
    public static void main(String[] args) {
        try {
            PigServer pigServer = new PigServer("local");
            runIdQuery(pigServer, "passwd");
        }
        catch(Exception e) {
        }
     }
    public static void runIdQuery(PigServer pigServer, String inputFile) throws IOException {
        pigServer.registerQuery("A = load '" + inputFile + "' using PigStorage(':');");
        pigServer.registerQuery("B = foreach A generate $0 as id;");
        pigServer.store("B", "id.out");
    }
}
</source>

<p>現在の作業ディレクトリでプログラムをコンパイルします (現在の作業ディレクトリに idlocal.class が出力されます。したがって、プログラムを実行する際には “.” をクラスパスに含めます) 。</p>
<source>
$ javac -cp pig.jar idlocal.java
</source>
<p>現在の作業ディレクトリでプログラムを実行します。実行結果については、出力ファイル id.out を見てください。</p>
<source>
Unix:   $ java -cp pig.jar:. idlocal
Cygwin: $ java –cp '.;pig.jar' idlocal
</source>

<!-- ++++++++++++++++++++++++++++++++++ -->
<p><strong>Mapreduce モード</strong></p>
<p>$HADOOPDIR が hadoop-site.xml が含まれるディレクトリを指すように設定します。</p>
<source>
$ export HADOOPDIR=/yourHADOOPsite/conf 
</source>
<p>idmapreduce.java - /etc/passwd ファイルからユーザ ID を抽出する Pig Latin 文を実行するプログラムです。まず、 /etc/passwd ファイルを HDFS 上のホームディレクトリにコピーしてください。</p>
<source>
import java.io.IOException;
import org.apache.pig.PigServer;
public class idmapreduce{
    public static void main(String[] args) {
        try {
            PigServer pigServer = new PigServer("mapreduce");
            runIdQuery(pigServer, "passwd");
        }
        catch(Exception e) {
        }
    }
    public static void runIdQuery(PigServer pigServer, String inputFile) throws IOException {
        pigServer.registerQuery("A = load '" + inputFile + "' using PigStorage(':');")
        pigServer.registerQuery("B = foreach A generate $0 as id;");
        pigServer.store("B", "idout");
    }
}
</source>
<p>現在の作業ディレクトリでプログラムをコンパイルします (現在の作業ディレクトリに idmapreduce.class が出力されます。したがって、プログラムを実行する際には “.” をクラスパスに含めます) 。</p>
<source>
$ javac -cp pig.jar idmapreduce.java
</source>
<p>現在の作業ディレクトリでプログラムを実行します。実行結果については、 Hadoop 上の idout ディレクトリを見てください。</p>
<source>
Unix:   $ java -cp pig.jar:.:$HADOOPDIR idmapreduce
Cygwin: $ java –cp '.;pig.jar;$HADOOPDIR' idmapreduce
</source>

</section>
</section>


 <!-- ============================================ -->    
   <section id="macros">
   <title>Pig マクロ</title> 
   <p>Pig Latin ではマクロの定義・展開・インポートができます。</p>

  <!-- ========================== -->
  <section id="define-macros">
   <title>DEFINE (マクロ)</title>
   <p>Pig のマクロを定義します。</p>
   
 <section>
   <title>文法</title>
   <p>マクロ定義</p>
   <table>
      <tr> 
            <td>
               <p>DEFINE macro_name (param [, param ...]) RETURNS {void | alias [, alias ...]} { pig_latin_fragment }; </p>
            </td>
      </tr> 
   </table>
    <p id="expand-macros">マクロ展開</p>
      <table>
      <tr> 
            <td>
               <p>alias [, alias ...] = macro_name (param [, param ...]) ; </p>
            </td>
      </tr> 
   </table>
 </section>   
   
<section>
   <title>定義</title>
   <table>
      <tr>
            <td>
               <p>macro_name</p>
            </td>
            <td>
               <p>マクロの名前。マクロの名前はグローバルです。</p>
            </td>
      </tr>
            <tr>
            <td>
               <p>param</p>
            </td>
            <td>
               <p>(オプショナル) カンマ区切りで括弧に括られた引数列です。 Pig の関係の別名を入力として指定できます。引数は Pig Latin 断片内で置き換えられます。</p>
               <p>ユーザ定義関数 (UDF) と異なり、 Pig のマクロは次の型を引数として取ります:</p>
               <ul>
               <li>別名 (識別子)</li>
               <li>整数</li>
               <li>浮動小数点数</li>
               <li>文字列リテラル (引用符に括られた文字列)</li>
               </ul>
               <p>型は引数の定義に含まれません。マクロを書く人の責任で、引数の型をドキュメント化するべきです。</p>
            </td>
      </tr>
      <tr>
            <td>
               <p>void</p>
            </td>
            <td>
               <p>マクロに戻り値としての別名がなければ、 void を指定します。</p>
            </td>
      </tr>
            <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>(オプショナル) 1 つ以上の、 Pig Latin 断片中に出現する関係の別名の、カンマで区切られたリスト。別名はマクロ中で $&lt;alias&gt; という形式で出現する必要があります。</p>
               <p>マクロに戻り値としての別名がなければ、 void を指定します。</p>
            </td>
      </tr>
      <tr>
            <td>
               <p>pig_latin_fragment</p>
            </td>
            <td>
               <p>1 つ以上の、中括弧で括られた Pig Latin 文。</p>
            </td>
      </tr>
    </table>
   </section>
    
   <section>
   <title>用法</title>
<!-- +++++++++++++++++++++++++++++++++++++++++++++++ --> 
   <p><strong>マクロ定義</strong></p>
   <p>マクロ定義は最初の使用箇所以前であれば Pig スクリプト中のどこにでも書けます。マクロ定義は、自身よりも前に定義された他のマクロを参照することができます。再帰的な参照はできません。</p>
   
   <p>次の制限事項があります:</p>
   <ul>
   <li>マクロはネストした <a href="basic.html#nested-block">FOREACH</a> 文のブロックの中では使えません。</li>
   <li>マクロの中に書けるのは <a href="start.html#pl-statements">Pig Latin 文</a>だけです。 <a href="basic.html#register">REGISTER</a> 文は使えません。 ;Grunt で使われる<a href="cmds.html#shell-cmds">シェルコマンド</a>も使えません。</li>
   <li>Macros cannot include a user-defined schema that has a name collision with an alias in the macro.</li>
   <li>マクロ中で<a href="#parameter-sub">パラメータ置換</a>はできません。マクロに対しては明示的に引数を渡す必要があります。パラメータ置換ができるのはトップレベルだけです。</li>
   </ul>

<p>次の例では my_macro という名前のマクロを作っています。マクロを外から見ると別名 A と C だけが見えます。別名 B は外からは見えません。</p>
<source>
DEFINE my_macro(A, sortkey) RETURNS C {
    B = FILTER $A BY my_filter(*);
    $C = ORDER B BY $sortkey;
}
</source>

<!-- +++++++++++++++++++++++++++++++++++++++++++++++ -->
<p><strong>マクロの展開</strong></p>

<p>マクロはマクロ展開構文を使ってインライン展開できます。次の点に注意してください:</p>
<ul>
<li>マクロ中にある外側から見えない別名は、衝突を防ぐためにマクロの名前と連番が前置されます。</li>
<li>マクロ展開は完全な関数呼び出しとして使えるものではありません。再帰的展開はできません。</li>
</ul>
<p>次の例では my_macro (前の例で定義済み) が展開されます。別名 B は外側から見えないので、 macro_my_macro_B_0 という名前に置き換えられます。</p>

<source>
/* 展開前 */

X = LOAD 'users' AS (user, address, phone);
Y = my_macro(X, user);
STORE Y into 'bar';

/* 展開後 */

X = LOAD 'users' AS (user, address, phone);
macro_my_macro_B_0 = FILTER X BY my_filter(*);
Y = ORDER macro_my_macro_B_0  BY user;
STORE Y INTO 'output';
</source>

<!-- +++++++++++++++++++++++++++++++++++++++++++++++ -->
<p><strong>マクロのインポート</strong></p>
<p>他の Pig スクリプト中のマクロをインポートすることもできます (<a href="#import-macros">IMPORT (マクロ)</a> を見てください) 。</p>
</section> 


 <section>
 <title>例</title>
<p>次の例は引数なしのマクロです。</p>
<source>
DEFINE my_macro() returns B {
   D = LOAD 'data' AS (a0:int, a1:int, a2:int);   
   $B = FILTER D BY ($1 == 8) OR (NOT ($0+$2 > $1));
};

X = my_macro();
STORE X INTO 'output';
</source>

<p>次の例では、引数を取って戻り値を戻しています。</p>
<source>
DEFINE group_and_count (A, group_key, reducers) RETURNS B {
   D = GROUP $A BY $group_key PARALLEL $reducers;
   $B = FOREACH D GENERATE group, COUNT($A);
};

X = LOAD 'users' AS (user, age, zip);
Y = group_and_count (X, user, 20);
Z = group_and_count (X, age, 30);
STORE Y into 'byuser';
STORE Z into 'byage';
</source>

<p>次の例では、マクロは別名を戻さないため、 void を指定しています。</p>
<source>
DEFINE my_macro(A, sortkey) RETURNS void {     
      B = FILTER $A BY my_filter(*);     
      C = ORDER B BY $sortkey;
      STORE C INTO 'my_output';  
};

/* このマクロを展開するには、次のようにします */

my_macro(alpha, 'user');
</source>

<p>次の例では名前の衝突が起きます。 B という文字が関係の別名とユーザ定義のスキーマの双方に使われているためです。名前衝突を検出すると、 Pig は例外を投げます。</p>
<source>
DEFINE my_macro(A, sortkey) RETURNS E {     
      B = FILTER $A BY my_filter(*);     
      C = ORDER B BY $sortkey;
      D = LOAD 'in' as (B:bag{});
      $E = FOREACH D GENERATE COUNT(B); 
};
</source>

<p>次の例は、マクロを使う際に引数の型を知ることの重要性を示しています。 my_macro1 から my_macro2 を呼ぶ時に、引数 $outfile を引用符でくくっていることに注意してください。</p>
<source>
-- A: 別名
-- outfile: 出力先のパス (引用符でくくられた文字列)
DEFINE my_macro1(A, outfile) RETURNS void {     
       STORE $A INTO '$outfile'; 
};

-- A: 別名
-- sortkey: 列名 (引用符でくくられた文字列)
-- outfile: 出力先のパス (引用符でくくられた文字列)
DEFINE my_macro2(A, sortkey, outfile) RETURNS void {     
      B = FILTER $A BY my_filter(*);     
      C = ORDER B BY $sortkey;
      my_macro1(C, '$outfile');
   };

   alpha = Load 'input' as (user, age, gpa);
   my_macro2(alpha, 'age', 'order_by_age.txt');
</source>


<p>次の例ではマクロ (group_with_parallel) が他のマクロ (foreach_count) を参照しています。</p>
<source>
DEFINE foreach_count(A, C) RETURNS B {
   $B = FOREACH $A GENERATE group, COUNT($C);
};

DEFINE group_with_parallel (A, group_key, reducers) RETURNS B {
   C = GROUP $A BY $group_key PARALLEL $reducers;
   $B = foreach_count(C, $A);
};
       
/* 展開前 */
 
X = LOAD 'users' AS (user, age, zip);
Y = group_with_parallel (X, user, 23);
STORE Y INTO 'byuser';

/* 展開後 */

X = LOAD 'users' AS (user, age, zip);
macro_group_with_parallel_C_0 = GROUP X by (user) PARALLEL 23;
Y = FOREACH macro_group_with_parallel_C_0 GENERATE group, COUNT(X);
STORE Y INTO 'byuser';
</source>
</section> 
   
  </section>    
   
   
  <!-- ========================== -->
   <section id="import-macros">
   <title>IMPORT (macros)</title>   
   <p>Import macros defined in a separate file.</p>
    <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>IMPORT 'file-with-macro';</p>
            </td>
      </tr> 
   </table>
   </section>
     
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>file-with-macro</p>
            </td>
            <td>
               <p>The name of a file (enclosed in single quotes) that contains one or more macro definitions; for example, 'my_macro.pig' or  'mypath/my_macro.pig'.</p>
               <p></p>
               <p>Macro names are global and all macros share the same name space. While the file can contain more than one macro definition, having two macros with the same name in your execution context will result in an error.</p>
               <p></p>
               <p>Files are imported based on either (1) the given file path or (2) the import path specified via the Pig property pig.import.search.path. If a file path is given, whether absolute or relative to the current directory (starting with . or ..), the import path will be ignored. </p>
               <p></p>
            </td>
         </tr>
      </table>   
   </section>
      
   <section>
   <title>Usage</title>
   <p>Use the IMPORT command to import a macro defined in a separate file into your Pig script. </p>
   <p>IMPORT adds the macro definitions to the Pig Latin namespace; these macros can then be invoked as if they were defined in the same file.</p>
   <p>Macros can only contain Pig Latin statements; Grunt shell commands are not supported.</p>
   
   <p>See also: <a href="#define-macros">DEFINE (macros)</a></p>
     </section> 
     
   <section>
   <title>Example</title>
   <p>In this example, because a path is not given, Pig will use the import path specified in <code>pig.import.search.path</code>.</p>
<source>
/* myscript.pig */
...
...
IMPORT 'my_macro.pig';
...
...
</source>
   
    </section> 
   </section>   
   </section> 

  
 <!-- =========================================== -->    
   <section id="parameter-sub">
   <title>Parameter Substitution</title>
   <section>
   
   <!-- ++++++++++++++++++++++++++++++++++ -->
   <title>Description</title>
   <p>Substitute values for parameters at run time.</p>
   
   <section>
   <title>Syntax: Specifying Parameters Using the Pig Command Line</title>
   <table>
      <tr>
            <td>
               <p>pig {–param param_name = param_value | –param_file file_name} [-debug | -dryrun] script</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>Syntax: Specifying Parameters Using Preprocessor Statements in a Pig Script</title>
   <table>
      <tr>
            <td>
               <p>{%declare | %default} param_name param_value</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>pig</p>
            </td>
            <td>
               <p>Keyword</p>
               <p>Note: exec, run, and explain also support parameter substitution.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>–param</p>
            </td>
            <td>
               <p>Flag. Use this option when the parameter is included in the command line.</p>
               <p>Multiple parameters can be specified. If the same parameter is specified multiple times, the last value will be used and a warning will be generated.</p>
               <p>Command line parameters and parameter files can be combined with command line parameters taking precedence. </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>param_name</p>
            </td>
            <td>
               <p>The name of the parameter.</p>
               <p>The parameter name has the structure of a standard language identifier: it must start with a letter or underscore followed by any number of letters, digits, and underscores. </p>
               <p>Parameter names are case insensitive. </p>
               <p>If you pass a parameter to a script that the script does not use, this parameter is silently ignored. If the script has a parameter and no value is supplied or substituted, an error will result.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>param_value</p>
            </td>
            <td>
               <p>The value of the parameter. </p>
               <p>A parameter value can take two forms:</p>
               <ul>
                  <li>
                     <p>A sequence of characters enclosed in single or double quotes. In this case the unquoted version of the value is used during substitution. Quotes within the value can be escaped with the backslash character ( \ ). Single word values that don't use special characters such as % or = don't have to be quoted. </p>
                  </li>
                  <li>
                     <p>A command enclosed in back ticks. </p>
                  </li>
               </ul>
               <p>The value of a parameter, in either form, can be expressed in terms of other parameters as long as the values of the dependent parameters are already defined.</p>
               <p>There are no hard limits on the size except that parameters need to fit into memory.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>–param_file</p>
            </td>
            <td>
               <p>Flag. Use this option when the parameter is included in a file. </p>
               <p>Multiple files can be specified. If the same parameter is present multiple times in the file, the last value will be used and a warning will be generated. If a parameter present in multiple files, the value from the last file will be used and a warning will be generated.</p>
               <p>Command line parameters and parameter files can be combined with command line parameters taking precedence. </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>file_name</p>
            </td>
            <td>
               <p>The name of a file containing one or more parameters.</p>
               <p>A parameter file will contain one line per parameter. Empty lines are allowed. Perl-style (#) comment lines are also allowed. Comments must take a full line and # must be the first character on the line. Each parameter line will be of the form: param_name = param_value. White spaces around = are allowed but are optional.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>–debug</p>
            </td>
            <td>
               <p>Flag. With this option, the script is run and a fully substituted Pig script produced in the current working directory named original_script_name.substituted </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>–dryrun</p>
            </td>
            <td>
               <p>Flag. With this option, the script is not run and a fully substituted Pig script produced in the current working directory named original_script_name.substituted</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>script</p>
            </td>
            <td>
               <p>A pig script. The pig script must be the last element in the Pig command line.</p>
               <ul>
                  <li>
                     <p>If parameters are specified in the Pig command line or in a parameter file, the script should include a $param_name for each para_name included in the command line or parameter file.</p>
                  </li>
                  <li>
                     <p>If parameters are specified using the preprocessor statements, the script should include either %declare or %default.</p>
                  </li>
                  <li>
                     <p>In the script, parameter names can be escaped with the backslash character ( \ ) in which case substitution does not take place.</p>
                  </li>
               </ul>
            </td>
         </tr>
         <tr>
            <td>
               <p>%declare</p>
            </td>
            <td>
               <p>Preprocessor statement included in a Pig script.</p>
               <p>Use to describe one parameter in terms of other parameters.</p>
               <p>The declare statement is processed prior to running the Pig script. </p>
               <p>The scope of a parameter value defined using declare is all the lines following the declare statement until the next declare statement that defines the same parameter is encountered.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>%default</p>
            </td>
            <td>
               <p>Preprocessor statement included in a Pig script.</p>
               <p>Use to provide a default value for a parameter. The default value has the lowest priority and is used if a parameter value has not been defined by other means.</p>
               <p>The default statement is processed prior to running the Pig script. </p>
               <p>The scope is the same as for %declare.</p>
            </td>
         </tr>
   </table>
   </section></section>
   
   <!-- ++++++++++++++++++++++++++++++++++ -->
   <section>
   <title>Usage</title>
   <p>Parameter substitution enables you to write Pig scripts that include parameters and to supply values for these parameters at run time. For instance, suppose you have a job that needs to run every day using the current day's data. You can create a Pig script that includes a parameter for the date. Then, when you run this script you can specify or supply a value for the date parameter using one of the supported methods. </p>
   
   <section>
   <title>Specifying Parameters </title>
   <p>You can specify parameter names and parameter values as follows:</p>
   <ul>
      <li>
         <p>As part of a command line.</p>
      </li>
      <li>
         <p>In parameter file, as part of a command line.</p>
      </li>
      <li>
         <p>With the declare statement, as part of Pig script.</p>
      </li>
      <li>
         <p>With default statement, as part of a Pig script.</p>
      </li>
   </ul>
   <p></p>
   <p>Parameter substitution CANNOT be used inside of macros.  Parameters should be explicitly passed to macros and parameter substitution used only at the top level (see <a href="#define-macros">DEFINE (macros)</a>).</p>
   </section>
   
   <section>
   <title>Precedence</title>
   <p>Precedence for parameters is as follows:</p>
   <ul>
      <li>
         <p>Highest - parameters defined using the declare statement</p>
      </li>
      <li>
         <p>Next - parameters defined in the command line</p>
      </li>
      <li>
         <p>Lowest - parameters defined in a script</p>
      </li>
   </ul>
   </section>
   
   <section>
   <title>Processing Order and Precedence</title>
   <p>Parameters are processed as follows:</p>
   <ul>
      <li>
         <p>Command line parameters are scanned in the order they are specified on the command line. </p>
      </li>
      <li>
         <p>Parameter files are scanned in the order they are specified on the command line. Within each file, the parameters are processed in the order they are listed. </p>
      </li>
      <li>
         <p>Declare and default preprocessors statements are processed in the order they appear in the Pig script. </p>
      </li>
   </ul>
   </section></section>
  
  
    <!-- ++++++++++++++++++++++++++++++++++ --> 
     <section>
   <title>Examples</title> 
   <section>
   <title>Specifying Parameters in the Command Line</title>
   <p>Suppose we have a data file called 'mydata' and a pig script called 'myscript.pig'.</p>

<p>mydata </p>
<source>
1       2       3
4       2       1
8       3       4
</source>
 
 <p>myscript.pig</p>
<source>
A = LOAD '$data' USING PigStorage() AS (f1:int, f2:int, f3:int);
DUMP A;
</source>

<p>In this example the parameter (data) and the parameter value (mydata) are specified in the command line. If the parameter name in the command line (data) and the parameter name in the script ($data) do not match, the script will not run. If the value for the parameter (mydata) is not found, an error is generated.</p>
<source>
$ pig –param data=mydata myscript.pig

(1,2,3)
(4,2,1)
(8,3,4)
</source>
 </section> 
   
<!-- ++++++++++++++++++++++++++++++++++ --> 
   <section>
   <title>Specifying parameters Using a Parameter File</title>
   <p>Suppose we have a parameter file called 'myparams.'</p>
<source>
# my parameters
data1 = mydata1
cmd = `generate_name`
</source>

   
   <p>In this example the parameters and values are passed to the script using the parameter file.</p>
<source>
$ pig –param_file myparams script2.pig
</source>
   
   </section>
 
 <!-- ++++++++++++++++++++++++++++++++++ -->   
   <section>
   <title>Specifying Parameters Using the Declare Statement</title>
   <p>In this example the command is executed and its stdout is used as the parameter value.</p>
<source>
%declare CMD `generate_date`;
A = LOAD '/data/mydata/$CMD';
B = FILTER A BY $0>'5';

<em>etc ... </em>
</source>
   
   </section>

<!-- ++++++++++++++++++++++++++++++++++ -->    
   <section>
   <title>Specifying Parameters Using the Default Statement</title>
   <p>In this example the parameter (DATE) and value ('20090101') are specified in the Pig script using the default statement. If a value for DATE is not specified elsewhere, the default value 20090101 is used.</p>
<source>
%default DATE '20090101';
A = load '/data/mydata/$DATE';

<em>etc ... </em>
</source>

   </section>
   
   <!-- ++++++++++++++++++++++++++++++++++ --> 
   <section>
   <title>Specifying Parameter Values as a sequence of Characters</title>
   <p>In this example the characters (in this case, Joe's URL) can be enclosed in single or double quotes, and quotes within the sequence of characters can be escaped. </p>
<source>
%declare DES 'Joe\'s URL';
A = LOAD 'data' AS (name, description, url);
B = FILTER A BY description == '$DES';
 
<em>etc ... </em>
</source>
   
   <p>In this example single word values that don't use special characters (in this case, mydata) don't have to be enclosed in quotes.</p>
<source>
$ pig –param data=mydata myscript.pig
</source>   
</section>
   
   <!-- ++++++++++++++++++++++++++++++++++ --> 
   <section>
   <title>Specifying Parameter Values as a Command</title>
   <p>In this example the command is enclosed in back ticks. First, the parameters mycmd and date are substituted when the declare statement is encountered. Then the resulting command is executed and its stdout is placed in the path before the load statement is run.</p>
<source>
%declare CMD '$mycmd $date';
A = LOAD '/data/mydata/$CMD';
B = FILTER A BY $0>'5';
 
<em>etc ... </em>
</source>
   </section>
   </section>
   </section>


</body>
</document>

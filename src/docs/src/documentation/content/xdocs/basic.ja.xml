<?xml version="1.0" encoding="UTF-8"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">

<document>
  <header>
    <title>Pig Latin Basics (Pig Latin の基本)</title>
  </header>
  <body>

<!-- CONVENTIONS -->
<section>
<title>表記法</title>
   <p>Pig Latin リファレンスマニュアル中の文法例、コード例の表記法は次のとおりです。</p>
   <table>
      <tr>
            <td>
               <p>表記法</p>
            </td>
            <td>
               <p>説明</p>
            </td>
            <td>
               <p>例</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>( )</p>
            </td>
            <td>
               <p>丸括弧は 1 つ以上の項目を囲います。</p>
               <p>括弧はタプルデータ型を表すこともあります。</p>
            </td>
            <td>
               <p>複数の項目:</p>
               <p>(1, abc, (2,4,6) )</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>[ ]</p>
            </td>
            <td>
               <p>角括弧は 1 つ以上の省略可能な項目を囲います。</p>
               <p>角括弧はマップデータ型を表すこともあります。この場合、省略可能な項目を表すためには &lt;&gt; を使います。</p>
            </td>
            <td>
               <p>省略可能な項目:</p>
               <p>[INNER | OUTER]</p>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>{ }</p>
            </td>
            <td>
               <p>波括弧は 2 つ以上の項目から、 1 つを選択するときに使います。</p>
               <p>波括弧は、バッグデータ型を表すこともあります。この場合、選択を表すには &lt;&gt; を使います。</p>
            </td>
            <td>
               <p>2 つの項目から 1 つを選択:</p>
               <p>{ block | nested_block }</p>
              <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>…</p>
            </td>
            <td>
               <p>三点リーダーはコードの一部が繰り返し可能であることを表します。</p>
            </td>
            <td>
               <p>Pig Latin 文:</p>
               <p>cat path [path …]</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>UPPERCASE</p>
               <p></p>
               <p>lowercase</p>
            </td>
            <td>
               <p>一般に、大文字はシステムが用意する要素を表します。</p>
               <p>一般に、小文字はユーザが用意する要素を表します。</p>
               <p>(この表記法は、すべての例で厳密に適用されるわけではありません)</p>
               <p><a href="#case-sensitivity">大文字・小文字の区別</a>を参照してください。</p>
            </td>
            <td>
               <p>Pig Latin 文:</p>
               <p>a = LOAD 'data' AS (f1:int);</p>
               <p></p>
               <ul>
                  <li>
                     <p>LOAD, AS - Pig のキーワード</p>
                  </li>
                  <li>
                     <p>a, f1 - ユーザが用意する別名</p>
                  </li>
                  <li>
                     <p>'data' - ユーザが用意するデータソース</p>
                  </li>
               </ul>
            </td>
         </tr>
   </table>
   </section>   


 <!-- KEYWORDS -->
   <section id="reserved-keywords">
   <title>予約語</title>
   <p>Pig の予約語は次のとおりです。</p>
   <table>
         <tr>
            <td> <p>-- A </p> </td>
            <td> <p>and, any, all, arrange, as, asc, AVG</p> </td>
         </tr>      
      
         <tr>
            <td> <p>-- B </p> </td>
            <td> <p>bag, BinStorage, by, bytearray </p> </td>
         </tr>   

         <tr>
            <td> <p>-- C </p> </td>
            <td> <p>cache, cat, cd, chararray, cogroup, CONCAT, copyFromLocal, copyToLocal, COUNT, cp, cross</p> </td>
         </tr>
         
         <tr>
            <td> <p>-- D </p> </td>
            <td> <p>%declare, %default, define, desc, describe, DIFF, distinct, double, du, dump</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- E </p> </td>
            <td> <p>e, E, eval, exec, explain</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- F </p> </td>
            <td> <p>f, F, filter, flatten, float, foreach, full</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- G </p> </td>
            <td> <p>generate, group</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- H </p> </td>
            <td> <p>help</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- I </p> </td>
            <td> <p>if, illustrate, import, inner, input, int, into, is</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- J </p> </td>
            <td> <p>join</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- K </p> </td>
            <td> <p>kill</p> </td>
         </tr>   
         
         <tr>
            <td> <p>-- L </p> </td>
            <td> <p>l, L, left, limit, load, long, ls</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- M </p> </td>
            <td> <p>map, matches, MAX, MIN, mkdir, mv </p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- N </p> </td>
            <td> <p>not, null</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- O </p> </td>
            <td> <p>onschema, or, order, outer, output</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- P </p> </td>
            <td> <p>parallel, pig, PigDump, PigStorage, pwd</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- Q </p> </td>
            <td> <p>quit</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- R </p> </td>
            <td> <p>register, right, rm, rmf, run</p> </td>
         </tr>  

         <tr>
            <td> <p>-- S </p> </td>
            <td> <p>sample, set, ship, SIZE, split, stderr, stdin, stdout, store, stream, SUM</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- T </p> </td>
            <td> <p>TextLoader, TOKENIZE, through, tuple</p> </td>
         </tr>  
         
         <tr>
            <td> <p>-- U </p> </td>
            <td> <p>union, using</p> </td>
         </tr>  

         <tr>
            <td> <p>-- V, W, X, Y, Z </p> </td>
            <td> <p> </p> </td>
         </tr>  
            
   </table>
   </section>
   
   
 <!-- ++++++++++++++++++++++++++++++++++ --> 
 <!-- CASE SENSITIVITY -->
   <section id="case-sensitivity">
   <title>大文字・小文字の区別</title>
   <p>関係やフィールドの名前 (別名) は大文字・小文字が区別されます。 Pig Latin の関数は大文字・小文字が区別されます。パラメータの名前 (<a href="cont.html#parameter-sub">パラメータ置換</a>を参照) と Pig Latin のキーワード (<a href="#reserved-keywords">予約語</a> を参照) は大文字・小文字が区別されません。</p>
   <p>下の例では、次のようになります:</p>
   <ul>
      <li>
         <p>関係の名前 (別名) A, B, C は大文字・小文字が区別されます。</p>
      </li>
      <li>
         <p>フィールドの名前 (別名) f1, f2, f3 は大文字・小文字が区別されます。</p>
      </li>
      <li>
         <p>関数の名前 PigStorage, COUNT は大文字・小文字が区別されます。</p>
      </li>
      <li>
         <p>キーワード LOAD, USING, AS, GROUP, BY, FOREACH, GENERATE, DUMP は大文字・小文字が区別されません。つまり、それぞれ load, using, as, group, by のように書くこともできます。</p>
      </li>
      <li>
         <p>FOREACH 文の中で、関係 B のフィールドは位置表記 ($0) で参照されています。</p>
      </li>
   </ul>
   <p/>

<source>
grunt> A = LOAD 'data' USING PigStorage() AS (f1:int, f2:int, f3:int);
grunt> B = GROUP A BY f1;
grunt> C = FOREACH B GENERATE COUNT ($0);
grunt> DUMP C;
</source>
</section>
  
 <!-- ++++++++++++++++++++++++++++++++++ -->   
<!-- DATA TYPES AND MORE-->
<section>
<title>データ型その他</title>

<!-- IDENTIFIERS-->
<section id="identifiers">
<title>識別子</title>
<p>識別子には関係の名前 (別名), フィールドの名前 (別名), 変数の名前などが含まれます。 Pig では、識別子はアルファベットから始まって、任意個数のアルファベット、数字、アンダースコアが後ろに続きます。</p>

<p>有効な識別子:</p>
<source>
A
A123
abc_123_BeX_
</source>

<p>無効な識別子:</p>
<source>
_A123
abc_$
A!B
</source>

</section>


<!-- RELATIONS, BAGS, TUPLES, FIELDS-->
   <section id="relations">
   <title>関係、バッグ、タプル、フィールド</title>
      <p><a href="start.html#pl-statements">Pig Latin の文</a>は関係を操作します。関係は次のように定義されます:</p>
   <ul>
      <li>
         <p>関係はバッグです (より正確に言えば、外部バッグです) 。</p>
      </li>
      <li>
         <p>バッグはタプルのコレクションです。</p>
      </li>
      <li>
         <p>タプルはフィールドの順序付き集合です。</p>
      </li>
      <li>
         <p>フィールドはデータの一片です。</p>
      </li>
   </ul>
   <p>Pig の関係はタプルのバッグです。 Pig の関係は関係データベースにおけるテーブルと同一のものです。タプルはテーブルの行に対応します。関係データベースのテーブルとは異なり、 Pig の関係では、すべてのタプルが同じ数のフィールドを持っている必要はなく、また同じ位置のフィールド (列) が同じ型である必要もありません。</p>
   <p>リレーションは順序付けされていません。したがって、タプルが何らかの順序で処理されるということは保証されません。さらに言うと、タプルがなんらかの全順序にしたがって処理されるのでない限り、処理は並列化される可能性があります。</p>
   
   <section id="ref-relation">
   <title>関係への参照</title>
   <p>関係は名前 (別名) によって参照されます。名前は Pig Latin 文で割り当てられます。次の例では、関係の名前 (別名) は A です。</p>
   
   <source>
A = LOAD 'student' USING PigStorage() AS (name:chararray, age:int, gpa:float);
DUMP A;
(John,18,4.0F)
(Mary,19,3.8F)
(Bill,20,3.9F)
(Joe,18,3.8F)
</source>

  <p>別名は他の別名に代入できます。新しい別名は、元の別名が元の関係を指しているところで、同じように使えます。</p>

  <source>
A = LOAD 'student' USING PigStorage() AS (name:chararray, age:int, gpa:float);
B = A;
DUMP B;
</source>
</section>
   
   
   <!-- +++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="ref-field">
   <title>フィールドへの参照</title>
   <p>フィールドは位置表記か名前 (別名) によって参照されます。</p>
   <ul>
      <li>
         <p>位置表記はシステムによって生成されます。位置表記はドル記号 ($) で始まります。また、番号は 0 から始まります。たとえば、 $0, $1, $2 のようにです。</p>
      </li>
      <li>
         <p>名前はスキーマを使ってユーザによって割り当てられます (GROUP 演算子といくつかの関数の場合は、システムによって割り当てられます) 。 Pig キーワードでない限り、どのような名前でも使えます (有効な名前の例については<a href="#identifiers">識別子</a>を参照) 。</p>
      </li>
   </ul>
   <p>上述の関係 A には、次の 3 つのフィールドがあります。</p>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>1 つ目のフィールド</p>
            </td>
            <td>
               <p>2 つ目のフィールド</p>
            </td>
            <td>
               <p>3 つ目のフィールド</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>データ型</p>
            </td>
            <td>
               <p>chararray</p>
            </td>
            <td>
               <p>int</p>
            </td>
            <td>
               <p>float</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>位置表記 (システムが生成) </p>
            </td>
            <td>
               <p>$0</p>
            </td>
            <td>
               <p>$1</p>
            </td>
            <td>
               <p>$2</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>使用可能な名前 (スキーマを用いてユーザが指定)</p>
            </td>
            <td>
               <p>name</p>
            </td>
            <td>
               <p>age</p>
            </td>
            <td>
               <p>gpa</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>フィールドの値 (最初のタプル)</p>
            </td>
            <td>
               <p>John</p>
            </td>
            <td>
               <p>18</p>
            </td>
            <td>
               <p>4.0</p>
            </td>
         </tr>
   </table>
   
   <p>次の例のように、 AS 節を使ってフィールドに名前を割り当てた場合でも、フィールドを参照するのに位置表記を使うことができます。しかし、デバッグを容易にするため、、またコードを分り易くするため、名前を使うほうが良いでしょう。</p>
<source>
A = LOAD 'student' USING PigStorage() AS (name:chararray, age:int, gpa:float);
X = FOREACH A GENERATE name,$2;
DUMP X;
(John,4.0F)
(Mary,3.8F)
(Bill,3.9F)
(Joe,3.8F)
</source>   
   
   <p>次の例では、要求される列 ($3) がスキーマに存在しないため、エラーが発生します (位置表記は $0 から始まります) 。エラーは文が実行される前に検出されます。</p>
   
   <source>
A = LOAD 'data' AS (f1:int,f2:int,f3:int);
B = FOREACH A GENERATE $3;
DUMP B;
2009-01-21 23:03:46,715 [main] ERROR org.apache.pig.tools.grunt.GruntParser - java.io.IOException: 
Out of bound access. Trying to access non-existent  : 3. Schema {f1: bytearray,f2: bytearray,f3: bytearray} has 3 column(s). 
<em>etc ... </em></source>
</section>
   
   
   <!-- +++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="ref-field-complex">
   <title>複合データ型のフィールドへの参照</title>
   <p>前述したように、タプル中のフィールドは、複合型 (バッグ、タプル、マップ) を含む任意のデータ型であることが可能です。</p>
   <ul>
      <li>
         <p>複合データ型のフィールドには、複合データ型のスキーマを使います。</p>
      </li>
      <li>
         <p>複合データ型のフィールドを使うためには、参照外し (参照先の取得) 演算子を使います。</p>
      </li>
   </ul>
   <p>次の例では、データファイルにはネストしたタプルが格納されています。データをロードするためには、複合データ型のスキーマ (この場合はタプル) を使います。そして、タプル中のフィールドにアクセスするためには、参照外し演算子 (t1.t1a, t2.$0 のようなドット) を使います。フィールドに名前を割り当てた場合でも、位置表記を使ってフィールドにアクセスできます。</p>

   
   <source>
cat data;
(3,8,9) (4,5,6)
(1,4,7) (3,7,5)
(2,5,8) (9,5,8)

A = LOAD 'data' AS (t1:tuple(t1a:int, t1b:int,t1c:int),t2:tuple(t2a:int,t2b:int,t2c:int));

DUMP A;
((3,8,9),(4,5,6))
((1,4,7),(3,7,5))
((2,5,8),(9,5,8))

X = FOREACH A GENERATE t1.t1a,t2.$0;

DUMP X;
(3,4)
(1,3)
(2,9)
</source>
</section>
</section>   

<!-- ++++++++++++++++++++++++++++++++++ --> 
<section id="data-types">
<title>データ型</title>

<section>
<title>単純型と複合型</title>
<p></p>

   <table>
      <tr>
            <td>
               <p><strong>単純型</strong></p>
            </td>
            <td>
               <p>説明</p>
            </td>
            <td>
               <p>例</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>int</p>
            </td>
            <td>
               <p>32 ビットの符号付き整数</p>
            </td>
            <td>
               <p>10</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>long</p>
            </td>
            <td>
               <p>64 ビットの符号付き整数</p>
            </td>
            <td>
               <p>データ:     10L あるいは 10l </p>
               <p>ディスプレイ: 10L </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>float</p>
            </td>
            <td>
               <p>32 ビットの浮動小数点数</p>
            </td>
            <td>
               <p>データ:     10.5F あるいは 10.5f あるいは 10.5e2f あるいは 10.5E2F</p>
               <p>表示: 10.5F あるいは 1050.0F</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>double</p>
            </td>
            <td>
               <p>64 ビットの浮動小数点数</p>
            </td>
            <td>
               <p>Data:     10.5 あるいは 10.5e2 あるいは 10.5E2</p>
               <p>Display: 10.5 あるいは 1050.0</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>chararray</p>
            </td>
            <td>
               <p>UTF-8 エンコーディングの文字の配列 (文字列)</p>
            </td>
            <td>
               <p>hello world</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bytearray</p>
            </td>
            <td>
               <p>バイト列 (blob)</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
                  <tr>
            <td>
               <p>boolean</p>
            </td>
            <td>
               <p>boolean</p>
            </td>
            <td>
               <p>true/false (大文字・小文字を区別しない)</p>
            </td>
         </tr>
         <tr>
            <td>
               <p><strong>複合型</strong></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>タプル</p>
            </td>
            <td>
               <p>フィールドの順序付き集合</p>
            </td>
            <td>
               <p>(19,2)</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>バッグ</p>
            </td>
            <td>
               <p>タプルのコレクション</p>
            </td>
            <td>
               <p>{(19,2), (18,1)}</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>マップ</p>
            </td>
            <td>
               <p>キーと値のペアの集合</p>
            </td>
            <td>
               <p>[open#apache]</p>
            </td>
         </tr>
   </table>
   
   <p>データ型については一般に次の原則が適用されます:</p>
   <ul>
      <li>
         <p>フィールドに型を割り当てるにはスキーマを使います。もし型が割り当てられていない場合は、フィールドはデフォルトで bytearray と解釈され、また使用される際の文脈に従って暗黙の型変換が行われます。たとえば、関係 B では、 f1 は整数に変換されます。これは加算対象の 5 が整数だからです。関係 C では、 f1 と f2 どちらも型が分からないため、 double 型に変換されます。</p>
      <source>
A = LOAD 'data' AS (f1,f2,f3);
B = FOREACH A GENERATE f1 + 5;
C = FOREACH A generate f1 + f2;
</source>
      </li>
   </ul>

   <ul>
      <li>
         <p>load 文でスキーマが定義される場合は、ロード関数はスキーマを矯正しようと試みます。データがスキーマに合わない場合は、 null 値になるか、エラーが発生します。</p>
      <source>
A = LOAD 'data' AS (name:chararray, age:int, gpa:float);
</source>
      </li>
   </ul>
   <p></p>
   <ul>
      <li>
         <p>サポートされていない明示的キャストを使った場合は、エラーが発生します。たとえば、 chararray は int にキャストできません。</p>
         <source>
A = LOAD 'data' AS (name:chararray, age:int, gpa:float);
B = FOREACH A GENERATE (int)name;

エラーが発生します …</source>
      </li>
   </ul>

   <p></p>
   <ul>
      <li>
         <p>Pig が型の不一致を暗黙キャストによって解決できない場合は、エラーが発生します。たとえば、 chararray と float を足し合わせることはできません (<a href="#types-table-add">加算演算子 (+) 減算演算子 (-) の型テーブル</a> を参照) 。</p>
      <source>
A = LOAD 'data' AS (name:chararray, age:int, gpa:float);
B = FOREACH A GENERATE name + gpa;

エラーが発生します …</source>
      </li>
   </ul>
   <p>すべての型には対応する<a href="#Schemas">スキーマ</a>があります。</p>
   </section>
   
   <section id ="tuple">
   <title>タプル</title>
   <p>タプルはフィールドの順序付き集合です。</p>
   
   <section>
   <title>文法</title>
   <table>
        <tr>
            <td>
               <p>( field [, field …] )  </p>
            </td>
        </tr>
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
      <tr>
            <td>
               <p>(  )</p>
            </td>
            <td>
               <p>タプルは丸括弧 ( ) によって囲われます。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>field</p>
            </td>
            <td>
               <p>データの一片。フィールドはタプルやバッグを含む任意のデータ型であることが可能です。</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>使用法</title>
   <p>タプルは 1 個以上のフィールドを含む行だと考えられます。それぞれのフィールドは任意の型であり、またフィールドにはデータが存在する場合と存在しない場合があります。フィールドのデータが存在しない場合、次のようになります:</p>
   <ul>
      <li>
         <p>Load 文では、結果のタプルのフィールドの値は null になります。値が存在しないとみなされて null に変換される条件は、ロード関数ごとに異なります。たとえば、 PigStorage 関数では、空のフィールドが null に変換されます。</p>
      </li>
      <li>
         <p>Load 文以外では、要求されるフィールドがタプル中に存在しない場合、 null になります。</p>
      </li>
   </ul>
   <p></p>
   <p><a href="#tuple-schema">タプルのスキーマ</a>も参照してください。</p>
   </section>
   
   <section>
   <title>Example</title>
   <p>次の例では、タプルは 3 つのフィールドを含みます。</p>
   <source>(John,18,4.0F)</source>
   </section></section>
   
   <section id="bag">
   <title>バッグ</title>
   <p>バッグはタプルのコレクションです。</p>
   
   <section>
   <title>文法: 内部バッグ</title>
   <table>
      <tr>
            <td>
               <p>{ tuple [, tuple …] }</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
      <tr>
            <td>
               <p>{  }</p>
            </td>
            <td>
               <p>内部バッグは波括弧 { } で囲われます。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>tuple</p>
            </td>
            <td>
               <p>タプル。</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>使用法</title>
   <p>バッグについては次のルールが適用されます:</p>
   <ul>
      <li>
         <p>バッグは重複したタプルを含むことができます。</p>
      </li>
      <li>
         <p>バッグはフィールド数の異なるタプルを含むことができます。ただし、アクセスしたフィールドが存在しない場合には、 null 値が生成されます。</p>
      </li>
      <li>
         <p>バッグは型の異なるタプルを含むことができます。ただし、バッグを実際に処理する際には、処理対象のタプルのスキーマは同一である必要があります。たとえば、半数のタプルが chararray のフィールドを持ち、もう半数のタプルが float のフィールドを持っていた時に、数値計算の対象とするタプルはどちらか半数である必要があります。なぜなら、 chararray のフィールドは null に変換されてしまうからです。</p>
         <p>バッグには、外部バッグ (あるいは関係) と内部バッグの 2 つの形式があります。</p>
      </li>
   </ul>
   <p></p>
   <p><a href="#bag-schema">バッグのスキーマ</a>も参照してください。</p>
   </section>
   
   <section>
   <title>例: 外部バッグ</title>
   <p>次の例では、 A はタプルのバッグ (関係) です。このバッグを、外部バッグと呼びます。</p>
<source>
A = LOAD 'data' as (f1:int, f2:int, f3;int);
DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
</source>
   </section>
   
   <section>
   <title>例: 内部バッグ</title>
   <p>関係 A を最初のフィールドでグループ化して、関係 X を作ったとします。</p>
   <p>次の例では、 X はタプルの外部バッグ (関係) です。関係 X のタプルは 2 つのフィールドを持っています。最初のフィールドの型は int, 2 つ目のフィールドの型はバッグです。後者のフィールドのバッグを、内部バッグと呼びます。</p>
<source>
X = GROUP A BY f1;
DUMP X;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(8,{(8,3,4)})
</source>
   </section>
   </section>
   
   <section id="map">
   <title>マップ</title>
   <p>マップはキーと値のペアの集合です。</p>
   
   <section>
   <title>文法 (&lt;&gt; 内は省略可能)</title>
   <table>
      <tr>
            <td>
               <p>[ key#value &lt;, key#value …&gt; ]</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
      <tr>
            <td>
               <p>[ ]</p>
            </td>
            <td>
               <p>Map は角括弧 [ ] で囲います。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>#</p>
            </td>
            <td>
               <p>キーと値はハッシュ記号 # で区切ります。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>key</p>
            </td>
            <td>
               <p>マップ中で重複しない chararray 型の値です。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>value</p>
            </td>
            <td>
               <p>任意のデータ型の値です (デフォルトは bytearray) 。</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>使用法</title>
   <p>マップ中のキーは重複しない値です。</p>

   <p><a href="#map-schema">マップのスキーマ</a>も参照してください。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、マップはキーと値のペアを 2 つ含みます。</p>
<source>[name#John,phone#5551212]</source>
</section></section></section> 
   
   <!-- ++++++++++++++++++++++++++++++++++ --> 
   <section id="nulls">
   <title>Pig Latin における null</title>
   <p>Pig Latin において、 null は SQL での定義にのっとっています。すなわち、未知の値、もしくは存在しない値です。 null はデータに元々存在するか、あるいは演算の結果として生じます。</p>
   <section id="nulls-ops">
   <title>null と演算子と関数</title>
   <p>Pig Latin の演算子と関数は、 null を次のように扱います。</p>
   <table>
      <tr>
            <td>
               <p>演算子</p>
            </td>
            <td>
               <p>動作</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>比較演算子:</p>
               <p>==, !=</p>
               <p>&gt;, &lt;</p>
               <p>&gt;=, &lt;=</p>
            </td>
            <td>
               <p>どちらかの項が null である時、結果は null になります。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>比較演算子:</p>
               <p>matches</p>
            </td>
            <td>
               <p>マッチ対象の文字列、あるいはパターン文字列のどちらかが null である場合、結果は null になります。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>算術演算子:</p>
               <p> + , -, *, /</p>
               <p>% 剰余</p>
               <p>? : 条件演算子</p>
            </td>
            <td>
               <p>いずれかの項が null の場合、結果は null になります。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>null 演算子:</p>
               <p>is null</p>
            </td>
            <td>
               <p>テスト対象の値が null である場合、結果は true になります。 null 以外の場合、結果は false になります (<a href="#null_operators">null 演算子</a> を参照)。</p>
              
            </td>
         </tr>
         <tr>
            <td>
               <p>null 演算子:</p>
               <p>is not null</p>
            </td>
            <td>
               <p>テスト対象の値が null でない場合、結果は true になります。 null の場合、結果は false になります (<a href="#null_operators">null 演算子</a> を参照)。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>参照外し (参照先の取得) 演算子:</p>
               <p>タプル (.) あるいはマップ (#)</p>
            </td>
            <td>
               <p>タプル、あるいはマップが null である場合、結果は null になります。</p>
            </td>
         </tr>
                           <tr>
            <td>
               <p>演算子:</p>
               <p>COGROUP, GROUP, JOIN</p>
            </td>
            <td>
               <p>これら演算子は、 null を違った形で扱います (下記の例を参照) 。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>関数:</p>
               <p>COUNT_STAR</p>
            </td>
            <td>
               <p>null を含むすべての値の数を数えます。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>キャスト演算子</p>
            </td>
            <td>
               <p>null 値をある型から他の型にキャストすると、 結果は null になります。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>関数:</p>
               <p>AVG, MIN, MAX, SUM, COUNT</p>
            </td>
            <td>
               <p>null 値を無視します。</p>
            </td>
         </tr>

         <tr>
            <td>
               <p>関数:</p>
               <p>CONCAT</p>
            </td>
            <td>
               <p>どちらかの項が null である場合、結果は null になります。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>関数:</p>
               <p>SIZE</p>
            </td>
            <td>
               <p>テスト対象の値が null の場合、結果は null になります。</p>
            </td>
         </tr>
   </table>
   
   <p>ブーリアン式が null である場合、次の演算子の挙動に注意してください:</p>
   <ul>
      <li>
         <p>FILTER 演算子 - 条件式の値が null である場合、対象のタプルはフィルタの結果に含まれません (X が null の時、 !X も null になります。結局、フィルタはいずれの場合も排除します) 。</p>
      </li>
      <li>
      <p>条件演算子 - 条件式の値が null である場合、結果は null になります (上述の算術演算子の項目を参照してください) 。</p>
      </li>
   </ul>
   </section>
   
   
   <!-- ++++++++++++++++++++++++++++++++++ --> 
   <section id="nulls-constants">
   <title>null と定数</title>
   <p>null は任意の型の式の位置で、定数として書くことができます。</p>
   <p>次の例では、 a と null が結果になります。</p>
<source>
A = LOAD 'data' AS (a, b, c).
B = FOREACH A GENERATE a, null;
</source>
  
   <p>次の外部結合の例では、どちらかのテーブルに結合キーが存在しなかった場合、 null に置換します。</p>
<source>
A = LOAD 'student' AS (name: chararray, age: int, gpa: float);
B = LOAD 'votertab10k' AS (name: chararray, age: int, registration: chararray, donation: float);
C = COGROUP A BY name, B BY name;
D = FOREACH C GENERATE FLATTEN((IsEmpty(A) ? null : A)), FLATTEN((IsEmpty(B) ? null : B));
</source>
   
   <p>他の式と同じように、 null 定数は暗黙的に、また明示的にキャストできます。</p>
   <p>次の例では、 a と null はいずれも暗黙的に double 型にキャストされます。</p>
<source>
A = LOAD 'data' AS (a, b, c).
B = FOREACH A GENERATE a + null;
</source>
   
   <p>次の例では、 a と null はいずれも int 型にキャストされます。 a は暗黙的に、 null は明示的にキャストされます。</p>
<source>
A = LOAD 'data' AS (a, b, c).
B = FOREACH A GENERATE a + (int)null;
</source>
   </section>
   
      <!-- ++++++++++++++++++++++++++++++++++ -->  
   <section id="nulls-ops-produce">
   <title>結果が null になる演算</title>
   <p>上述の通り、ある種の演算の結果は null になる可能性があります。結果が null になる可能性がある演算は次のとおりです:</p>
   <ul>
      <li>
         <p>0 による除算</p>
      </li>
      <li>
         <p>ユーザ定義関数 (UDF) の戻り値</p>
      </li>
      <li>
         <p>存在しないフィールドの参照外し (参照先の取得)</p>
      </li>
      <li>
         <p>マップ中の存在しないキーの参照外し (参照先の取得) 。たとえば、 info というマップの中身が [name#john, phone#5551212] だった時、 info#address という値を使おうとすると、 null が戻ります。</p>
      </li>
      <li>
         <p>タプル中の存在しないフィールドへのアクセス。</p>
      </li>
   </ul>
   
   <section>
   <title>例: タプル中の存在しないフィールドへのアクセス</title>
   <p>次の例で、フィールドのデータが存在しない場合、フィールドへのアクセスの結果は null になります。</p>
<source>
cat data;
    2   3
4   
7   8   9

A = LOAD 'data' AS (f1:int,f2:int,f3:int)

DUMP A;
(,2,3)
(4,,)
(7,8,9)

B = FOREACH A GENERATE f1,f2;

DUMP B;
(,2)
(4,)
(7,8)
</source>
   
   </section></section>
   
   
      <!-- ++++++++++++++++++++++++++++++++++ -->  
   <section id="nulls-load">
   <title>null とロード関数</title>
   <p>上述の通り、 null は元々データに存在している可能性があります。 null がデータの一部として存在している場合、 null を正しく取り扱うことはロード関数の責任範囲です。何が null に変換されるのかはロード関数に依存します。ただし、ロード関数は null を常に Java の null 値に変換する必要があります。</p>
   <p>Pig Latin のロード関数 (PigStorage や TextLoader 等) はデータが存在しない時に null を生成します。たとえば、空文字列 (chararray) はロードされず、代わりに null に置き換えられます。</p>
   
   <p>PigStorage は LOAD 演算子を使う際のデフォルトのロード関数です。次の例では、名前が null であるレコードをフィルタするのに is not null 演算子を用いています。</p>

 <source>
A = LOAD 'student' AS (name, age, gpa); 
B = FILTER A BY name is not null;
</source>  
   </section>
   
   <section id="nulls_group">
   <title>null と GROUP/COGROUP 演算子</title>
   <p>1 つの関係を GROUP 演算子でグループ化するとき、グループ化キーが null であるレコードは 1 つにまとめてグループ化されます。</p>
   <source>
A = load 'student' as (name:chararray, age:int, gpa:float);
dump A;
(joe,18,2.5)
(sam,,3.0)
(bob,,3.5)

X = group A by age;
dump X;
(18,{(joe,18,2.5)})
(,{(sam,,3.0),(bob,,3.5)})
   </source>
   
<p>複数の関係を GROUP (COGROUP) 演算子でグループ化するとき、グループ化キーが null であるレコードは、関係ごとに別々にグループ化されます。次の例で、結果の関係には null をグループ化キーとするタプルが 2 つあります。 1 つは関係 A のタプルのみを含み、もう 1 つは関係 B のタプルのみを含みます。</p>
   
<source>
A = load 'student' as (name:chararray, age:int, gpa:float);
B = load 'student' as (name:chararray, age:int, gpa:float);
dump B;
(joe,18,2.5)
(sam,,3.0)
(bob,,3.5)

X = cogroup A by age, B by age;
dump X;
(18,{(joe,18,2.5)},{(joe,18,2.5)})
(,{(sam,,3.0),(bob,,3.5)},{})
(,{},{(sam,,3.0),(bob,,3.5)})
</source>
   </section>
   
      <!-- ++++++++++++++++++++++++++++++++++ -->  
   <section id="nulls_join">
   <title>null と JOIN 演算子</title>
   <p>JOIN 演算子は、内部結合の場合、 SQL の標準にしたがって null を除外します (<a href="perf.html#nulls">結合の前に null を除外する</a> を参照)。</p>
<source>
A = load 'student' as (name:chararray, age:int, gpa:float);
B = load 'student' as (name:chararray, age:int, gpa:float);
dump B;
(joe,18,2.5)
(sam,,3.0)
(bob,,3.5)
  
X = join A by age, B by age;
dump X;
(joe,18,2.5,joe,18,2.5)
</source>
   </section>
   
   </section>
  
  
   <!-- ++++++++++++++++++++++++++++++++++ -->  
   <section id="constants">
   <title>定数</title>
   <p>Pig は bytearray 以外のすべてのデータ型について定数表現を用意しています。</p>
   <table>
      <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p><strong>定数の例</strong></p>
            </td>
            <td>
               <p><strong>説明</strong></p>
            </td>
         </tr>
         <tr>
            <td>
               <p><strong>単純データ型</strong></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>int</p>
            </td>
            <td>
               <p>19</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>long</p>
            </td>
            <td>
               <p>19L</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>float</p>
            </td>
            <td>
               <p>19.2F or 1.92e2f</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>double</p>
            </td>
            <td>
               <p>19.2 or 1.92e2</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>chararray</p>
            </td>
            <td>
               <p>'hello world'</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bytearray</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>存在しません。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>boolean</p>
            </td>
            <td>
               <p>true/false</p>
            </td>
            <td>
               <p>大文字・小文字を区別しません。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p><strong>複合データ型</strong></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>タプル</p>
            </td>
            <td>
               <p>(19, 2, 1)</p>
            </td>
            <td>
               <p>この形式の定数はタプルを表します。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>バッグ</p>
            </td>
            <td>
               <p>{ (19, 2), (1, 2) }</p>
            </td>
            <td>
               <p>この形式の定数はバッグを表します。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>マップ</p>
            </td>
            <td>
               <p>[ 'name' # 'John', 'ext' # 5555 ]</p>
            </td>
            <td>
               <p>この形式の定数はマップを表します。</p>
            </td>
         </tr>
   </table>
   <p></p>
   <p>次の点に注意してください:</p>
   <ul>
      <li>
         <p>UTF-8 のシステムでは 'abc' のように印字可能な ASCII 文字を含む文字列が指定できます。また、 '\t' のように制御文字が指定できます。ユニコードに含まれる文字は '\u' から始まる記法で指定できます。たとえば、 '\u0001' は Ctrl-A を 16 進表記で表しています (Wikipedia の記事 <a href="http://ja.wikipedia.org/wiki/ASCII">ASCII</a>, <a href="http://ja.wikipedia.org/wiki/Unicode">Unicode</a>, <a href="http://ja.wikipedia.org/wiki/UTF-8">UTF-8</a> を参照。) 。理屈の上では、 UTF-8 以外のシステム上では UTF-8 でない文字列定数が指定できるはずですが、我々が知る限りこれはテストされていません。</p>
      </li>
      <li>
         <p>long の定数を指定するためには、 l か L を数値の末尾につけます (12345678L のように) 。もし数値が int に収まり切らないにも関わらず l も L も指定されていなければ、パース時に問題が検出されて処理が止まります。</p>
      </li>
      <li>
         <p>Any numeric constant with decimal point (for example, 1.5) and/or exponent (for example, 5e+1) is treated as double unless it ends with f or F in which case it is assigned type float (for example,  1.5f). </p>
         <p>小数点を含む数値定数 (例: 1.5) や指数部定数を含む数値定数 (例: 5e+1) は double 型の値として扱われます。末尾に f か F が付いている場合は float 型の値として扱われます (例: 1.5f) 。</p>
      </li>
   </ul>
   <p>タプル、バッグ、マップのデータ型の定義は定数にも適用されます。</p>
   <ul>
      <li>
         <p>タプルは任意の型のフィールドを含むことができます</p>
      </li>
      <li>
         <p>バッグはタプルのコレクションです</p>
      </li>
      <li>
         <p>マップのキーは chararray である必要があります。キーに紐づく値は任意のデータ型であることができます</p>
      </li>
   </ul>
   <p></p>
   <p>複合データ型の定数は、値を含むかどうかに関わらず、単純データ型の定数と同じ場所で使うことができます。つまり、 FILTER 演算子と GENERATE 演算子です。</p>

<source>
A = LOAD 'data' USING MyStorage() AS (T: tuple(name:chararray, age: int));
B = FILTER A BY T == ('john', 25);
D = FOREACH B GENERATE T.name, [25#5.6], {(1, 5, 18)};
</source>
   </section>
   
   
    <!-- ++++++++++++++++++++++++++++++++++ --> 
   <section id="expressions">
   <title>式</title>
   <p>Pig Latin において、式は FILTER, FOREACH, GROUP, SPLIT 演算子、そして評価関数の中で使える言語構造です。</p>
   <p>式は数学において伝統的な中置記法で書けます。文脈に応じて、式は次のものを含む可能性があります。</p>
   <ul>
      <li>
         <p>任意の Pig データ型 (単純データ型および複合データ型) の値</p>
      </li>
      <li>
         <p>任意の PIg 演算子 (算術演算子、比較演算子、 null, 条件演算子、符号演算子、キャスト演算子)</p>
      </li>
      <li>
         <p>任意の Pig 組み込み関数</p>
      </li>
      <li>
         <p>Java で書かれた任意のユーザ定義関数 (UDF)</p>
       </li>
        </ul>
       <p>Pig Latin では、</p>
        <ul>
       <li>
         <p>算術演算子は次のようになります:</p>
         <source>
X = GROUP A BY f2*f3;
</source>
      </li>

      <li>
         <p>文字列型の式は次のようになります。 a と b はいずれも chararray だと思ってください:</p>
         <source>
X = FOREACH A GENERATE CONCAT(a,b);
</source>
      </li>

      <li>
         <p></p>
         <p>ブーリアン式は次のようになります:</p>
         <source>
X = FILTER A BY (f1==8) OR (NOT (f2+f3 &gt; f1));
</source>
      </li>
   </ul>

   <!-- ++++++++++++++++++++++++++++++++++ --> 
      <section id="fexp">
          <title>フィールド式</title>
          <p>フィールド式はフィールドを表します。正確に言えばフィールドに対する<a href="#deref">参照外し演算子</a>の適用です。</p>
      </section>

   <!-- ++++++++++++++++++++++++++++++++++ --> 
      <section id="sexp">
          <title>スター式</title>
          <p>スター式 ( * ) はタプル中のすべてのフィールドを表現するのに使えます。全フィールドを明示的に書き出すのと同じ意味になります。次の例で、 B と C の定義は正確に同一です。また、 MyUDF 関数はどちらの場合でも正確に同じ引数をともなって呼び出されます。</p>
          <source>
A = LOAD 'data' USING MyStorage() AS (name:chararray, age: int);
B = FOREACH A GENERATE *, MyUDF(name, age);
C = FOREACH A GENERATE name, age, MyUDF(*);
</source>
          <p>次の例はスター式を使う場合によくある間違いです。次の例で、プログラマが本当に数えたかったのはバッグの中の 2 番目のフィールドの数 (COUNT($1)) です。</p>
          <source>
G = GROUP A BY $0;
C = FOREACH G GENERATE COUNT(*)
</source>
        
<p>入力のスキーマが未知 (null) の時には、スター式の使用にいくつかの制限があります:</p>
<ul>
<li>GROUP/COGROUP 演算子では、グループ化列の式にスター式を使うことはできません。</li>
<li>ORDER BY 演算子では、 ORDER BY 列としてスター式を使った場合、他の ORDER BY 列を指定することはできません。</li>
</ul>
      </section>

   <!-- ++++++++++++++++++++++++++++++++++ --> 
<section id="prexp">
<title>範囲射影式</title>
<p>範囲射影 ( .. ) 式は入力からある範囲の式を抜き出すのに使えます。たとえば:</p>
<ul>
<li>.. $x : $0 から $x までの列を抜き出します ($0 と $x を含む)</li>
<li>$x .. : $x から最後までの列を抜き出します ($x と 最後の列を含む)</li>
<li>$x .. $y : $x から $y までの列を抜き出します ($x と $y を含む)</li>
</ul>
<p></p>

<p>入力の関係がスキーマを持っている場合、列を位置で指定する代わりに別名で指定できます。別名と位置表記を組み合わせることもできます。たとえば "col1 .. $5" は正しい範囲射影式です。</p>

<p>範囲射影は<a href="#sexp">スター式</a> ( * ) が使える場所であればどこでも使えます。</p>

<p>範囲射影は次の文の中で使えます:
<a href="#foreach">FOREACH</a>, 
<a href="#join+%28inner%29">JOIN</a>,  
<a href="#group">GROUP</a>, 
<a href="#cogroup">COGROUP</a>,
<a href="#order+by">ORDER BY</a> (ネストされた FOREACH ブロック中の ORDER BY でも使えます) 。</p>

<p>いくつかの例です:</p>
<source>
..... 
grunt> F = foreach IN generate (int)col0, col1 .. col3; 
grunt> describe F; 
F: {col0: int,col1: bytearray,col2: bytearray,col3: bytearray} 
..... 
..... 
grunt> SORT = order IN by col2 .. col3, col0, col4 ..; 
..... 
..... 
J = join IN1 by $0 .. $3, IN2 by $0 .. $3; 
..... 
..... 
g = group l1 by b .. c; 
..... 
</source>

<p>入力のスキーマが未知 (null) の場合、最後の列までの範囲射影 (例: "x ..") の使用にはいくつかの制限があります:</p>
<ul>
<li>GROUP/COGROUP 演算子では、グループ化列の式に最後の列までの範囲射影を使うことはできません。</li>
<li>ORDER BY 演算子で、最後の列までの範囲射影はソート列の最後でのみ使えます。
<source>
..... 
grunt> describe IN; 
Schema for IN unknown. 

/* This statement is supported */
SORT = order IN by $2 .. $3, $6 ..; 

/* This statement is NOT supported */ 
SORT = order IN by $2 .. $3, $6 ..; 
..... 
</source>


</li>
</ul>
</section>
      
      <!-- ++++++++++++++++++++++++++++++++++ -->    
      <section id="bexp">
          <title>ブーリアン式</title>
          <p>ブーリアン式はブーリアン型の値を戻す UDF によって構成できます (<a href="#boolops">ブーリアン演算子</a>を参照) 。
          </p>
      </section>

   <!-- ++++++++++++++++++++++++++++++++++ -->            
      <section id="texp">
          <title>タプル式</title>
          <p>タプル式は部分式をタプルにまとめあげます。タプル式は (expression, [, expression …]) という形式です。ここで expression は一般式です。もっとも単純な形態のタプル式はすべてのフィールドを表すスター式です。
          </p>
      </section>

   <!-- ++++++++++++++++++++++++++++++++++ --> 
    <section id="gexp">
          <title>一般式</title>
          <p>一般式は UDF とほとんどの演算子によって構成できます。 Pig は boolean を基本型とみなさないので、一般式の値が boolean になることはできません。最も単純な形態の一般式はフィールド式です。
          </p>
      </section>
   </section>
   
   
    <!-- ================================================== --> 
   <section id="Schemas">
   <title>スキーマ</title>

   <p>スキーマによってフィールドに名前を割り当て、フィールドの型を宣言することができます。スキーマの使用は必須ではありませんが、可能な限り使用することをお勧めします。型宣言によってパース時のエラーチェックが厳密になり、また実行時の効率も上がるからです。</p>
   
   <p>スキーマ定義が可能な所ではどこでも、<a href="#schema-simple">単純データ型のスキーマ</a>と<a href="#schema-complex">複合データ型のスキーマ</a>を書くことができます。</p>
   
   <p>スキーマは <a href="#load">LOAD</a> 演算子、 <a href="#stream">STREAM</a> 演算子、 <a href="#foreach">FOREACH</a> 演算子の AS 節で定義できます。 LOAD 演算子でスキーマを定義する時、スキーマを適用するのはロード関数の責任です (<a href="#load">LOAD</a> と <a href="udf.html">ユーザ定義関数</a> を参照) 。</p>

   <p></p>
   <p><strong>既知のスキーマの扱い</strong></p>
   <p>次のことに注意してください:</p>
   <ul>
      <li>フィールド名とフィールドの型の両方を含むスキーマが定義できます。</li>
      <li>フィールド名だけを含むスキーマが定義できます。この場合、フィールドの型はデフォルトで bytearray になります。</li>
      <li>スキーマを定義しないことも可能です。この場合、フィールドは無名になり、またフィールドの型はデフォルトで bytearray になります。</li>
   </ul>
   <p>フィールドに名前を割り当てると、名前と位置表記の両方でフィールドが参照できるようになります。名前を割り当てない場合 (つまりフィールドが無名の時) 、フィールドは位置表記のみで参照できます。</p>
   <p>フィールドに型を割り当てると、その後キャスト演算子を使って型を変えることができます。型を割り当てない場合、フィールドの型はデフォルトで bytearray になります。デフォルトの型はキャスト演算子で変更できます。</p>
   <p id="unknown-schema"><strong>未知のスキーマの扱い</strong></p>
      <p>次のことに注意してください:</p>
   <ul>
      <li>複数の関係に JOIN/COGROUP/CROSS 演算子を適用する際、どれか一つの関係のスキーマが未知であれば (つまり、定義されたスキーマがない場合。 null スキーマとも呼ぶ) 、結果の関係のスキーマは null になります。</li>
      <li>要素のスキーマが定義されていないバッグに対して FLATTEN 演算子を適用すると、結果の関係のスキーマは null になります。</li>
      <li>スキーマが合致しない二つの関係を UNION すると、結果の関係のスキーマは null になります。</li>
      <li>スキーマが null の場合、 Pig はすべてのフィールドを bytearray として扱います (内部的には、 Pig は実際の型を動的に決定します) 。</li>
    </ul>      
    <p>次の例を見てください。フィールドの型が指定されていない時、 Pig は未知の型を表すのに bytearray を使います。フィールドの数がわからない時、 Pig は未知のスキーマを導出します。</p>
    
 <source>
/* フィールドの型を指定しない ... */
a = load '1.txt' as (a0, b0);
a: {a0: bytearray,b0: bytearray}

/* フィールドの数が不明 ... */
a = load '1.txt';
a: Schema for a unknown
</source>

   <p><strong>Pig はスキーマをどのように扱うか</strong></p>
   
   <p>上に示したとおり、いくつかの例外を除いて Pig は関係のスキーマを前もって推論します。関係のスキーマを調べるには <a href="test.html#describe">DESCRIBE</a> 演算子が使えます。 Pig は入力データを実行時に期待する型にキャストすることによってスキーマを適用します。キャストがうまく行けばユーザに結果が戻されます。うまく行かなければ、変換に失敗したレコードごとに警告が表示されます。 Pig は入力データ中のフィールドの実際の型を知らないことに注意してください。その代わり、 Pig は実行時に型を判断し、適切な変換を行います。</p>
  
<p>非決定論的なスキーマはとても強力ですが、時に性能に悪影響を与えます。次の例を考えてください:</p>  
  
<source>
A = load ‘input’ as (x, y, z);
B = foreach A generate x+y;
</source>

 <p>B に対して <a href="test.html#describe">DESCRIBE</a> 演算子を適用すると、 double 型の列が一つのスキーマが表示されます。これは、スキーマが不明の場合に、 Pig が最も安全な選択として最大の数値型を選択するからです。実際の入力データは整数値だけを含んでいるのかも知れませんが、 Pig はデータを double にキャストし、 double 型の結果が戻るようにします。</p>

 <p>関係のスキーマが推論できない時は、 Pig は実行時の型をパイプラインを通して伝播します。</p>


   <!-- ++++++++++++++++++++++++++++++++++ -->     
   <section id="schema-load">
   <title>LOAD 演算子と STREAM 演算子におけるスキーマ</title>
   <p>LOAD 演算子と STREAM 演算子では、スキーマは AS キーワードに後続して、括弧でくくる必要があります。</p>
   <p>次の例で、 LOAD 文は単純データ型からなるスキーマを含んでいます。</p>
<source>
A = LOAD 'data' AS (f1:int, f2:int);
</source>   
   </section>
 
    <!-- ++++++++++++++++++++++++++++++++++ -->   
   <section id="schemaforeach">
   <title>FOREACH 演算子におけるスキーマ</title>
   <p>FOREACH 演算子で FLATTEN 演算子を使う場合、スキーマは AS キーワードに後続して、括弧でくくる必要があります。 FLATTEN 演算子を使わない場合は、スキーマを括弧でくくる必要はありません。</p>
   <p>次の例で、 FOREACH 文は FLATTEN 演算子を使っており、また単純データ型からなるスキーマを適用しています。</p>
<source>
X = FOREACH C GENERATE FLATTEN(B) AS (f1:int, f2:int, f3:int), group;
</source>  
   <p>次の例で、 FOREACH 文は単純な式に対するスキーマを適用しています。</p>
<source>
X = FOREACH A GENERATE f1+f2 AS x1:int;
</source>   
   <p>次の例で、 FOREACH 文は複数のフィールドに対してスキーマを適用しています。</p>
<source>
X = FOREACH A GENERATE f1 as user, f2 as age, f3 as gpa;
</source> 
   </section>
  
     <!-- ++++++++++++++++++++++++++++++++++ -->  
   <section  id="schema-simple">
   <title>単純データ型のスキーマ</title>
   <p>単純データ型は int, long, float, double, chararray, bytearray, boolean からなります。</p>
   
   <section>
   <title>文法</title>
   <table>
      <tr>
            <td>
               <p>(alias[:type]) [, (alias[:type]) …] )</p>
            </td>
         </tr>
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>フィールドに割り当てる名前。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>type</p>
            </td>
            <td>
               <p>(省略可能) フィールドに割り当てられる単純データ型。</p>
               <p>aliad と type はコロン ( : ) によって区切ります。</p>
               <p>type が省略された時には、フィールドの型はデフォルトで bytearray になります。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>( , )</p>
            </td>
            <td>
               <p>複数のフィールドはカンマで区切ります。</p>
            </td>
         </tr>
   </table></section>
   
   <section>
   <title>例</title>
   <p>次の例で、スキーマは複数の型を定義しています。</p>
<source>
cat student;
John	18	4.0
Mary	19   	3.8
Bill	20   	3.9
Joe	18   	3.8

A = LOAD 'student' AS (name:chararray, age:int, gpa:float);

DESCRIBE A;
A: {name: chararray,age: int,gpa: float}

DUMP A;
(John,18,4.0F)
(Mary,19,3.8F)
(Bill,20,3.9F)
(Joe,18,3.8F)
</source>
   
   <p>次の例で "gpa" フィールドは型が宣言されていないため、デフォルトで bytearray になります。</p>
<source>
cat student;
John	18	4.0
Mary	19	3.8
Bill	20	3.9
Joe	18	3.8

A = LOAD 'data' AS (name:chararray, age:int, gpa);

DESCRIBE A;
A: {name: chararray,age: int,gpa: bytearray}

DUMP A;
(John,18,4.0)
(Mary,19,3.8)
(Bill,20,3.9)
(Joe,18,3.8)
</source>
   
   </section></section>
 
    <!-- ++++++++++++++++++++++++++++++++++ -->   
   <section id="schema-complex">
   <title>複合データ型のスキーマ</title>
   <p>複合データ型はタプル、バッグ、マップからなります。</p></section>
   
      <!-- ++++++++++++++++++++++++++++++++++ --> 
   <section id="tuple-schema">
   <title>タプルのスキーマ</title>
   <p>タプルはフィールドの順序付き集合です。</p>
   
   <section>
   <title>文法</title>
   <table>
      <tr>
            <td>
               <p>alias:[tuple] (alias[:type]) [, (alias[:type]) …] )</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>タプルに割り当てる名前。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>:</p>
            </td>
            <td>
               <p>alias とスキーマはコロンで区切ります。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>tuple</p>
            </td>
            <td>
               <p>(省略可能) タプル型 (大文字・小文字を区別しません) 。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>( )</p>
            </td>
            <td>
               <p>タプルを指定するには丸括弧を使います。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>alias[:type]</p>
            </td>
            <td>
               <p>タプルの中身。スキーマ定義のルールがタプルの中身にも適用されます:</p>
               <ul>
                  <li>
                     <p>alias - フィールドに割り当てられる名前</p>
                  </li>
                  <li>
                     <p>type (省略可能) - フィールドに割り当てられる単純データ型あるいは複合データ型</p>
                  </li>
               </ul>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例で、スキーマはタプルを定義しています。 2 つの LOAD 文は同一です。</p>

 <source>
cat data;
(3,8,9)
(1,4,7)
(2,5,8)

A = LOAD 'data' AS (T: tuple (f1:int, f2:int, f3:int));
A = LOAD 'data' AS (T: (f1:int, f2:int, f3:int));

DESCRIBE A;
A: {T: (f1: int,f2: int,f3: int)}

DUMP A;
((3,8,9))
((1,4,7))
((2,5,8))
</source>
   
   <p>次の例で、スキーマは 2 つのタプルを定義しています。</p>
<source>
cat data;
(3,8,9) (mary,19)
(1,4,7) (john,18)
(2,5,8) (joe,18)

A = LOAD data AS (F:tuple(f1:int,f2:int,f3:int),T:tuple(t1:chararray,t2:int));

DESCRIBE A;
A: {F: (f1: int,f2: int,f3: int),T: (t1: chararray,t2: int)}

DUMP A;
((3,8,9),(mary,19))
((1,4,7),(john,18))
((2,5,8),(joe,18))
</source>
   </section></section>

   <!-- ++++++++++++++++++++++++++++++++++ -->    
   <section id="bag-schema">
   <title>バッグのスキーマ</title>
   <p>バッグはタプルのコレクションです。</p>
   
   <section>
   <title>文法</title>
   <table>
      <tr>
            <td>
               <p>alias:[bag] {tuple} </p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>バッグに割り当てる名前です。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>:</p>
            </td>
            <td>
               <p>alias とスキーマはコロンで区切ります。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bag</p>
            </td>
            <td>
               <p>(省略可能) バッグ型 (大文字・小文字を区別しません) 。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>{ }</p>
            </td>
            <td>
               <p>バッグを指定するには波括弧を使います。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>tuple</p>
            </td>
            <td>
               <p>タプル (タプルのスキーマを参照) 。</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例で、スキーマはバッグを定義しています。 2 つの LOAD 文は同一です。</p>
<source>
cat data;
{(3,8,9)}
{(1,4,7)}
{(2,5,8)}

A = LOAD 'data' AS (B: bag {T: tuple(t1:int, t2:int, t3:int)});
A = LOAD 'data' AS (B: {T: (t1:int, t2:int, t3:int)});

DESCRIBE A:
A: {B: {T: (t1: int,t2: int,t3: int)}}

DUMP A;
({(3,8,9)})
({(1,4,7)})
({(2,5,8)})
</source>
   </section></section>
   
      <!-- ++++++++++++++++++++++++++++++++++ --> 
   <section id="map-schema">
   <title>マップのスキーマ</title>
   <p>マップはキーと値のペアです。</p>
   
   <section>
   <title>文法 (&lt;&gt; は省略可能であることを表します)</title>
   <table>
      <tr>
            <td>
               <p>alias:&lt;map&gt; [ &lt;type&gt; ] </p>
            </td>
         </tr>
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
         <tr>
            <td><p>alias</p></td>
            <td><p>マップに割り当てる名前です。</p></td>
         </tr>
         <tr>
            <td>
               <p>:</p>
            </td>
            <td>
               <p>alias とスキーマはコロンで区切ります。</p>
            </td>
         </tr>
         <tr>
            <td><p>map</p></td>
            <td><p>(省略可能) マップ型 (大文字と小文字を区別しません) 。</p></td>
         </tr>
         <tr>
            <td><p>[ ]</p></td>
            <td><p>マップ型を表すには角括弧 [ ] を使います。</p></td>
         </tr>
         <tr>
            <td><p>type</p></td>
            <td><p>(省略可能) データ型 (どのデータ型でも許容されます。デフォルトは bytearray です) 。</p>
            <p>型はマップの値にのみ適用されます。マップのキーは常に chararray 型です (<a href="#map">マップ</a> を参照) 。</p>
	    <p>型が宣言された場合、マップのすべての値はこの型である必要があります。</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例で、スキーマは型付けされないマップを定義します (マップの値はデフォルトで bytearray になります) 。 2 つの LOAD 文は同一です。</p>
<source>
cat data;
[open#apache]
[apache#hadoop]

A = LOAD 'data' AS (M:map []);
A = LOAD 'data' AS (M:[]);

DESCRIBE A;
a: {M: map[ ]}

DUMP A;
([open#apache])
([apache#hadoop])
</source>

<p>次の例は、型付きのマップを定義しています。</p>
<source>
/* マップの型を宣言する */
a = load '1.txt' as(map[int]); --Map value is int
b = foreach a generate (map[(i:int)])a0; -- Map value is tuple
b = stream a through `cat` as (m:map[{(i:int,j:chararray)}]); -- Map value is bag

/* 型付けされたマップの値の参照は、マップの値の型になる */
a = load '1.txt' as(map[int]);
b = foreach a generate $0#'key';

/* b のスキーマ */
b: {int}
</source>
 </section></section>
   
      <!-- ++++++++++++++++++++++++++++++++++ --> 
   <section id="schema-multi">
   <title>複数の型のスキーマ</title>
   <p>複数の型を含むデータのスキーマも定義できます。</p>
   
   <section>
   <title>例</title>
   <p>次の例で、スキーマはタプル、バッグ、マップのフィールドを定義しています。</p>
<source>
A = LOAD 'mydata' AS (T1:tuple(f1:int, f2:int), B:bag{T2:tuple(t1:float,t2:float)}, M:map[] );

A = LOAD 'mydata' AS (T1:(f1:int, f2:int), B:{T2:(t1:float,t2:float)}, M:[] );
</source>
</section></section></section>
   </section>
   
<!-- =================================================================== -->    
<!-- ARITHMETIC OPERATORS, ETC -->
<section id="artichmetic-ops">
	<title>算術演算子その他</title>

<section id="arithmetic">
<title>算術演算子</title>

<section>
<title>説明</title>
   <table>
      <tr>
            <td>
               <p>演算子</p>
            </td>
            <td>
               <p>記法</p>
            </td>
            <td>
               <p>注記</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>加算</p>
            </td>
            <td>
               <p>+</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>減算</p>
            </td>
            <td>
               <p>-</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>乗算</p>
            </td>
            <td>
               <p>*</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>除算</p>
            </td>
            <td>
               <p>/</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>剰余</p>
            </td>
            <td>
               <p>%</p>
            </td>
            <td>
               <p>a を b で割った余りを戻します (a%b) 。</p>
               <p>整数値 (int, long) に対して使います。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>条件</p>
            </td>
            <td>
               <p>? :</p>
            </td>
            <td>
               <p>(条件 ? 真の時の結果値 : 偽の時の結果値) </p>
               <p>条件演算子は括弧でくくる必要があります。</p>
               <p>2 つの結果値のスキーマは一致する必要があります。</p>
               <p>項になれるのは式のみです (関係演算は項になれません) 。</p>
            </td>
          </tr>
   </table>

   <section>
   <title>例</title>
   <p>次のような関係 A があるとします。</p>
<source>
A = LOAD 'data' AS (f1:int, f2:int, B:bag{T:tuple(t1:int,t2:int)});

DUMP A;
(10,1,{(2,3),(4,6)})
(10,3,{(2,3),(4,6)})
(10,6,{(2,3),(4,6),(5,7)})
</source>

  <p>次の例ではフィールド f1 と f2 に対して剰余演算子を使っています。</p>
<source>
X = FOREACH A GENERATE f1, f2, f1%f2;

DUMP X;
(10,1,0)
(10,3,1)
(10,6,4)
</source>
   
   <p>次の例ではフィールド f2 と B に対して条件演算子を使っています。条件は「 f2 が 1 の時」です。条件が真の時は 1 が戻ります。条件が偽の時は B の中のタプルの数が戻ります。</p>
<source>
X = FOREACH A GENERATE f2, (f2==1?1:COUNT(B));

DUMP X;
(1,1L)
(3,2L)
(6,3L)
</source>
   </section>
   
   <section id="types-table-add">
   <title>加算演算子 (+) 減算演算子 (-) の型テーブル</title>
   <p>* bytearray cast as this data type</p>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>バッグ</p>
            </td>
            <td>
               <p>タプル</p>
            </td>
            <td>
               <p>マップ</p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>バッグ</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>タプル</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>未実装</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>マップ</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>int </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>int にキャスト</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>long </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>long にキャスト</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>float </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>float にキャスト</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>double </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>double にキャスト</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>double にキャスト</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section id="types-table-mult">
   <title>乗算演算子 (*) 除算演算子 (/) の型テーブル</title>
   <p>* bytearray cast as this data type</p>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>バッグ</p>
            </td>
            <td>
               <p>タプル</p>
            </td>
            <td>
               <p>マップ</p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>バッグ</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>未実装</p>
            </td>
            <td>
               <p>未実装</p>
            </td>
            <td>
               <p>未実装</p>
            </td>
            <td>
               <p>未実装</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>タプル</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>未実装</p>
            </td>
            <td>
               <p>未実装</p>
            </td>
            <td>
               <p>未実装</p>
            </td>
            <td>
               <p>未実装</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>マップ</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>int </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>int にキャスト</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>long </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>long にキャスト</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>float </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>float にキャスト</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>double </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>double にキャスト</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>double にキャスト</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>乗算演算子 (*) 除算演算子 (/) の型テーブル</title>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>int にキャスト</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>long </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long にキャスト</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
   </table>
   </section></section></section>
   
<!-- =================================================================== --> 
   <section id="boolops">
   <title>論理演算子</title>
      
      <section>
      <title>説明</title>
   <table>
      <tr>
            <td>
               <p>演算子</p>
            </td>
            <td>
               <p>記法</p>
            </td>
            <td>
               <p>注記</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>AND       </p>
            </td>
            <td>
               <p>論理積</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>OR  </p>
            </td>
            <td>
               <p>論理和</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>NOT</p>
            </td>
            <td>
               <p>否定</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
   </table>
   <p>ブーリアン式 (ブーリアン値と比較演算子を含む式) の結果は常にブーリアン値 (true か false) になります。</p>
   
   <section>
   <title>例</title>
<source>
X = FILTER A BY (f1==8) OR (NOT (f2+f3 > f1));
</source>
   
   </section></section></section>   
   
   <!-- =================================================================== -->
   <section id="cast">
   <title>キャスト演算子</title>
   
   <section>
   <title>説明</title>
   <p>Pig Latin では次の表に挙げるキャストが可能です</p>
   <table>
       <tr>
            <td>
               <p><strong>キャスト元 / キャスト先</strong></p>
            </td>
            <td>
               <p>バッグ</p>
            </td>
            <td>
               <p>タプル</p>
            </td>
            <td>
               <p>マップ</p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p>boolean</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>バッグ</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>タプル</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>マップ</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
           <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
           <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>エラー</p>
            </td>
           <td>
               <p>可能</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>可能</p>
            </td>
         </tr>
                  <tr>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>可能</p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
   </table>

   <section>
   <title>文法</title>
   <table>
      <tr>
            <td>
               <p>{(data_type) |  (tuple(data_type))  | (bag{tuple(data_type)}) | (map[]) } field</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
      <tr>
            <td>
               <p>(data_type)</p>
            </td>
            <td>
               <p>キャスト先のデータ型。括弧にくくります。 bytearray を除く任意の型へのキャストができます (上表を参照) 。</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>field</p>
            </td>
            <td>
               <p>型を変換したいフィールド。</p>
               <p>フィールドは位置表記と名前 (別名) の両方で表せます。たとえば、最初のフィールドが f1 で型が int だったら、 (long)$0 と (long)f1 のどちらでも long にキャストできます。</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>使用方法</title>
   <p>キャスト演算子を使うことで、変換がサポートされている限り (上表を参照) 、データをある型から別の型に変換できます。たとえば、 myint という整数フィールドを文字列に変換したいとします。この場合、 (chararray)myint によって chararray にキャストできます。</p>
   <p>Please note the following:</p>
   <ul>
      <li>
         <p>フィールドは明示的にキャストできます。一度キャストしたら、フィールドはその型で在り続けます (自動的に元に戻ることはありません) 。¬¡の例で、 $0 は明示的に int にキャストされています。</p>
<source>
B = FOREACH A GENERATE (int)$0 + 1;
</source>
      </li>
   </ul>
   <p></p>
   <ul>
      <li>
         <p>可能であれば、 Pig は暗黙のキャストを行います。次の例では、 $0 は int にキャストされ、 $1 は double にキャストされます (いずれもデータの中身によらず) 。</p>
<source>
B = FOREACH A GENERATE $0 + 1, $1 + 1.0
</source>
      </li>
   </ul>
   <ul>
      <li>
         <p>2 つのbytearray 値に対して算術演算を行ったり、 bytearray 値に対して集計演算を行ったりした場合、暗黙的に double にキャストされます。中身のデータが実際には int や long なのであれば、型を宣言したり、明示的にデータをキャストしたりすることにより、よりよい性能が得られます。</p>
      </li>
      <li>
         <p>ダウンキャストによって情報が落ちる可能性があります。たとえば、 long から int へのキャストでは上位ビットが落ちます。</p>
      </li>
   </ul>
   </section>
    </section>
   
   <!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section>
   <title>例</title>
   <p>次の例で、 int は chararray 型にキャストされます (関係 X において) 。</p>
<source>
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY f1;

DUMP B;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(7,{(7,2,5)})
(8,{(8,3,4),(8,4,3)})

DESCRIBE B;
B: {group: int,A: {f1: int,f2: int,f3: int}}

X = FOREACH B GENERATE group, (chararray)COUNT(A) AS total;
(1,1)
(4,2)
(7,1)
(8,2)

DESCRIBE X;
X: {group: int,total: chararray}
</source>
   
   
<p>次の例で、関係 A の bytearray 型のフィールド fld はタプル型にキャストされます。</p>
<source>
cat data;
(1,2,3)
(4,2,1)
(8,3,4)

A = LOAD 'data' AS fld:bytearray;

DESCRIBE A;
a: {fld: bytearray}

DUMP A;
((1,2,3))
((4,2,1))
((8,3,4))

B = FOREACH A GENERATE (tuple(int,int,float))fld;

DESCRIBE B;
b: {(int,int,float)}

DUMP B;
((1,2,3))
((4,2,1))
((8,3,4))
</source>
   
   <p>次の例で、関係 A の bytearray 型のフィールド flt はバッグ型にキャストされます。</p>
<source>
cat data;
{(4829090493980522200L)}
{(4893298569862837493L)}
{(1297789302897398783L)}

A = LOAD 'data' AS fld:bytearray;

DESCRIBE A;
A: {fld: bytearray}

DUMP A;
({(4829090493980522200L)})
({(4893298569862837493L)})
({(1297789302897398783L)})

B = FOREACH A GENERATE (bag{tuple(long)})fld; 

DESCRIBE B;
B: {{(long)}}

DUMP B;
({(4829090493980522200L)})
({(4893298569862837493L)})
({(1297789302897398783L)})
</source>


   <p>次の例で、関係 A のフィールド flt はマップ型にキャストされます。</p>
<source>
cat data;
[open#apache]
[apache#hadoop]
[hadoop#pig]
[pig#grunt]

A = LOAD 'data' AS fld:bytearray;

DESCRIBE A;
A: {fld: bytearray}

DUMP A;
([open#apache])
([apache#hadoop])
([hadoop#pig])
([pig#grunt])

B = FOREACH A GENERATE ((map[])fld;

DESCRIBE B;
B: {map[ ]}

DUMP B;
([open#apache])
([apache#hadoop])
([hadoop#pig])
([pig#grunt])
</source>
   
</section>

<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="cast-relations">
   <title>関係からスカラ値へのキャスト</title>
<p>Pig ではタプルを 1 つだけ含む関係をスカラ値にキャストすることができます。タプルのフィールドは 1 つでも複数でも構いません。もし関係が複数のタプルを持っていたら、次の実行時エラーが発生します:  "Scalar has more than one row in the output" 。</p>

<p>この種のキャストは、 FOREACH, FILTER, SPLIT など、普通に式が使える場所ならどこでも使えます。もし明示的なキャストがない場合は、 Pig のルールにしたがって暗黙的キャストが行われます。また、スキーマが推論できないときには、 bytearray 型が使われます。</p>  
 
<p>関係からスカラ値へのキャストのもっとも典型的な使い道は、集計した値を後続の計算で使うことです。</p> 
 
<p>次の例では、各ユーザのクリックが全体に占める割合を求めています。 FOREACH 文の中では、明示的キャストを行なっています。 SUM の結果に名前を割り当てない場合には、位置表記が使えます (userid, clicks/(double)C.$0) 。</p>

<source>
A = load 'mydata' as (userid, clicks); 
B = group A all; 
C = foreach B genertate SUM(A.clicks) as total; 
D = foreach A generate userid, clicks/(double)C.total; 
dump D;
</source>
   
<p>次の例では、複数のフィールドを持つタプルを扱っています。 FILTER 文では暗黙的キャストが行われています。 FOREACH 文では、明示的キャストが行われています。</p>
<source>
A = load 'mydata' as (userid, clicks); 
B = group A all; 
C = foreach B genertate SUM(A.clicks) as total, COUNT(A) as cnt; 
D = FILTER A by clicks > C.total/3 
E = foreach D generate userid, clicks/(double)C.total, cnt; 
dump E; 
</source>
</section>
</section>
   
   <!-- =================================================================== --> 
   <section id="comparison">
   <title>Comparison Operators</title>
      
    <section><title>Description</title>
   <table>
      <tr>
            <td>
               <p>Operator</p>
            </td>
            <td>
               <p>Symbol</p>
            </td>
            <td>
               <p> Notes</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>equal  </p>
            </td>
            <td>
               <p>==</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>not equal </p>
            </td>
            <td>
               <p>!=</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>less than  </p>
            </td>
            <td>
               <p>&lt;</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>greater than </p>
            </td>
            <td>
               <p>&gt;</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>less than or equal to  </p>
            </td>
            <td>
               <p>&lt;=</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>greater than or equal to</p>
            </td>
            <td>
               <p>&gt;=</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p>pattern matching  </p>
            </td>
            <td>
               <p>matches</p>
            </td>
            <td>
            <p>Takes an expression on the left and a string constant on the right.</p>
            <p><em>expression</em> matches <em>string-constant</em></p>
            <p>Use the Java <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html">format</a> for regular expressions.</p>

            </td>
         </tr>
   </table>
   <p>Use the comparison operators with numeric and string data.</p>
    </section>
    
   <section>
   <title>Examples</title>

<p><strong>Numeric Example</strong></p>
<source>
X = FILTER A BY (f1 == 8);
</source>

<p><strong>String Example</strong></p>   
<source>
X = FILTER A BY (f2 == 'apache');
</source>

 <p><strong>Matches Example</strong></p>    
<source>
X = FILTER A BY (f1 matches '.*apache.*');
</source>
   </section>
   
   <section id="types-table-equal">
   <title>Types Table: equal (==) operator</title>
   <p></p>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>bag </p>
            </td>
            <td>
               <p>tuple </p>
            </td>
            <td>
               <p>map </p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bag </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>tuple </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
               <p>(see Note 1) </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>map </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
               <p>(see Note 2)</p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>int </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>cast as boolean </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>long </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>cast as boolean </p>
            </td>
             <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>float </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>cast as boolean  </p>
            </td>
             <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>double </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>cast as boolean  </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>cast as boolean </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
                  <tr>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
         </tr>
   </table>
   <p>Note 1: boolean (Tuple A is equal to tuple B if they have the same size s, and for all 0 &lt;= i &lt; s A[i] = = B[i])</p>
   <p>Note 2: boolean (Map A is equal to map B if A and B have the same number of entries, and for every key k1 in A with a value of v1, there is a key k2 in B with a value of v2, such that k1 = = k2 and v1 = = v2)</p>
</section>

   <section id="types-table-not-equal">
   <title>Types Table: not equal (!=) operator</title>
     <p></p>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>bag </p>
            </td>
            <td>
               <p>tuple </p>
            </td>
            <td>
               <p>map </p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bag </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
          <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>tuple </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>map </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>int </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>boolean (bytearray cast as int) </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>long </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>boolean (bytearray cast as long) </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>float </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>boolean (bytearray cast as float) </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>double </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>error </p>
            </td>
            <td>
               <p>boolean (bytearray cast as double) </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean (bytearray cast as chararray) </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p></p>
            </td>
            <td>
               <p>error</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section id="types-table-matches">
   <title>Types Table: matches operator</title>
   <p>*Cast as chararray (the second argument must be chararray)</p>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray* </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>boolean </p>
            </td>
            <td>
               <p>boolean  </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p>boolean</p>
            </td>
            <td>
               <p>boolean </p>
            </td>
         </tr>
   </table>
   </section>
   </section>

   

  <!-- =================================================================== -->    
   <section id="type-construction">
   <title>Type Construction Operators</title>
   
   <section>
   <title>Description</title>
   <table>
      <tr>
            <td>
               <p>Operator</p>
            </td>
            <td>
               <p>Symbol</p>
            </td>
            <td>
               <p> Notes</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>tuple constructor </p>
            </td>
            <td>
               <p> ( ) </p>
            </td>
            <td>
               <p>Use to construct a tuple from the specified elements. Equivalent to <a href="func.html#totuple">TOTUPLE</a>.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bag constructor</p>
            </td>
            <td>
               <p> { }</p>
            </td>
            <td>
               <p>Use to construct a bag from the specified elements. Equivalent to <a href="func.html#tobag">TOBAG</a>.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>map constructor</p>
            </td>
            <td>
               <p> [ ]</p>
            </td>
            <td>
               <p>Use to construct a bag from the specified elements. Equivalent to <a href="func.html#tomap">TOMAP</a>.</p>
            </td>
         </tr>
   </table>

<p></p>   
<p>Note the following:</p>  
<ul>
<li>These operators can be used anywhere where the expression of the corresponding type is acceptable including FOREACH GENERATE, FILTER, etc.</li>
<li>A single element enclosed in parens ( ) like (5) is not considered to be a tuple but rather an arithmetic operator.</li>
<li>For bags, every element is put in the bag; if the element is not a tuple Pig will create a tuple for it:
<ul>
<li> Given this {$1, $2}  Pig creates this {($1), ($2)} a bag with two tuples
<p>... neither $1 and $2 are tuples so Pig creates a tuple around each item</p> <p>&nbsp;</p></li>

<li> Given this {($1), $2} Pig creates this {($1), ($2)} a bag with two tuples
<p>... since ($1) is treated as $1 (one cannot create a single element tuple using this syntax), {($1), $2} becomes {$1, $2} and Pig creates a tuple around each item</p><p>&nbsp;</p></li>

<li> Given this {($1, $2)} Pig creates this {($1, $2)} a bag with a single tuple
<p>... Pig creates a tuple ($1, $2) and then puts this tuple into the bag</p><p>&nbsp;</p></li>

</ul> 
</li>
</ul>
</section>
   
<!-- ++++++++++++++++++++++++++++++++++ --> 
   <section>
   <title>Examples</title>
<p><strong>Tuple Construction</strong></p>
<source>
A = load 'students' as (name:chararray, age:int, gpa:float);
B = foreach A generate (name, age);
store B into ‘results’;

Input (students):
joe smith  20  3.5
amy chen   22  3.2
leo allen  18  2.1

Output (results):
(joe smith,20)
(amy chen,22)
(leo allen,18)
</source>   
   
<!-- ++++++++++++++++++++++++++++++++++ --> 
<p><strong>Bag Construction</strong></p>
<source>
A = load 'students' as (name:chararray, age:int, gpa:float);
B = foreach A generate {(name, age)}, {name, age};
store B into ‘results’;

Input (students):
joe smith  20  3.5
amy chen   22  3.2
leo allen  18  2.1

Output (results):
{(joe smith,20)}   {(joe smith),(20)}
{(amy chen,22)}    {(amy chen),(22)}
{(leo allen,18)}   {(leo allen),(18)}
</source>   

<!-- ++++++++++++++++++++++++++++++++++ -->    
<p><strong>Map Construction</strong></p>
<source>
A = load 'students' as (name:chararray, age:int, gpa:float);
B = foreach A generate [name, gpa];
store B into ‘results’;

Input (students):
joe smith  20  3.5
amy chen   22  3.2
leo allen  18  2.1

Output (results):
[joe smith#3.5]
[amy chen#3.2]
[leo allen#2.1]
</source>
</section>
</section>


  <!-- =================================================================== -->    
   <section id="deref">
   <title>Dereference Operators</title>
   
   <section>
   <title>Description</title>
   <table>
      <tr>
            <td>
               <p>Operator</p>
            </td>
            <td>
               <p>Symbol</p>
            </td>
            <td>
               <p> Notes</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>tuple dereference      </p>
            </td>
            <td>
               <p>tuple.id or tuple.(id,…)</p>
            </td>
            <td>
               <p>Tuple dereferencing can be done by name (tuple.field_name) or position (mytuple.$0). If a set of fields are dereferenced (tuple.(name1, name2) or tuple.($0, $1)), the expression represents a tuple composed of the specified fields. Note that if the dot operator is applied to a bytearray, the bytearray will be assumed to be a tuple.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bag dereference</p>
            </td>
            <td>
               <p>bag.id or bag.(id,…)</p>
            </td>
            <td>
               <p>Bag dereferencing can be done by name (bag.field_name) or position (bag.$0). If a set of fields are dereferenced (bag.(name1, name2) or bag.($0, $1)), the expression represents a bag composed of the specified fields.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>map dereference</p>
            </td>
            <td>
               <p>map#'key'</p>
            </td>
            <td>
               <p>Map dereferencing must be done by key (field_name#key or $0#key). If the pound operator is applied to a bytearray, the bytearray is assumed to be a map. If the key does not exist, the empty string is returned.</p>
            </td>
         </tr>
   </table>
   </section>
   
<!-- ++++++++++++++++++++++++++++++++++++ -->    
<section>
<title>Examples</title> 
  
<p><strong>Tuple Example</strong></p>   
<p>Suppose we have relation A.</p>
<source>
LOAD 'data' as (f1:int, f2:tuple(t1:int,t2:int,t3:int));

DUMP A;
(1,(1,2,3))
(2,(4,5,6))
(3,(7,8,9))
(4,(1,4,7))
(5,(2,5,8))
</source>
   
   <p>In this example dereferencing is used to retrieve two fields from tuple f2.</p>
<source>
X = FOREACH A GENERATE f2.t1,f2.t3;

DUMP X;
(1,3)
(4,6)
(7,9)
(1,7)
(2,8)
</source>

   
<!-- ++++++++++++++++++++++++++++++++++++ --> 
<p><strong>Bag Example</strong></p>   
   
<p>Suppose we have relation B, formed by grouping relation A (see the GROUP operator for information about the field names in relation B).</p>
<source>
A = LOAD 'data' AS (f1:int, f2:int,f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY f1;

DUMP B;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(7,{(7,2,5)})
(8,{(8,3,4),(8,4,3)})

ILLUSTRATE B;
<em>etc …</em>
----------------------------------------------------------
| b   | group: int | a: bag({f1: int,f2: int,f3: int}) |
----------------------------------------------------------
</source>
   
<p>In this example dereferencing is used with relation X to project the first field (f1) of each tuple in the bag (a).</p>
<source>
X = FOREACH B GENERATE a.f1;

DUMP X;
({(1)})
({(4),(4)})
({(7)})
({(8),(8)})
</source>
   

<!-- ++++++++++++++++++++++++++++++++++++ --> 
<p><strong>Tuple/Bag Example</strong></p>

<p>Suppose we have relation B, formed by grouping relation A  (see the GROUP operator for information about the field names in relation B).</p>

<source>
A = LOAD 'data' AS (f1:int, f2:int, f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY (f1,f2);

DUMP B;
((1,2),{(1,2,3)})
((4,2),{(4,2,1)})
((4,3),{(4,3,3)})
((7,2),{(7,2,5)})
((8,3),{(8,3,4)})
((8,4),{(8,4,3)})

ILLUSTRATE B;
<em>etc …</em>
-------------------------------------------------------------------------------
| b     | group: tuple({f1: int,f2: int}) | a: bag({f1: int,f2: int,f3: int}) |
-------------------------------------------------------------------------------
|       | (8, 3)                                | {(8, 3, 4), (8, 3, 4)} |
-------------------------------------------------------------------------------
</source>   
   
   <p>In this example dereferencing is used to project a field (f1) from a tuple (group) and a field (f1) from a bag (a).</p>
<source>
X = FOREACH B GENERATE group.f1, a.f1;

DUMP X;
(1,{(1)})
(4,{(4)})
(4,{(4)})
(7,{(7)})
(8,{(8)})
(8,{(8)})
</source>

<!-- ++++++++++++++++++++++++++++++++++++ -->     
<p><strong>Map Example</strong></p>
 <p>Suppose we have relation A. </p>

<source>
A = LOAD 'data' AS (f1:int, f2:map[]);

DUMP A;
(1,[open#apache])
(2,[apache#hadoop])
(3,[hadoop#pig])
(4,[pig#grunt])
</source>

   <p>In this example dereferencing is used to look up the value of key 'open'.</p>

<source>
X = FOREACH A GENERATE f2#'open';

DUMP X;
(apache)
()
()
()
</source>
</section>
</section>
  
  <!-- =================================================================== -->    
<section id="disambiguate">
<title>Disambiguate Operator</title>

<p>Use the disambiguate operator ( :: ) to identify field names after JOIN, COGROUP, CROSS, or FLATTEN operators.</p>

<p>In this example, to disambiguate y,  use A::y or B::y.  In cases where there is no ambiguity, such as z, the :: is not necessary but is still supported.</p>

<source>
A = load 'data1' as (x, y);
B = load 'data2' as (x, y, z);
C = join A by x, B by x;
D = foreach C generate y; -- which y?
</source>
</section>

    <!-- =================================================================== -->  
   <section  id="flatten">
   <title>Flatten Operator</title>
   <p>The FLATTEN operator looks like a UDF syntactically, but it is actually an operator that changes the structure of tuples 
   and bags in a way that a UDF cannot. Flatten un-nests tuples as well as bags. The idea is the same, but the operation and 
   result is different for each type of structure.</p>

   <p>For tuples, flatten substitutes the fields of a tuple in place of the tuple. For example, consider a relation that has a tuple 
   of the form (a, (b, c)). The expression GENERATE $0, flatten($1), will cause that tuple to become (a, b, c).</p>

   <p>For bags, the situation becomes more complicated. When we un-nest a bag, we create new tuples. If we have a 
   relation that is made up of tuples of the form ({(b,c),(d,e)}) and we apply GENERATE flatten($0), we end up with two 
   tuples (b,c) and (d,e). When we remove a level of nesting in a bag, sometimes we cause a cross product to happen. 
   For example, consider a relation that has a tuple of the form (a, {(b,c), (d,e)}), commonly produced by the GROUP operator. 
   If we apply the expression GENERATE $0, flatten($1) to this tuple, we will create new tuples: (a, b, c) and (a, d, e).</p>
   
   <p>Also note that the flatten of empty bag will result in that row being discarded; no output is generated. 
   (See also <a href="perf.html#nulls">Drop Nulls Before a Join</a>.) </p>
   
   <source>
grunt> cat empty.bag
{}      1
grunt> A = LOAD 'empty.bag' AS (b : bag{}, i : int);
grunt> B = FOREACH A GENERATE flatten(b), i;
grunt> DUMP B;
grunt>
</source>
   
   <p>For examples using the FLATTEN operator, see <a href="#flatten-example">FOREACH</a>.</p>
   </section>

  <!-- =================================================================== -->    
<section id="null_operators">
   <title>Null Operators</title>
     
   <section>
   <title>Description</title>
   <table>
      <tr>
            <td>
               <p>Operator</p>
            </td>
            <td>
               <p>Symbol</p>
            </td>
            <td>
               <p> Notes</p>
            </td>
         </tr>
         <tr>
            <td>
               <p id="is-null">is null </p>
            </td>
            <td>
               <p>is null</p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
         <tr>
            <td>
               <p id="is-not-null">is not null  </p>
            </td>
            <td>
               <p>is not null  </p>
            </td>
            <td>
               <p></p>
            </td>
         </tr>
   </table>
   <p></p>
   <p>For a detailed discussion of nulls see <a href="#nulls">Nulls and Pig Latin</a>.</p>
      </section>
      
   <section>
   <title>Examples</title>
   
   <p>In this example, values that are not null are obtained.</p>
<source>
X = FILTER A BY f1 is not null;
</source>
   </section>

   <section id="types-table-nulls">
   <title>Types Table</title>
   <p>The null operators can be applied to all data types (see <a  href="#nulls">Nulls and Pig Latin</a>). </p>
   </section>
   </section>
   
  <!-- =================================================================== -->    
   <section id="sign">
   <title>Sign Operators</title>
   
   <section>
   <title>Description</title>
   <table>
      <tr>
            <td>
               <p>Operator</p>
            </td>
            <td>
               <p>Symbol</p>
            </td>
            <td>
               <p> Notes</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>positive       </p>
            </td>
            <td>
               <p>+</p>
            </td>
            <td>
               <p> Has no effect.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>negative (negation)</p>
            </td>
            <td>
               <p> -</p>
            </td>
            <td>
               <p> Changes the sign of a positive or negative number.</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>Examples</title>
<p>In this example, the negation operator is applied to the "x" values.</p>   
<source>
A = LOAD 'data' as (x, y, z);

B = FOREACH A GENERATE -x, y;
</source>
</section>
   
   </section>
   
   <section id="types-table-negative">
   <title>Types Table: negative ( - ) operator</title>
   <table>
      <tr>
            <td>
               <p>bag </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>tuple </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>map </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>int </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>float </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>double </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>error </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p>double (as double) </p>
            </td>
         </tr>
   </table>
   </section>
  
</section>   

<!-- =================================================================== -->
<!-- RELATIONAL OPERATORS, ETC -->
<section>
<title>Relational Operators</title>

<!-- =================================================================== -->
 <section id="COGROUP">
<title>COGROUP</title>
   <p>See the <a href="#GROUP">GROUP</a> operator.</p>
</section>

<!-- =================================================================== -->
   <section id="cross">
   <title>CROSS</title>
   <p>Computes the cross product of two or more relations.</p>
   
   <section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>alias = CROSS alias, alias [, alias …] [PARTITION BY partitioner] [PARALLEL n];</p>
            </td>
        </tr> 
   </table>
   </section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name of a relation. </p>
            </td>
         </tr>
               <tr>
            <td>
               <p id="partition-by-cross">PARTITION BY partitioner</p>
            </td>
            <td>
             <p>Use this feature to specify the Hadoop Partitioner. The partitioner controls the partitioning of the keys of the intermediate map-outputs. </p>
             <ul>
             <li>
             <p>For more details, see http://hadoop.apache.org/common/docs/r0.20.2/api/org/apache/hadoop/mapred/Partitioner.html</p>
             </li>
             <li>
             <p>For usage, see <a href="#partitionby">Example: PARTITION BY</a></p>
             </li>
             </ul>
            </td>
         </tr>
         <tr>
            <td>
               <p>PARALLEL n</p>
            </td>
            <td>
               <p>Increase the parallelism of a job by specifying the number of reduce tasks, n. </p>
               <p>For more information, see <a href="perf.html#Parallel">Use the Parallel Features</a>.</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Usage</title>
   <p>Use the CROSS operator to compute the cross product (Cartesian product) of two or more relations.</p>
   <p>CROSS is an expensive operation and should be used sparingly. </p>
   </section>
   
   <section>
   <title>Example</title>
   <p>Suppose we have relations A and B.</p>
<source>
A = LOAD 'data1' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)

B = LOAD 'data2' AS (b1:int,b2:int);

DUMP B;
(2,4)
(8,9)
(1,3)
</source>
   
<p>In this example the cross product of relation A and B is computed.</p>
<source>
X = CROSS A, B;

DUMP X;
(1,2,3,2,4)
(1,2,3,8,9)
(1,2,3,1,3)
(4,2,1,2,4)
(4,2,1,8,9)
(4,2,1,1,3)
</source>
   
   </section></section>
   
<!-- =================================================================== -->    
   <section id="define">
   <title>DEFINE</title>
   
   <p>See:</p>
   <ul>
   <li><a href="basic.html#define-udfs">DEFINE (UDFs, streaming)</a></li>
   <li><a href="cont.html#define-macros">DEFINE (macros)</a></li>
   </ul>
   </section>
 
 <!-- =================================================================== -->  
   <section id="distinct">
   <title>DISTINCT </title>
   <p>Removes duplicate tuples in a relation.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>alias = DISTINCT alias [PARTITION BY partitioner] [PARALLEL n];        </p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>Terms</title>
   <table>
        <tr> 
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name of the relation.</p>
            </td>
        </tr>
      
      <tr>      
         <td>
               <p id="partition-by-distinct">PARTITION BY partitioner</p>
            </td>
            <td>
             <p>Use this feature to specify the Hadoop Partitioner. The partitioner controls the partitioning of the keys of the intermediate map-outputs. </p>
             <ul>
             <li>
             <p>For more details, see http://hadoop.apache.org/common/docs/r0.20.2/api/org/apache/hadoop/mapred/Partitioner.html</p>
             </li>
             <li>
              <p>For usage, see <a href="#partitionby">Example: PARTITION BY</a>.</p>
             </li>
             </ul>
         </td>
     </tr> 
         
         <tr>
            <td>
               <p>PARALLEL n</p>
            </td>
            <td>
               <p>Increase the parallelism of a job by specifying the number of reduce tasks, n.</p>
               <p>For more information, see <a href="perf.html#Parallel">Use the Parallel Features</a>.</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>Usage</title>
   <p>Use the DISTINCT operator to remove duplicate tuples in a relation. DISTINCT does not preserve the original order of the contents (to eliminate duplicates, Pig must first sort the data). You cannot use DISTINCT on a subset of fields; to do this, use FOREACH and a nested block to first select the fields and then apply DISTINCT  (see <a href="#nestedblock">Example: Nested Block</a>).</p>
   </section>
   
   <section>
   <title>Example</title>
   <p>Suppose we have relation A.</p>
<source>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(8,3,4)
(1,2,3)        
(4,3,3)        
(4,3,3)        
(1,2,3) 
</source>
   
   <p>In this example all duplicate tuples are removed.</p>
<source>
X = DISTINCT A;

DUMP X;
(1,2,3)
(4,3,3)
(8,3,4)
</source>

 </section></section>
   
  
<!-- =================================================================== -->   
   <section id="filter">
   <title>FILTER </title>
   <p>Selects tuples from a relation based on some condition.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>alias = FILTER alias  BY expression;</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name of the relation.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>BY</p>
            </td>
            <td>
               <p>Required keyword.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>A boolean expression.</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>Usage</title>
   <p>Use the FILTER operator to work with tuples or rows of data (if you want to work with columns of data, use the FOREACH...GENERATE operation).</p>
   <p>FILTER is commonly used to select the data that you want; or, conversely, to filter out (remove) the data you don’t want.</p>
   </section>
   
   <section>
   <title>Examples</title>
   <p>Suppose we have relation A.</p>
<source>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)
</source>
   
   <p>In this example the condition states that if the third field equals 3, then include the tuple with relation X.</p>
<source>
X = FILTER A BY f3 == 3;

DUMP X;
(1,2,3)
(4,3,3)
(8,4,3)
</source>
   
<p>In this example the condition states that if the first field equals 8 or if the sum of fields f2 and f3 is not greater than first field, then include the tuple relation X.</p>
<source>
X = FILTER A BY (f1 == 8) OR (NOT (f2+f3 > f1));

DUMP X;
(4,2,1)
(8,3,4)
(7,2,5)
(8,4,3)
</source>

</section></section>
 
 <!-- =================================================================== -->  
   <section id="foreach">
   <title>FOREACH</title>
   <p>Generates data transformations based on columns of data.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>alias  = FOREACH { block | nested_block };</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias </p>
            </td>
            <td>
               <p>The name of relation (outer bag).</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>block</p>
            </td>
            <td>
               <p>FOREACH…GENERATE block used with a relation (outer bag). Use this syntax:</p>
               <p></p>
               <p>alias = FOREACH alias GENERATE expression [AS schema] [expression [AS schema]….];</p>
               <p>See <a href="#schemas">Schemas</a></p>
               
            </td>
         </tr>
         <tr>
            <td>
               <p id="nested-block">nested_block</p>
            </td>
            <td>
               <p>Nested FOREACH...GENERATE block used with a inner bag. Use this syntax:</p>
               <p></p>
               <p>alias = FOREACH nested_alias {</p>
               <p>   alias = {nested_op | nested_exp}; [{alias = {nested_op | nested_exp}; …]</p>
               <p>   GENERATE expression [AS schema] [expression [AS schema]….]</p>
               <p>};</p>
               <p></p>
               <p>Where:</p>
               <p>The nested block is enclosed in opening and closing brackets { … }. </p>
               <p>The GENERATE keyword must be the last statement within the nested block.</p>
               <p>See <a href="#schemas">Schemas</a></p>
               <p>Macros are NOT alllowed inside a nested block.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>nested_alias</p>
            </td>
            <td>
               <p>The name of the inner bag.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>nested_op</p>
            </td>
            <td>
               <p>Allowed operations are CROSS, DISTINCT, FILTER, FOREACH, LIMIT, and ORDER BY. </p>
               <p>Note: FOREACH statements can be nested to two levels only. FOREACH statements that are nested to three or more levels will result in a grammar error.</p>
               <p>You can also perform projections within the nested block.</p>
               <p>For examples, see <a href="#nestedblock">Example: Nested Block</a>.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>nested_exp</p>
            </td>
            <td>
               <p>Any arbitrary, supported expression.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>AS</p>
            </td>
            <td>
               <p>Keyword</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>schema</p>
            </td>
            <td>
               <p>A schema using the AS keyword (see <a href="#schemas">Schemas</a>).</p>
               <ul>
                  <li>
                     <p>If the <a href="#Flatten">FLATTEN</a> operator is used, enclose the schema in parentheses.</p>
                  </li>
                  <li>
                     <p>If the FLATTEN operator is not used, don't enclose the schema in parentheses.</p>
                  </li>
               </ul>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Usage</title>
   <p>Use the FOREACH…GENERATE operation to work with columns of data (if you want to work with tuples or rows of data, use the FILTER operation).</p>
  
   <p>FOREACH...GENERATE works with relations (outer bags) as well as inner bags:</p>
   <ul>
      <li>
         <p>If A is a relation (outer bag), a FOREACH statement could look like this.</p>
<source>
X = FOREACH A GENERATE f1;
</source>
      </li>
      <li>
         <p>If A is an inner bag, a FOREACH statement could look like this.</p>
  <source>
X = FOREACH B {
        S = FILTER A BY 'xyz';
        GENERATE COUNT (S.$0);
}
</source>
      </li>
   </ul>
   </section>
   
   <section id="projection">
   <title>Example: Projection</title>
   <p>In this example the asterisk (*) is used to project all tuples from relation A to relation X. Relation A and X are identical.</p>
<source>
X = FOREACH A GENERATE *;

DUMP X;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)
</source>
   
   <p>In this example two fields from relation A are projected to form relation X. </p>
<source>
X = FOREACH A GENERATE a1, a2;

DUMP X;
(1,2)
(4,2)
(8,3)
(4,3)
(7,2)
(8,4)
</source>
   
   </section>
   
   <section>
   <title>Example: Nested Projection</title>


   <p>In this example if one of the fields in the input relation is a tuple, bag or map, we can perform a projection on that field (using a deference operator).</p>
<source>
X = FOREACH C GENERATE group, B.b2;

DUMP X;
(1,{(3)})
(4,{(6),(9)})
(8,{(9)})
</source>
   
   <p>In this example multiple nested columns are retained.</p>
<source>
X = FOREACH C GENERATE group, A.(a1, a2);

DUMP X;
(1,{(1,2)})
(4,{(4,2),(4,3)})
(8,{(8,3),(8,4)})
</source>
   </section>
   
   <section>
   <title>Example: Schema</title>
   <p>In this example two fields in relation A are summed to form relation X. A schema is defined for the projected field.</p>
<source>
X = FOREACH A GENERATE a1+a2 AS f1:int;

DESCRIBE X;
x: {f1: int}

DUMP X;
(3)
(6)
(11)
(7)
(9)
(12)

Y = FILTER X BY f1 > 10;

DUMP Y;
(11)
(12)
</source>
   
   </section>
   
   <section>
   <title>Example: Applying Functions</title>
   <p>In this example the built in function SUM() is used to sum a set of numbers in a bag.</p>
<source>
X = FOREACH C GENERATE group, SUM (A.a1);

DUMP X;
(1,1)
(4,8)
(8,16)
</source>
   
   </section>
   
   <section id="flatten-example">
   <title>Example: Flatten</title>
   <p>In this example the <a href="#Flatten">FLATTEN</a> operator is used to eliminate nesting. </p>
<source>
X = FOREACH C GENERATE group, FLATTEN(A);

DUMP X;
(1,1,2,3)
(4,4,2,1)
(4,4,3,3)
(8,8,3,4)
(8,8,4,3)
</source>
   
   
   <p>Another FLATTEN example.</p>
<source>
X = FOREACH C GENERATE GROUP, FLATTEN(A.a3);

DUMP X;
(1,3)
(4,1)
(4,3)
(8,4)
(8,3)
</source>
   
   <p>Another FLATTEN example. Note that for the group '4' in C, there are two tuples in each bag. Thus, when both bags are flattened, the cross product of these tuples is returned; that is, tuples (4, 2, 6), (4, 3, 6), (4, 2, 9), and (4, 3, 9).</p>
<source>
X = FOREACH C GENERATE FLATTEN(A.(a1, a2)), FLATTEN(B.$1);

DUMP X;
(1,2,3)
(4,2,6)
(4,2,9)
(4,3,6)
(4,3,9)
(8,3,9)
(8,4,9)
</source>

   <p>Another FLATTEN example. Here, relations A and B both have a column x. When forming relation E,  you need to use the :: operator to identify which column x to use - either relation A column x (A::x) or relation B column x (B::x). This example uses relation A column x (A::x).</p>
<source>
A = LOAD 'data' AS (x, y);
B = LOAD 'data' AS (x, z);
C = COGROUP A BY x, B BY x;
D = FOREACH C GENERATE flatten(A), flatten(b);
E = GROUP D BY A::x;
……
</source>
   
   </section>
   
   <section id="nestedblock">
   <title>Example: Nested Block</title>
      <p>In this example a CROSS is performed within the nested block.</p>
<source>
 user = load 'user' as (uid, age, gender, region);
session = load 'session' as (uid, region);
C = cogroup user by uid, session by uid;
D = foreach C {
    crossed = cross user, session;
    generate crossed;  
</source>
<p>In this example FOREACH is nested to the second level.</p>
<source>
a = load '1.txt' as (a0, a1:chararray, a2:chararray); 
b = group a by a0; 
c = foreach b { 
    c0 = foreach a generate TOMAP(a1,a2); 
    generate c0; 
} 
dump c; 
</source>
<p>This example shows a CROSS and FOREACH nested to the second level.</p>
<source>
a = load '1.txt' as (a0, a1, a2); 
b = load '2.txt' as (b0, b1); 
c = cogroup a by a0, b by b0; 
d = foreach c { 
    d0 = cross a, b; 
    d1 = foreach d0 generate a1+b1; 
    generate d1; 
} 
dump d;
</source>
   <p>Suppose we have relations A and B. Note that relation B contains an inner bag.</p>
<source>
A = LOAD 'data' AS (url:chararray,outlink:chararray);

DUMP A;
(www.ccc.com,www.hjk.com)
(www.ddd.com,www.xyz.org)
(www.aaa.com,www.cvn.org)
(www.www.com,www.kpt.net)
(www.www.com,www.xyz.org)
(www.ddd.com,www.xyz.org)

B = GROUP A BY url;

DUMP B;
(www.aaa.com,{(www.aaa.com,www.cvn.org)})
(www.ccc.com,{(www.ccc.com,www.hjk.com)})
(www.ddd.com,{(www.ddd.com,www.xyz.org),(www.ddd.com,www.xyz.org)})
(www.www.com,{(www.www.com,www.kpt.net),(www.www.com,www.xyz.org)})
</source>
   
   <p>In this example we perform two of the operations allowed in a nested block, FILTER and DISTINCT. Note that the last statement in the nested block must be GENERATE. Also, note the use of projection (PA = FA.outlink;) to retrieve a field. DISTINCT can be applied to a subset of fields (as opposed to a relation) only within a nested block.</p>
<source>
X = FOREACH B {
        FA= FILTER A BY outlink == 'www.xyz.org';
        PA = FA.outlink;
        DA = DISTINCT PA;
        GENERATE group, COUNT(DA);
}

DUMP X;
(www.aaa.com,0)
(www.ccc.com,0)
(www.ddd.com,1)
(www.www.com,1)
</source>
   
</section></section>
   
 
 
            
            
<!-- =================================================================== -->
   <section id="GROUP">
   <title>GROUP</title>
   <p>Groups the data in one or more relations.</p>
   <p>Note: The GROUP and COGROUP operators are identical. Both operators work with one or more relations. 
   For readability GROUP is used in statements involving one relation and COGROUP is used in statements involving two or more relations. 
   You can COGROUP up to but no more than 127 relations at a time.</p>   
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>alias = GROUP alias { ALL | BY expression} [, alias ALL | BY expression …]  [USING 'collected' | 'merge'] [PARTITION BY partitioner] [PARALLEL n];</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias </p>
            </td>
            <td>
               <p>The name of a relation.</p>
               <p>You can COGROUP up to but no more than 127 relations at a time.</p>
            </td>
         </tr>
                  <tr>
            <td>
               <p>ALL</p>
            </td>
            <td>
               <p>Keyword. Use ALL if you want all tuples to go to a single group; for example, when doing aggregates across entire relations.</p>
               <p>B = GROUP A ALL;</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>BY</p>
            </td>
            <td>
               <p>Keyword. Use this clause to group the relation by field, tuple or expression.</p>
               <p>B = GROUP A BY f1;</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>A tuple expression. This is the group key or key field. If the result of the tuple expression is a single field, the key will be the value of the first field rather than a tuple with one field. To group using multiple keys, enclose the keys in parentheses:</p>
               <p>B = GROUP A BY (key1,key2);</p>
            </td>
         </tr>
         
         <tr>
            <td>
               <p>USING</p>
            </td>
            <td>
               <p>Keyword</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>'collected'</p>
            </td>
  
            <td>

            <p>Use the ‘collected’ clause with the GROUP operation (works with one relation only).</p>
            <p>The following conditions apply:</p>
               <ul>
               <li>
               <p>The loader must implement the {CollectableLoader} interface.</p>
               </li>
               <li>
               <p>Data must be sorted on the group key.</p>
               </li>
               </ul>
               <p></p>
               <p>If your data and loaders satisfy these conditions, use the ‘collected’ clause to perform an optimized version of GROUP; 
            the operation will execute on the map side and avoid running the reduce phase.</p>
               <p></p>
            </td>
         </tr>    
         
         <tr>
            <td>
               <p>'merge'</p>
            </td>
            <td>

               <p>Use the ‘merge’ clause with the COGROUP operation (works with two or more relations only).</p>
               <p>The following conditions apply:</p>
               <ul>
               <li>
               <p>No other operations can be done between the LOAD and COGROUP statements.</p>
               </li>
               <li>
               <p>Data must be sorted on the COGROUP key for all tables in ascending (ASC) order.</p>
               </li> 
                <li>
               <p>Nulls are considered smaller than evertyhing. If data contains null keys, they should occur before anything else.</p>
               </li>
               <li>
               <p>Left-most loader must implement the {CollectableLoader} interface as well as {OrderedLoadFunc} interface.</p>
               </li>
               <li>
               <p>All other loaders must implement IndexableLoadFunc.</p>
               </li>
                <li>
               <p>Type information must be provided in the schema for all the loaders.</p>
               </li>              
               </ul>
               <p></p>
               <p>If your data and loaders satisfy these conditions, the ‘merge’ clause to perform an optimized version of COGROUP; 
               the operation will execute on the map side and avoid running the reduce phase.</p>
            </td>
            
         </tr>     
         
     <tr>      
         <td >
               <p id="partition-by-group">PARTITION BY partitioner</p>
            </td>
            <td>
             <p>Use this feature to specify the Hadoop Partitioner. The partitioner controls the partitioning of the keys of the intermediate map-outputs. </p>
             <ul>
             <li>
             <p>For more details, see http://hadoop.apache.org/common/docs/r0.20.2/api/org/apache/hadoop/mapred/Partitioner.html</p>
             </li>
             <li>
             <p>For usage, see <a href="#partitionby">Example: PARTITION BY</a></p>
             </li>
             </ul>
         </td>
     </tr> 

         <tr>
            <td>
               <p>PARALLEL n</p>
            </td>
            <td>
               <p>Increase the parallelism of a job by specifying the number of reduce tasks, n.</p>
               <p>For more information, see <a href="perf.html#Parallel">Use the Parallel Features</a>.</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Usage</title>
   <p>The GROUP operator groups together tuples that have the same group key (key field). The key field will be a tuple if the group key has more than one field, otherwise it will be the same type as that of the group key. The result of a GROUP operation is a relation that includes one tuple per group. This tuple contains two fields: </p>
   <ul>
      <li>
         <p>The first field is named "group" (do not confuse this with the GROUP operator) and is the same type as the group key.</p>
      </li>
      <li>
         <p>The second field takes the name of the original relation and is type bag.</p>
     </li>
     <li>
         <p>The names of both fields are generated by the system as shown in the example below.</p>
      </li>
   </ul>
   <p></p>
   
   <p>Note the following about the GROUP/COGROUP and JOIN operators:</p>
      <ul>
      <li>
         <p>The GROUP and JOIN operators perform similar functions. GROUP creates a nested set of output tuples while JOIN creates a flat set of output tuples</p>
      </li>
      <li>
         <p>The GROUP/COGROUP and JOIN operators handle null values differently (see <a href="#nulls_group">Nulls and GROUP/COGROUP Operataors</a>).</p>
     </li>
   </ul>
   
   </section>
   
   <section>
   <title>Example</title>
<p>Suppose we have relation A.</p>

<source>
A = load 'student' AS (name:chararray,age:int,gpa:float);

DESCRIBE A;
A: {name: chararray,age: int,gpa: float}

DUMP A;
(John,18,4.0F)
(Mary,19,3.8F)
(Bill,20,3.9F)
(Joe,18,3.8F)
</source>
   
   <p>Now, suppose we group relation A on field "age" for form relation B. We can use the DESCRIBE and ILLUSTRATE operators to examine the structure of relation B. Relation B has two fields. The first field is named "group" and is type int, the same as field "age" in relation A. The second field is name "A"  after relation A and is type bag.</p>
<source>
B = GROUP A BY age;

DESCRIBE B;
B: {group: int, A: {name: chararray,age: int,gpa: float}}

ILLUSTRATE B;
<em>etc ... </em>
----------------------------------------------------------------------
| B     | group: int | A: bag({name: chararray,age: int,gpa: float}) |
----------------------------------------------------------------------
|       | 18         | {(John, 18, 4.0), (Joe, 18, 3.8)}             |
|       | 20         | {(Bill, 20, 3.9)}                             |
----------------------------------------------------------------------

DUMP B;
(18,{(John,18,4.0F),(Joe,18,3.8F)})
(19,{(Mary,19,3.8F)})
(20,{(Bill,20,3.9F)})
</source>
   

   <p>Continuing on, as shown in these FOREACH statements, we can refer to the fields in relation B by names "group" and "A" or by positional notation.</p>

<source>
C = FOREACH B GENERATE group, COUNT(A);

DUMP C;
(18,2L)
(19,1L)
(20,1L)

C = FOREACH B GENERATE $0, $1.name;

DUMP C;
(18,{(John),(Joe)})
(19,{(Mary)})
(20,{(Bill)})
</source>
</section>
   
   <section>
   <title>Example</title>
   
   <p>Suppose we have relation A.</p>
<source>
A = LOAD 'data' as (f1:chararray, f2:int, f3:int);

DUMP A;
(r1,1,2)
(r2,2,1)
(r3,2,8)
(r4,4,4)
</source>
   
<p>In this example the tuples are grouped using an expression, f2*f3.</p>
<source>
X = GROUP A BY f2*f3;

DUMP X;
(2,{(r1,1,2),(r2,2,1)})
(16,{(r3,2,8),(r4,4,4)})
</source>
</section>

   <section>
   <title>Example</title>
   <p>Suppose we have two relations, A and B.</p>
<source>
A = LOAD 'data1' AS (owner:chararray,pet:chararray);

DUMP A;
(Alice,turtle)
(Alice,goldfish)
(Alice,cat)
(Bob,dog)
(Bob,cat)

B = LOAD 'data2' AS (friend1:chararray,friend2:chararray);

DUMP B;
(Cindy,Alice)
(Mark,Alice)
(Paul,Bob)
(Paul,Jane)
</source>
   
   <p>In this example tuples are co-grouped using field “owner” from relation A and field “friend2” from relation B as the key fields. The DESCRIBE operator shows the schema for relation X, which has two fields, "group" and "A" (see the GROUP operator for information about the field names).</p>
<source>
X = COGROUP A BY owner, B BY friend2;

DESCRIBE X;
X: {group: chararray,A: {owner: chararray,pet: chararray},b: {firend1: chararray,friend2: chararray}}
</source>
   
   <p>Relation X looks like this. A tuple is created for each unique key field. The tuple includes the key field and two bags. The first bag is the tuples from the first relation with the matching key field. The second bag is the tuples from the second relation with the matching key field. If no tuples match the key field, the bag is empty.</p>
<source>
(Alice,{(Alice,turtle),(Alice,goldfish),(Alice,cat)},{(Cindy,Alice),(Mark,Alice)})
(Bob,{(Bob,dog),(Bob,cat)},{(Paul,Bob)})
(Jane,{},{(Paul,Jane)})
</source>
   
   <p>In this example tuples are co-grouped and the INNER keyword is used asymmetrically on only one of the relations.</p>
<source>
X = COGROUP A BY owner, B BY friend2 INNER;

DUMP X;
(Bob,{(Bob,dog),(Bob,cat)},{(Paul,Bob)})
(Jane,{},{(Paul,Jane)})
(Alice,{(Alice,turtle),(Alice,goldfish),(Alice,cat)},{(Cindy,Alice),(Mark,Alice)})
</source>
   </section>
   
   <section>
   <title>Example</title>
<p>This example shows how to group using multiple keys.</p>   
<source>
 A = LOAD 'allresults' USING PigStorage() AS (tcid:int, tpid:int, date:chararray, result:chararray, tsid:int, tag:chararray);
 B = GROUP A BY (tcid, tpid); 
</source>
    </section>   
     
   <section id="partitionby">
   <title>Example: PARTITION BY</title>
<p>To use the Hadoop Partitioner add PARTITION BY clause to the appropriate operator: </p>
<source>
A = LOAD 'input_data'; 
B = GROUP A BY $0 PARTITION BY org.apache.pig.test.utils.SimpleCustomPartitioner PARALLEL 2;
</source>
<p>Here is the code for SimpleCustomPartitioner:</p>
<source>
public class SimpleCustomPartitioner extends Partitioner &lt;PigNullableWritable, Writable&gt; { 
     //@Override 
    public int getPartition(PigNullableWritable key, Writable value, int numPartitions) { 
        if(key.getValueAsPigType() instanceof Integer) { 
            int ret = (((Integer)key.getValueAsPigType()).intValue() % numPartitions); 
            return ret; 
       } 
       else { 
            return (key.hashCode()) % numPartitions; 
        } 
    } 
}
</source>
   </section>
   </section>
   
   <!-- =================================================================== -->    
   <section id="import">
   <title>IMPORT</title>
   
   <p>See <a href="cont.html#import-macros">IMPORT (macros)</a></p>

   </section>
   
<!-- =========================================================================== -->     
   
   <section id="join-inner">
   <title>JOIN (inner) </title>
   <p>Performs an inner join of two or more relations based on common field values.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>alias = JOIN alias BY {expression|'('expression [, expression …]')'} (, alias BY {expression|'('expression [, expression …]')'} …) [USING 'replicated' | 'skewed' | 'merge' | 'merge-sparse'] [PARTITION BY partitioner] [PARALLEL n];  </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name of a relation.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>BY</p>
            </td>
            <td>
               <p>Keyword</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>A field expression.</p>
               <p>Example: X = JOIN A BY fieldA, B BY fieldB, C BY fieldC;</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>USING</p>
            </td>
            <td>
               <p>Keyword</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>'replicated'</p>
            </td>
            <td>
               <p>Use to perform replicated joins (see <a href="perf.html#Replicated-Joins">Replicated Joins</a>).</p>
            </td>
         </tr>
         
         <tr>
            <td>
               <p>'skewed'</p>
            </td>
            <td>
               <p>Use to perform skewed joins (see <a href="perf.html#Skewed-Joins">Skewed Joins</a>).</p>
            </td>
         </tr>
         
          <tr>
            <td>
               <p>'merge'</p>
            </td>
            <td>
               <p>Use to perform merge joins (see <a href="perf.html#Merge-Joins">Merge Joins</a>).</p>
            </td>
         </tr>
         
          <tr>
            <td>
               <p>'merge-sparse'</p>
            </td>
            <td>
               <p>Use to perform merge-sparse joins (see <a href="perf.html#Merge-sparse-Joins">Merge-Sparse Joins</a>).</p>
            </td>
         </tr>         
         
              <tr>      
         <td>
               <p id="partition-by-join-inner">PARTITION BY partitioner</p>
            </td>
            <td>
             <p>Use this feature to specify the Hadoop Partitioner. The partitioner controls the partitioning of the keys of the intermediate map-outputs. </p>
             <ul>
             <li>
             <p>For more details, see http://hadoop.apache.org/common/docs/r0.20.2/api/org/apache/hadoop/mapred/Partitioner.html</p>
             </li>
             <li>
              <p>For usage, see <a href="#partitionby">Example: PARTITION BY</a></p>
             </li>
             </ul>
             <p></p>
             <p>This feature CANNOT be used with skewed joins.</p>
         </td>
     </tr> 

         <tr>
            <td>
               <p>PARALLEL n</p>
            </td>
            <td>
               <p>Increase the parallelism of a job by specifying the number of reduce tasks, n. </p>
               <p>For more information, see <a href="perf.html#Parallel">Use the Parallel Features</a>.</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Usage</title>
   <p>Use the JOIN operator to perform an inner, equijoin join of two or more relations based on common field values. 
   The JOIN operator always performs an inner join. Inner joins ignore null keys, so it makes sense to filter them out before the join.</p>
   
   <p>Note the following about the GROUP/COGROUP and JOIN operators:</p>
      <ul>
      <li>
         <p>The GROUP and JOIN operators perform similar functions. GROUP creates a nested set of output tuples while JOIN creates a flat set of output tuples.</p>
      </li>
      <li>
         <p>The GROUP/COGROUP and JOIN operators handle null values differently (see <a href="#nulls_join">Nulls and JOIN Operator</a>).</p>
     </li>
   </ul>
   <p></p>
   <p id="self-joins"><strong>Self Joins</strong></p>
   <p>To perform self joins in Pig load the same data multiple times, under different aliases, to avoid naming conflicts.</p>  
   <p>In this example the same data is loaded twice using aliases A and B.</p>
   <source>
grunt> A = load 'mydata';
grunt> B = load 'mydata';
grunt> C = join A by $0, B by $0;
grunt> explain C;
</source>
    </section>

   <section>
   <title>Example</title>
   <p>Suppose we have relations A and B.</p>
<source>
A = LOAD 'data1' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = LOAD 'data2' AS (b1:int,b2:int);

DUMP B;
(2,4)
(8,9)
(1,3)
(2,7)
(2,9)
(4,6)
(4,9)
</source>
   
   <p>In this example relations A and B are joined by their first fields.</p>
<source>
X = JOIN A BY a1, B BY b1;

DUMP X;
(1,2,3,1,3)
(4,2,1,4,6)
(4,3,3,4,6)
(4,2,1,4,9)
(4,3,3,4,9)
(8,3,4,8,9)
(8,4,3,8,9)
</source>
   
 </section>
 </section>
   
<!-- =========================================================================== -->  

<section id="join-outer">
   <title>JOIN (outer) </title>
   <p>Performs an outer join of two or more relations based on common field values.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>alias = JOIN left-alias BY left-alias-column [LEFT|RIGHT|FULL] [OUTER], right-alias BY right-alias-column 
               [USING 'replicated' | 'skewed' | 'merge'] [PARTITION BY partitioner] [PARALLEL n];  </p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>Terms</title>

   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name of a relation. Applies to alias, left-alias and right-alias.</p>
            </td>
        </tr>
        <tr>
            <td>
               <p>alias-column</p>
            </td>
            <td>
               <p>The name of the join column for the corresponding relation. Applies to left-alias-column and right-alias-column.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>BY</p>
            </td>
            <td>
               <p>Keyword</p>
            </td>
         </tr>

         <tr>
            <td>
               <p>LEFT</p>
            </td>
            <td>
               <p>Left outer join.</p>
            </td>
         </tr>
         
         <tr>
            <td>
               <p>RIGHT</p>
            </td>
            <td>
               <p>Right outer join.</p>
            </td>
         </tr>
         
              <tr>
            <td>
               <p>FULL</p>
            </td>
            <td>
               <p>Full outer join.</p>
            </td>
         </tr>

         <tr>
            <td>
               <p>OUTER</p>
            </td>
            <td>
               <p>(Optional) Keyword </p>
            </td>
         </tr>

  <tr>
            <td>
               <p>USING</p>
            </td>
            <td>
               <p>Keyword</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>'replicated'</p>
            </td>
            <td>
               <p>Use to perform replicated joins (see <a href="perf.html#Replicated-Joins">Replicated Joins</a>).</p>
               <p>Only left outer join is supported for replicated joins.</p>
            </td>
         </tr>
         
                  <tr>
            <td>
               <p>'skewed'</p>
            </td>
            <td>
               <p>Use to perform skewed joins (see <a href="perf.html#Skewed-Joins">Skewed Joins</a>).</p>
            </td>
         </tr>

         <tr>
            <td>
               <p>'merge'</p>
            </td>
            <td>
               <p>Use to perform merge joins (see <a href="perf.html#Merge-Joins">Merge Joins</a>).</p>
            </td>
         </tr>
         
         
      <tr>      
         <td>
               <p id="partition-by-join-outer">PARTITION BY partitioner</p>
            </td>
            <td>
             <p>Use this feature to specify the Hadoop Partitioner. The partitioner controls the partitioning of the keys of the intermediate map-outputs. </p>
             <ul>
             <li>
             <p>For more details, see http://hadoop.apache.org/common/docs/r0.20.2/api/org/apache/hadoop/mapred/Partitioner.html</p>
             </li>
             <li>
              <p>For usage, see <a href="#partitionby">Example: PARTITION BY</a></p>
             </li>
             </ul>
             <p></p>
             <p>This feature CANNOT be used with skewed joins.</p>
         </td>
     </tr> 

         <tr>
            <td>
               <p>PARALLEL n</p>
            </td>
            <td>
               <p>Increase the parallelism of a job by specifying the number of reduce tasks, n. </p>
               <p>For more information, see <a href="perf.html#Parallel">Use the Parallel Features</a>.</p>
            </td>
         </tr>
    
   </table>

</section>
   
 <section>
   <title>Usage</title>
   <p>Use the JOIN operator with the corresponding keywords to perform left, right, or full outer joins.  
   The keyword OUTER is optional for outer joins; the keywords LEFT, RIGHT and FULL will imply left outer, right outer and full outer joins respectively when OUTER is omitted. 
   The Pig Latin syntax closely adheres to the SQL standard.</p>
    <p>
   Please note the following:
    </p>
    <ul>
		<li>
			<p>Outer joins will only work provided the relations which need to produce nulls (in the case of non-matching keys) have schemas.</p>
		</li>
		<li>
			<p>Outer joins will only work for two-way joins; to perform a multi-way outer join, you will need to perform multiple two-way outer join statements.</p>
		</li>
    </ul>
</section>

   <section>
   <title>Examples</title>
<p>This example shows a left outer join.</p>
<source>
A = LOAD 'a.txt' AS (n:chararray, a:int); 
B = LOAD 'b.txt' AS (n:chararray, m:chararray);
C = JOIN A by $0 LEFT OUTER, B BY $0;
</source>

<p>This example shows a full outer join.</p>
<source>
A = LOAD 'a.txt' AS (n:chararray, a:int); 
B = LOAD 'b.txt' AS (n:chararray, m:chararray);
C = JOIN A BY $0 FULL, B BY $0;
</source>

<p>This example shows a replicated left outer join.</p>
<source>
A = LOAD 'large';
B = LOAD 'tiny';
C= JOIN A BY $0 LEFT, B BY $0 USING 'replicated';
</source>

<p>This example shows a skewed full outer join.</p>
<source>
A = LOAD 'studenttab' as (name, age, gpa);
B = LOAD 'votertab' as (name, age, registration, contribution);
C = JOIN A BY name FULL, B BY name USING 'skewed';
</source>
</section>
</section>  
  
<!-- =========================================================================== -->

   <section id="limit">
   <title>LIMIT </title>
   <p>Limits the number of output tuples.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>alias = LIMIT alias  n;</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name of a relation.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>n</p>
            </td>
            <td>
               <p>The number of output tuples, either:</p>
               <ul>
					<li>a constant (for example, 3)</li>
					<li>a scalar used in an expression (for example, c.sum/100)</li>
				</ul>
				<p></p>
				<p>Note: The expression can consist of constants or scalars; it cannot contain any columns from the input relation.</p>
				<p>Note: Using a scalar instead of a constant in LIMIT automatically disables most optimizations (only push-before-foreach is performed).</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Usage</title>
   <p>Use the LIMIT operator to limit the number of output tuples.</p> 
   
   <p>If the specified number of output tuples is equal to or exceeds the number of tuples in the relation, all tuples in the relation are returned.</p>
   <p>If the specified number of output tuples is less than the number of tuples in the relation, then n tuples are returned. There is no guarantee which n tuples will be returned, and the tuples that are returned can change from one run to the next. A particular set of tuples can be requested using the ORDER operator followed by LIMIT.</p>
   <p>Note: The LIMIT operator allows Pig to avoid processing all tuples in a relation. In most cases a query that uses LIMIT will run more efficiently than an identical query that does not use LIMIT. It is always a good idea to use limit if you can.</p>
   </section>
   
   <section>
   <title>Examples</title>
   <p>In this example the lmit is express as a scalar.</p>
 <source>
a = load 'a.txt';
b = group a all;
c = foreach b generate COUNT(a) as sum;
d = order a by $0;
e = limit d c.sum/100;
</source>
<p></p>
   <p>Suppose we have relation A.</p>
<source>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)
</source>
   
   <p>In this example output is limited to 3 tuples. Note that there is no guarantee which three tuples will be output.</p>
<source>
X = LIMIT A 3;

DUMP X;
(1,2,3)
(4,3,3)
(7,2,5)
</source>
   
   <p>In this example the ORDER operator is used to order the tuples and the LIMIT operator is used to output the first three tuples.</p>
<source>
B = ORDER A BY f1 DESC, f2 ASC;

DUMP B;
(8,3,4) 
(8,4,3) 
(7,2,5) 
(4,2,1)
(4,3,3)
(1,2,3)

X = LIMIT B 3;

DUMP X;
(8,3,4)
(8,4,3) 
(7,2,5) 
</source>
   </section></section>
   
   <!-- =========================================================================== -->
   
   <section id="load">
   <title>LOAD </title>
   <p>Loads data from the file system.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>LOAD 'data' [USING function] [AS schema];        </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>'data'</p>
            </td>
            <td>
               <p>The name of the file or directory, in single quotes.</p>
               <p>If you specify a directory name, all the files in the directory are loaded. </p>
               <p>You can use Hadoop globing to specify files at the file system or directory levels (see Hadoop
                  <a href="http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/fs/FileSystem.html#globStatus(org.apache.hadoop.fs.Path)">globStatus</a> for details on globing syntax).</p>
                  <p id="load-glob"><strong>Note:</strong> Pig uses Hadoop globbing so the functionality is IDENTICAL. However, when you run from the command line using the Hadoop fs command (rather than the Pig LOAD operator), the Unix shell may do some of the substitutions; this could alter the outcome giving the impression that globing works differently for Pig and Hadoop. For example:</p>
                <ul>
					<li>This works <br></br>hadoop fs -ls /mydata/20110423{00,01,02,03,04,05,06,07,08,09,{10..23}}00//<strong>part </strong></li>
					<li>This does not work <br></br>LOAD '/mydata/20110423{00,01,02,03,04,05,06,07,08,09,{10..23}}00//<strong>part </strong>'</li>
				</ul>
            </td>
         </tr>
         <tr>
            <td>
               <p>USING</p>
            </td>
            <td>
               <p>Keyword. </p>
               <p>If the USING clause is omitted, the default load function PigStorage is used. </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>function</p>
            </td>
            <td>
               <p>The load function. </p>
               <ul>
                  <li>
                  
                  
                     <p>You can use a built in function (see <a href="func.html#Load-Store-Functions">Load/Store Functions</a>). PigStorage is the default load function and does not need to be specified (simply omit the USING clause).</p>
                  </li>
                  <li>
                     <p>You can write your own load function  
                     if your data is in a format that cannot be processed by the built in functions (see <a href="udf.html">User Defined Functions</a>).</p>
                  </li>
               </ul>
            </td>
         </tr>
         <tr>
            <td>
               <p>AS</p>
            </td>
            <td>
               <p>Keyword. </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>schema</p>
            </td>
            <td>
               <p>A schema using the AS keyword, enclosed in parentheses (see <a href="#schemas">Schemas</a>).</p>
               <p>The loader produces the data of the type specified by the schema. If the data does not conform to the schema, depending on the loader, either a null value or an error is generated.</p>
               <p>Note: For performance reasons the loader may not immediately convert the data to the specified format; however, you can still operate on the data assuming the specified type.</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Usage</title>
   <p>Use the LOAD operator to load data from the file system. </p></section>
   
   <section>
   <title>Examples</title>
   <p>Suppose we have a data file called myfile.txt. The fields are tab-delimited. The records are newline-separated.</p>
<source>
1 2 3
4 2 1
8 3 4
</source>
   
   <p>In this example the default load function, PigStorage, loads data from myfile.txt to form relation A. The two LOAD statements are equivalent. Note that, because no schema is specified, the fields are not named and all fields default to type bytearray. </p>
<source>
A = LOAD 'myfile.txt';

A = LOAD 'myfile.txt' USING PigStorage('\t');

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
</source>
   
   <p>In this example a schema is specified using the AS keyword. The two LOAD statements are equivalent. You can use the DESCRIBE and ILLUSTRATE operators to view the schema. </p>
<source>
A = LOAD 'myfile.txt' AS (f1:int, f2:int, f3:int);

A = LOAD 'myfile.txt' USING PigStorage(‘\t’) AS (f1:int, f2:int, f3:int);

DESCRIBE A;
a: {f1: int,f2: int,f3: int}

ILLUSTRATE A;
---------------------------------------------------------
| a     | f1: bytearray | f2: bytearray | f3: bytearray |
---------------------------------------------------------
|       | 4             | 2             | 1             |
---------------------------------------------------------

---------------------------------------
| a     | f1: int | f2: int | f3: int |
---------------------------------------
|       | 4       | 2       | 1       |
---------------------------------------
</source>
   <p>
      For examples of how to specify more complex schemas for use with the LOAD operator, see Schemas for Complex Data Types and Schemas for Multiple Types.
      </p></section></section>
      

<!-- =================================================================== -->
<section id="mapreduce">
   <title>MAPREDUCE</title>
   <p>Executes native MapReduce jobs inside a Pig script.</p>      
   
   <section>
   <title>Syntax</title>
      <table>
      <tr> 
            <td>
               <p>alias1 = MAPREDUCE 'mr.jar' STORE alias2 INTO 
'inputLocation' USING storeFunc LOAD 'outputLocation' USING loadFunc AS schema [`params, ... `];</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias1, alias2</p>
            </td>
            <td>
               <p>The names of relations.</p>
            </td>
     </tr>
     <tr>
            <td>
               <p>mr.jar</p>
            </td>
            <td>
                <p>The MapReduce jar file (enclosed in single quotes).</p>
               <p>You can specify any MapReduce jar file that can be run through the <code>hadoop jar mymr.jar params</code> command. </p>
               <p>The values for inputLocation and outputLocation can be passed in the params. </p>
            </td>
     </tr>

      <tr>
            <td>
               <p>STORE ... INTO ... USING</p>
            </td>
            <td>
               <p>See <a href="basic.html#STORE">STORE</a></p>
               <p>Store alias2 into the inputLocation using storeFunc, which is then used by the MapReduce job to read its data.</p>
                
            </td>
     </tr>

      <tr>
            <td>
               <p>LOAD ... USING ... AS </p>
            </td>
            <td>
               <p>See <a href="basic.html#LOAD">LOAD</a></p>
               <p>After running mr1.jar's MapReduce job, load back the data from outputLocation into alias1 using loadFunc as schema.</p>
            </td>
     </tr>

      <tr>
            <td>
               <p>`params, ...`</p>
            </td>
            <td>
               <p>Extra parameters required for the mapreduce job (enclosed in back tics). </p>
            </td>
     </tr>
       
</table>
</section>

<section>
<title>Usage</title>
<p>Use the MAPREDUCE operator to run native MapReduce jobs from inside a Pig script.</p>

<p>The input and output locations for the MapReduce program are conveyed to Pig using the STORE/LOAD clauses.  
Pig, however, does not pass this information (nor require that this information be passed) to the MapReduce program. 
If you want to pass the input and output locations to the MapReduce program you can use the params clause or you can hardcode the locations in the MapReduce program.</p>
</section>

<section>
<title>Example</title>
<p>This example demonstrates how to run the wordcount MapReduce progam from Pig.
Note that the files specified as input and output locations in the MAPREDUCE statement will NOT be deleted by Pig automatically. You will need to delete them manually. </p>
<source>
A = LOAD 'WordcountInput.txt';
B = MAPREDUCE 'wordcount.jar' STORE A INTO 'inputDir' LOAD 'outputDir' 
    AS (word:chararray, count: int) `org.myorg.WordCount inputDir outputDir`;
</source>
</section>

</section>
 
 <!-- =================================================================== -->     
      <section id="order-by">
      <title>ORDER BY</title>
   <p>Sorts a relation based on one or more fields.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>alias = ORDER alias BY { * [ASC|DESC] | field_alias [ASC|DESC] [, field_alias [ASC|DESC] …] } [PARALLEL n];</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name of a relation.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>*</p>
            </td>
            <td>
               <p>The designator for a tuple.</p>
            </td>
         </tr>
                  <tr>
            <td>
               <p>field_alias</p>
            </td>
            <td>
               <p>A field in the relation. The field must be a simple type.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>ASC</p>
            </td>
            <td>
               <p>Sort in ascending order.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>DESC</p>
            </td>
            <td>
               <p>Sort in descending order.</p>
            </td>
         </tr>

         <tr>
            <td>
               <p>PARALLEL n</p>
            </td>
            <td>
               <p>Increase the parallelism of a job by specifying the number of reduce tasks, n.</p>
               <p>For more information, see <a href="perf.html#Parallel">Use the Parallel Features</a>.</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Usage</title>
   <p><strong>Note:</strong> ORDER BY is NOT stable; if multiple records have the same ORDER BY key, the order in which these records are returned is not defined and is not guarantted to be the same from one run to the next.</p>
   
   <p>In Pig, relations are unordered (see <a href="#relations">Relations, Bags, Tuples, Fields</a>):</p>
   <ul>
      <li>
         <p>If you order relation A to produce relation X (X = ORDER A BY * DESC;) relations A and X still contain the same data. </p>
      </li>
      <li>
         <p>If you retrieve relation X (DUMP X;) the data is guaranteed to be in the order you specified (descending).</p>
      </li>
      <li>
         <p>However, if you further process relation X (Y = FILTER X BY $0 &gt; 1;) there is no guarantee that the data will be processed in the order you originally specified (descending).</p>
      </li>
   </ul>
   <p></p>
      <p>Pig currently supports ordering on fields with simple types or by tuple designator (*). You cannot order on fields with complex types or by expressions. </p>
     <source>
A = LOAD 'mydata' AS (x: int, y: map[]);     
B = ORDER A BY x; -- this is allowed because x is a simple type
B = ORDER A BY y; -- this is not allowed because y is a complex type
B = ORDER A BY y#'id'; -- this is not allowed because y#'id' is an expression
</source> 
   </section>

   <section>
   <title>Examples</title>
   <p>Suppose we have relation A.</p>
<source>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)
</source>
   
   <p>In this example relation A is sorted by the third field, f3 in descending order. Note that the order of the three tuples ending in 3 can vary.</p>
<source>
X = ORDER A BY a3 DESC;

DUMP X;
(7,2,5)
(8,3,4)
(1,2,3)
(4,3,3)
(8,4,3)
(4,2,1)
</source>
   
   </section></section>
   


<!-- =========================================================================== -->
   <section id="sample">
   <title>SAMPLE</title>
   <p>Partitions a relation into two or more relations.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>SAMPLE alias size;</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name of a relation.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>size</p>
            </td>
            <td>
               <p>Sample size, either</p>
               <ul>
               <li>a constant, rage 0 to 1 (for example, enter 0.1 for 10%)</li>
                <li>a scalar used in an expression</li>
               </ul>
               <p></p>
               <p>Note: The expression can consist of constants or scalars; it cannot contain any columns from the input relation.</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
     <title>Usage</title>
     <p>Use the SAMPLE operator to select a random data sample with the stated sample size. 
     SAMPLE is a probabalistic operator; there is no guarantee that the exact same number of tuples will be returned for a particular sample size
     each time the operator is used.</p>
   </section>
   
   <section>
   <title>Example</title>
   <p>In this example relation X will contain 1% of the data in relation A.</p>
<source>
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

X = SAMPLE A 0.01;
</source>
<p>In this example, a scalar expression is used (it will sample approximately 1000 records from the input).</p>
<source>
a = load 'a.txt';
b = group a all;
c = foreach b generate COUNT(a) as num_rows;
e = sample d 1000/num_rows;
</source>
   </section></section>  
   
   <section>
   <title>SPLIT</title>
   <p>Partitions a relation into two or more relations.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>SPLIT alias INTO alias IF expression, alias IF expression [, alias IF expression …] [, alias OTHERWISE];</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name of a relation.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>INTO</p>
            </td>
            <td>
               <p>Required keyword.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>IF</p>
            </td>
            <td>
               <p>Required keyword.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression.</p>
            </td>
         </tr> 
           <tr>
            <td>
               <p>OTHERWISE</p>
            </td>
            <td>
               <p>Optional keyword. Designates a default relation.</p>
            </td>
         </tr>
   </table></section>
   
   <section>
   <title>Usage</title>
   <p>Use the SPLIT operator to partition the contents of a relation into two or more relations based on some expression. Depending on the conditions stated in the expression:</p>
   <ul>
      <li>
         <p>A tuple may be assigned to more than one relation.</p>
      </li>
      <li>
         <p>A tuple may not be assigned to any relation.</p>
         <p></p>
         <p></p>
      </li>
   </ul></section>
   
   <section>
   <title>Example</title>
   <p>In this example relation A is split into three relations, X, Y, and Z.</p>
<source>
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

DUMP A;                
(1,2,3)
(4,5,6)
(7,8,9)        

SPLIT A INTO X IF f1&lt;7, Y IF f2==5, Z IF (f3&lt;6 OR f3&gt;6);

DUMP X;
(1,2,3)
(4,5,6)

DUMP Y;
(4,5,6)

DUMP Z;
(1,2,3)
(7,8,9)
</source>
</section>


      <section>
   <title>Example</title>
   <p>In this example, the SPLIT and FILTER statements are essentially equivalent. 
   However, because SPLIT is implemented as "split the data stream and then apply filters" the 
  SPLIT statement is more expensive than the FILTER statement because Pig needs to filter and store two data streams.</p>
   <source>
SPLIT input_var INTO output_var IF (field1 is not null), ignored_var IF (field1 is null);  
-- where ignored_var is not used elsewhere
   
output_var = FILTER input_var BY (field1 is not null);
   </source>
      </section>
   </section>


<!-- =========================================================================== -->   

   <section id="store">
   <title>STORE </title>
   <p>Stores or saves results to the file system.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>STORE alias INTO 'directory' [USING function];</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name of a relation.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>INTO</p>
            </td>
            <td>
               <p>Required keyword.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>'directory'</p>
            </td>
            <td>
               <p>The name of the storage directory, in quotes. If the directory already exists, the STORE operation will fail.</p>
               <p></p>
               <p>The output data files, named part-nnnnn, are written to this directory. </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>USING</p>
            </td>
            <td>
               <p>Keyword. Use this clause to name the store function.</p>
               <p>If the USING clause is omitted, the default store function PigStorage is used.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>function</p>
            </td>
            <td>
               <p>The store function.</p>
               <ul>
                  <li>
                  
                  
                     <p>You can use a built in function (see the <a href="func.html#Load-Store-Functions">Load/Store Functions</a>). PigStorage is the default store function and does not need to be specified (simply omit the USING clause).</p>
                  </li>
                  <li>
                     <p>You can write your own store function  
                     if your data is in a format that cannot be processed by the built in functions (see <a href="udf.html">User Defined Functions</a>).</p>
                  </li>
               </ul>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Usage</title>
   <p>Use the STORE operator to run (execute) Pig Latin statements and save (persist) results to the file system. Use STORE for production scripts and batch mode processing.</p>
   
   <p>Note: To debug scripts during development, you can use <a href="test.html#DUMP">DUMP</a> to check intermediate results.</p>
</section>
   
   <section>
   <title>Examples</title>
   <p>In this example data is stored using PigStorage and the asterisk character (*) as the field delimiter.</p>
<source>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

STORE A INTO 'myoutput' USING PigStorage ('*');

CAT myoutput;
1*2*3
4*2*1
8*3*4
4*3*3
7*2*5
8*4*3
</source>
   
   <p>In this example, the CONCAT function is used to format the data before it is stored.</p>
<source>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = FOREACH A GENERATE CONCAT('a:',(chararray)f1), CONCAT('b:',(chararray)f2), CONCAT('c:',(chararray)f3);

DUMP B;
(a:1,b:2,c:3)
(a:4,b:2,c:1)
(a:8,b:3,c:4)
(a:4,b:3,c:3)
(a:7,b:2,c:5)
(a:8,b:4,c:3)

STORE B INTO 'myoutput' using PigStorage(',');

CAT myoutput;
a:1,b:2,c:3
a:4,b:2,c:1
a:8,b:3,c:4
a:4,b:3,c:3
a:7,b:2,c:5
a:8,b:4,c:3
</source>
   
   </section></section>
   
   
   <!-- =========================================================================== -->
   
   <section id="stream">
   <title>STREAM</title>
   <p>Sends data to an external script or program.</p>
      
      <section>
      <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>alias = STREAM alias [, alias …] THROUGH {`command` | cmd_alias } [AS schema] ;</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name of a relation.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>THROUGH</p>
            </td>
            <td>
               <p>Keyword. </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>`command`</p>
            </td>
            <td>
               <p>A command, including the arguments, enclosed in back tics (where a command is anything that can be executed).</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>cmd_alias</p>
            </td>
            <td>
               <p>The name of a command created using the DEFINE operator (see <a href="#define-udfs">DEFINE (UDFs, streaming)</a>  for additional  streaming examples).</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>AS</p>
            </td>
            <td>
               <p>Keyword.</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>schema</p>
            </td>
            <td>
               <p>A schema using the AS keyword, enclosed in parentheses (see <a href="#schemas">Schemas</a>).</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Usage</title>
   <p>Use the STREAM operator to send data through an external script or program. Multiple stream operators can appear in the same Pig script. The stream operators can be adjacent to each other or have other operations in between.</p>
   <p>When used with a command, a stream statement could look like this:</p>
<source>
A = LOAD 'data';

B = STREAM A THROUGH `stream.pl -n 5`;
</source>
   <p>When used with a cmd_alias, a stream statement could look like this, where mycmd is the defined alias.</p>
<source>
A = LOAD 'data';

DEFINE mycmd `stream.pl –n 5`;

B = STREAM A THROUGH mycmd;
</source>
   </section>
   
   <section>
   <title>About Data Guarantees</title>
   <p>Data guarantees are determined based on the position of the streaming operator in the Pig script. </p>
   <ul>
      <li>
         <p>Unordered data – No guarantee for the order in which the data is delivered to the streaming application. </p>
      </li>
      <li>
         <p>Grouped data – The data for the same grouped key is guaranteed to be provided to the streaming application contiguously</p>
      </li>
      <li>
         <p>Grouped and ordered data – The data for the same grouped key is guaranteed to be provided to the streaming application contiguously. Additionally, the data within the group is guaranteed to be sorted by the provided secondary key.</p>
      </li>
   </ul>
   <p>In addition to position, data grouping and ordering can be determined by the data itself. However, you need to know the property of the data to be able to take advantage of its structure.</p>
   </section>
   
   <section>
   <title>Example: Data Guarantees</title>
   <p>In this example the data is unordered.</p>
<source>
A = LOAD 'data';

B = STREAM A THROUGH `stream.pl`;
</source>
   
   <p>In this example the data is grouped.</p>
<source>
A = LOAD 'data';

B = GROUP A BY $1;

C = FOREACH B FLATTEN(A);

D = STREAM C THROUGH `stream.pl`;
</source>
   
   <p>In this example the data is grouped and ordered.</p>
<source>
A = LOAD 'data';

B = GROUP A BY $1;

C = FOREACH B {
      D = ORDER A BY ($3, $4);
      GENERATE D;
}

E = STREAM C THROUGH `stream.pl`;
</source>
   </section>
   
   <section>
   <title>Example: Schemas</title>
   <p>In this example a schema is specified as part of the STREAM statement.</p>
<source>
X = STREAM A THROUGH `stream.pl` as (f1:int, f2:int, f3:int);
</source>
   </section>
   </section>
   
   
   <!-- =========================================================================== -->
   
   <section id="union">
   <title>UNION</title>
   <p>Computes the union of two or more relations.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>alias = UNION [ONSCHEMA] alias, alias [, alias …];</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
       
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name of a relation.</p>
            </td>
      </tr>
      
      <tr>
             <td>
               <p id="onschema">ONSCHEMA </p>  
            </td>
            <td>
               <p>Use the ONSCHEMA clause to base the union on named fields (rather than positional notation). 
               All inputs to the union must have a non-unknown (non-null) <a href="#schemas">schema</a>.</p>
            </td>
         </tr>
   </table>
   </section>
   
   <section>
   <title>Usage</title>
   <p>Use the UNION operator to merge the contents of two or more relations. The UNION operator:</p>
   <ul>
      <li>
         <p>Does not preserve the order of tuples. Both the input and output relations are interpreted as unordered bags of tuples.</p>
      </li>
      <li>
         <p>Does not ensure (as databases do) that all tuples adhere to the same schema or that they have the same number of fields. In a typical scenario, however, this should be the case; therefore, it is the user's responsibility to either (1) ensure that the tuples in the input relations have the same schema or (2) be able to process varying tuples in the output relation.</p>
      </li>
      <li>
         <p>Does not eliminate duplicate tuples.</p>
      </li>
   </ul>
   <p></p> 
   <p><strong>Schema Behavior</strong></p>
   <p>The behavior of schemas for UNION (positional notation / data types) and UNION ONSCHEMA (named fields / data types) is the same, except where noted.</p>

<p>Union on relations with two different sizes result in a null schema (union only): </p>
<source>
A: (a1:long, a2:long) 
B: (b1:long, b2:long, b3:long) 
A union B: null 
</source>
  
<p>Union columns with incompatible types result in a bytearray type: </p>
<source>
A: (a1:long, a2:long) 
B: (b1:(b11:long, b12:long), b2:long) 
A union B: (a1:bytearray, a2:long) 
</source>

<p>Union columns of compatible type will produce an "escalate" type. 
The priority is:</p>
<ul>
<li>double &gt; float &gt; long &gt; int &gt; bytearray</li>
<li>tuple|bag|map|chararray &gt; bytearray</li>
</ul>
<source>
A: (a1:int, a2:bytearray, a3:int) 
B: (b1:float, b2:chararray, b3:bytearray) 
A union B: (a1:float, a2:chararray, a3:int) 
</source>

<p>Union of different inner types results in an empty complex type: </p>
<source>
A: (a1:(a11:long, a12:int), a2:{(a21:charray, a22:int)}) 
B: (b1:(b11:int, b12:int), b2:{(b21:int, b22:int)}) 
A union B: (a1:(), a2:{()}) 
</source>  

<p>The alias of the first relation is always taken as the alias of the unioned relation field. </p>  
   
</section>

   <section>
   <title>Example</title>
   <p>In this example the union of relation A and B is computed.</p>
<source>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)

B = LOAD 'data' AS (b1:int,b2:int);

DUMP A;
(2,4)
(8,9)
(1,3)

X = UNION A, B;

DUMP X;
(1,2,3)
(4,2,1)
(2,4)
(8,9)
(1,3)
</source>
   </section>
   
   <section>
   <title>Example</title>
   <p>This example shows the use of ONSCHEMA.</p>
<source>
L1 = LOAD 'f1' USING (a : int, b : float);
DUMP L1;
(11,12.0)
(21,22.0)

L2 = LOAD  'f1' USING (a : long, c : chararray);
DUMP L2;
(11,a)
(12,b)
(13,c)

U = UNION ONSCHEMA L1, L2;
DESCRIBE U ;
U : {a : long, b : float, c : chararray}

DUMP U;
(11,12.0,)
(21,22.0,)
(11,,a)
(12,,b)
(13,,c)
</source>
</section>
</section>
</section>
   
   
   <!-- =========================================================================== -->
   <!-- =========================================================================== -->
   
    <!-- UDF STATEMENTS --> 
   <section id="udf-statements">
   <title>UDF Statements</title>
   
<!-- ======================================================== -->
   <section id="define-udfs">
   <title>DEFINE (UDFs, streaming)</title>
   <p>Assigns an alias to a UDF or streaming command.</p>
   
   <section>
   <title>Syntax: UDF and streaming</title>
   <table>
      <tr> 
            <td>
               <p>DEFINE alias {function | [`command` [input] [output] [ship] [cache] [stderr] ] };</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>alias</p>
            </td>
            <td>
               <p>The name for a UDF function or the name for a streaming command (the cmd_alias for the <a href="#STREAM">STREAM</a> operator). </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>function</p>
            </td>
            <td>
            <p>For use with functions.</p>
               <p>The name of a UDF function. </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>`command`</p>
            </td>
            <td>
            <p>For use with streaming.</p>
               <p>A command, including the arguments, enclosed in back tics (where a command is anything that can be executed).</p>
               <p>The clauses (input, output, ship, cache, stderr) are described below. Note the following:</p>
               <ul>
                  <li>All clauses are optional.</li>
				  <li>The clauses can be specified in any order (for example, stderr can appear before input)</li>
				  <li>Each clause can be specified at most once (for example, multiple inputs are not allowed)</li>
				</ul>
            </td>
         </tr>
         <tr>
            <td>
               <p>input</p>
            </td>
            <td>
                <p>For use with streaming.</p>
               <p>INPUT ( {stdin | 'path'} [USING serializer] [, {stdin | 'path'} [USING serializer] …] )</p>
               <p>Where:</p>
               <ul>
                  <li>
                     <p>INPUT – Keyword.</p>
                  </li>
                  <li>
                     <p>'path' – A file path, enclosed in single quotes.</p>
                  </li>
                  <li>
                     <p>USING – Keyword.</p>
                  </li>
                  <li>
                     <p>serializer – PigStreaming is the default serializer. </p>
                  </li>
               </ul>
            </td>
         </tr>
         <tr>
            <td>
               <p>output</p>
            </td>
            <td>
            <p>For use with streaming.</p>
               <p>OUTPUT ( {stdout | stderr | 'path'} [USING deserializer] [, {stdout | stderr | 'path'} [USING deserializer] …] )</p>
               <p>Where:</p>
               <ul>
                  <li>
                     <p>OUTPUT – Keyword.</p>
                  </li>
                  <li>
                     <p>'path' – A file path, enclosed in single quotes.</p>
                  </li>
                  <li>
                     <p>USING – Keyword.</p>
                  </li>
                  <li>
                     <p>deserializer – PigStreaming is the default deserializer. </p>
                  </li>
               </ul>
            </td>
         </tr>
         <tr>
            <td>
               <p id="ship">ship</p>
            </td>
            <td>
            <p>For use with streaming.</p>
               <p>SHIP('path' [, 'path' …])</p>
               <p>Where:</p>
               <ul>
                  <li>
                     <p>SHIP – Keyword.</p>
                  </li>
                  <li>
                     <p>'path' – A file path, enclosed in single quotes.</p>
                  </li>
               </ul>
            </td>
         </tr>
         <tr>
            <td>
               <p id="cache">cache</p>
            </td>
            <td>
            <p>For use with streaming.</p>
               <p>CACHE('dfs_path#dfs_file' [, 'dfs_path#dfs_file' …])</p>
               <p>Where:</p>
               <ul>
                  <li>
                     <p>CACHE – Keyword.</p>
                  </li>
                  <li>
                     <p>'dfs_path#dfs_file' – A file path/file name on the distributed file system, enclosed in single quotes. Example: '/mydir/mydata.txt#mydata.txt'</p>
                  </li>
               </ul>
            </td>
         </tr> 
         <tr>
            <td>
               <p>stderr</p>
            </td>
           <td>
            <p>For use with streaming.</p>
            <p>STDERR( '/dir') or STDERR( '/dir' LIMIT n)</p>
             <p>Where:</p>
             <ul><li>'/dir' is the log directory, enclosed in single quotes.</li></ul>
             <ul><li>(optional) LIMIT n is the error threshold where n is an integer value. If not specified, the default error threshold is unlimited.</li></ul>
            </td>
         </tr>
   </table></section>
   
   <section>
   <title>Usage</title>
   <p>Use the DEFINE statement to assign a name (alias) to a UDF function or to a streaming command.</p>
   <p>Use DEFINE to specify a UDF function when:</p>
   <ul>
      <li>
         <p>The function has a long package name that you don't want to include in a script, especially if you call the function several times in that script.</p>
      </li>
      <li>
         <p>The constructor for the function takes string parameters. If you need to use different constructor parameters for different calls to the function you will need to create multiple defines – one for each parameter set.</p>
      </li>
   </ul>
   <p>Use DEFINE to specify a streaming command when: </p>
   <ul>
   <li>
   <p>The streaming command specification is complex.</p>
   </li>
      <li>
   <p>The streaming command specification requires additional parameters (input, output, and so on).</p>
   </li>
   </ul>
   
   
   <section>
   <title>About Input and Output</title>
   <p>Serialization is needed to convert data from tuples to a format that can be processed by the streaming application. Deserialization is needed to convert the output from the streaming application back into tuples. PigStreaming is the default serialization/deserialization function.</p>
   
<p>Streaming uses the same default format as PigStorage to serialize/deserialize the data. If you want to explicitly specify a format, you can do it as show below (see more examples in the Examples: Input/Output section).  </p> 

<source>
DEFINE CMD `perl PigStreaming.pl - nameMap` input(stdin using PigStreaming(',')) output(stdout using PigStreaming(','));
A = LOAD 'file';
B = STREAM B THROUGH CMD;
</source>  

<p>If you need an alternative format, you will need to create a custom serializer/deserializer by implementing the following interfaces.</p>

<source>
interface PigToStream {

        /**
         * Given a tuple, produce an array of bytes to be passed to the streaming
         * executable.
         */
        public byte[] serialize(Tuple t) throws IOException;
    }

    interface StreamToPig {

        /**
         *  Given a byte array from a streaming executable, produce a tuple.
         */
        public Tuple deserialize(byte[]) throws IOException;

        /**
         * This will be called on the front end during planning and not on the back
         * end during execution.
         *
         * @return the {@link LoadCaster} associated with this object.
         * @throws IOException if there is an exception during LoadCaster
         */
        public LoadCaster getLoadCaster() throws IOException;
    }
</source>  
   
   </section>
   
   <section id="ship-about">
   <title>About Ship </title>
   <p>Use the ship option to send streaming binary and supporting files, if any, from the client node to the compute nodes. Pig does not automatically ship dependencies; it is your responsibility to explicitly specify all the dependencies and to make sure that the software the processing relies on (for instance, perl or python) is installed on the cluster. Supporting files are shipped to the task's current working directory and only relative paths should be specified. Any pre-installed binaries should be specified in the PATH. </p>
   <p>Only files, not directories, can be specified with the ship option. One way to work around this limitation is to tar all the dependencies into a tar file that accurately reflects the structure needed on the compute nodes, then have a wrapper for your script that un-tars the dependencies prior to execution.</p>
   <p>Note that the ship option has two components: the source specification, provided in the ship( ) clause, is the view of your machine; the command specification is the view of the actual cluster. The only guarantee is that the shipped files are available in the current working directory of the launched job and that your current working directory is also on the PATH environment variable. </p>
   <p>Shipping files to relative paths or absolute paths is not supported since you might not have permission to read/write/execute from arbitrary paths on the clusters.</p>
   
    <p>Note the following:</p>
	<ul>
		<li>
			<p>It is safe only to ship files to be executed from the current working directory on the task on the cluster.</p>
			<source>
OP = stream IP through 'script';
or
DEFINE CMD 'script' ship('/a/b/script');
OP = stream IP through 'CMD';
</source>
		</li>
	    <li>
			<p>Shipping files to relative paths or absolute paths is undefined and mostly will fail since you may not have permissions to read/write/execute from arbitraty paths on the actual clusters. </p>
	    </li>
	</ul>   
   </section>
   
   
   <section id="cache-about">
   <title>About Cache</title>
   <p>The ship option works with binaries, jars, and small datasets. However, loading larger datasets at run time for every execution can severely impact performance. Instead, use the cache option to access large files already moved to and available on the compute nodes. Only files, not directories, can be specified with the cache option.</p>
   </section>
   
   <section id="autoship">
   <title>About Auto-Ship</title>
   <p>If the ship and cache options are not specified, Pig will attempt to auto-ship the binary in the following way:</p>
   <ul>
		<li>
            <p>If the first word on the streaming command is perl or python, Pig assumes that the binary is the first non-quoted string it encounters that does not start with dash.</p>
		</li>
		<li>
			<p>Otherwise, Pig will attempt to ship the first string from the command line as long as it does not come from <code>/bin, /usr/bin, /usr/local/bin</code>. Pig will determine this by scanning the path if an absolute path is provided or by executing  <code>which</code>. The paths can be made configurable using the <a href="cmds.html#set">set stream.skippath</a> option (you can use multiple set commands to specify more than one path to skip). </p>
		</li>
	</ul>
	<p>If you don't supply a DEFINE for a given streaming command, then auto-shipping is turned off.</p>
	<p>Note the following:</p>
	<ul>
		<li>
			<p>If Pig determines that it needs to auto-ship an absolute path it will not ship it at all since there is no way to ship files to the necessary location (lack of permissions and so on). </p>
			<source>
OP = stream IP through `/a/b/c/script`;
or 
OP = stream IP through `perl /a/b/c/script.pl`;
</source>
		</li>
	    <li>
			<p>Pig will not auto-ship files in the following system directories (this is determined by executing 'which &lt;file&gt;' command). </p>
			<source>
/bin /usr/bin /usr/local/bin /sbin /usr/sbin /usr/local/sbin
</source>
		</li>
	    <li>
			<p>To auto-ship, the file in question should be present in the PATH. So if the file is in the current working directory then the current working directory should be in the PATH. </p>
		</li>
	</ul>
   
   </section>
      </section>
   
 <section>
 <title>Examples: Input/Output</title>
 <p>In this example PigStreaming is the default serialization/deserialization function. The tuples from relation A are converted to tab-delimited lines that are passed to the script.</p>
<source>
X = STREAM A THROUGH `stream.pl`;
</source>
   
   <p>In this example PigStreaming is used as the serialization/deserialization function, but a comma is used as the delimiter.</p>
<source>
DEFINE Y 'stream.pl' INPUT(stdin USING PigStreaming(',')) OUTPUT (stdout USING PigStreaming(','));

X = STREAM A THROUGH Y;
</source>
   
   <p>In this example user defined serialization/deserialization functions are used with the script.</p>
<source>
DEFINE Y 'stream.pl' INPUT(stdin USING MySerializer) OUTPUT (stdout USING MyDeserializer);

X = STREAM A THROUGH Y;
</source>
   </section>
   
   <section>
   <title>Examples: Ship/Cache</title>
   <p>In this example ship is used to send the script to the cluster compute nodes.</p>
<source>
DEFINE Y 'stream.pl' SHIP('/work/stream.pl');

X = STREAM A THROUGH Y;
</source>
   
   <p>In this example cache is used to specify a file located on the cluster compute nodes.</p>
<source>
DEFINE Y 'stream.pl data.gz' SHIP('/work/stream.pl') CACHE('/input/data.gz#data.gz');

X = STREAM A THROUGH Y;
</source>
   </section>
   
 
     <section>
   <title>Example: DEFINE with STREAM</title>
<p>In this example a command is defined for use with the <a href="#STREAM">STREAM</a> operator.</p>
<source>
A = LOAD 'data';

DEFINE mycmd 'stream_cmd –input file.dat';

B = STREAM A through mycmd;
</source>
</section>   
   
   <section>
   <title>Examples: Logging</title>
   <p>In this example the streaming stderr is stored in the _logs/&lt;dir&gt; directory of the job's output directory. Because the job can have multiple streaming applications associated with it, you need to ensure that different directory names are used to avoid conflicts. Pig stores up to 100 tasks per streaming job.</p>
<source>
DEFINE Y 'stream.pl' stderr('&lt;dir&gt;' limit 100);

X = STREAM A THROUGH Y;
</source>

   
<p>In this example a function is defined for use with the FOREACH …GENERATE operator.</p>
<source>
REGISTER /src/myfunc.jar

DEFINE myFunc myfunc.MyEvalfunc('foo');

A = LOAD 'students';

B = FOREACH A GENERATE myFunc($0);
</source>

</section>
  </section>   
   
   
   
   <!-- =========================================================================== -->
   <section id="register">
   <title>REGISTER</title>
   <p>Registers a JAR file so that the UDFs in the file can be used.</p>
   
   <section>
   <title>Syntax</title>
   <table>
      <tr> 
            <td>
               <p>REGISTER path;</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
      <tr>
            <td>
               <p>path</p>
            </td>
            <td>
               <p>The path to the JAR file (the full location URI is required). Do not place the name in quotes.</p>
               
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>Usage</title>
   <p><strong>Pig Scripts</strong></p>
   
   <p>Use the REGISTER statement inside a Pig script to specify a JAR file or a Python/JavaScript module. Pig supports JAR files and modules stored in local file systems as well as remote, distributed file systems such as HDFS and Amazon S3 (see <a href="start.html#Pig-Scripts">Pig Scripts</a>).</p>
   
   <p id="register-glob">Additionally, JAR files stored in local file systems can be specified as a glob pattern using “*”. Pig will search for matching jars in the local file system, either the relative path (relative to your working directory) or the absolute path. Pig will pick up all JARs that match the glob.</p>
   
   <p><strong>Command Line</strong></p>
   <p>You can register additional files (to use with your Pig script) via the command line using the -Dpig.additional.jars option. 
For more information see <a href="udf.html">User Defined Functions</a>.</p>
   </section>
   
   <section>
   <title>Examples</title>
<p>In this example REGISTER states that the JavaScript module, myfunc.js, is located in the /src directory.</p>
<source>
/src $ java -jar pig.jar –

REGISTER /src/myfunc.js;
A = LOAD 'students';
B = FOREACH A GENERATE myfunc.MyEvalFunc($0);
</source>
   
<p>In this example additional JAR files are registered via the command line.</p>
<source>
pig -Dpig.additional.jars=my.jar:your.jar script.pig
</source>

<p>In this example a JAR file stored in HDFS is registered.</p>
<source>
java -cp pig.jar org.apache.pig.Main  hdfs://nn.mydomain.com:9020/myscripts/script.pig
</source>

<p>This example shows how to specify a glob pattern using either a relative path or an absolute path.</p>
<source>
register /homes/user/pig/myfunc*.jar
register count*.jar
register jars/*.jar
</source>
   </section>
   </section>
   </section>  

  </body>
</document>

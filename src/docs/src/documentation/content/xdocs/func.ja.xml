<?xml version="1.0" encoding="UTF-8"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">

<document>
  <header>
    <title>組み込み関数 (Built In Functions)</title>
  </header>
  <body>
  
<section id="built-in-functions">
<title>導入</title>
<p>
Pig には多くの関数が組み込まれています (集合関数、ロード・ストア関数、数学関数、文字列関数、バッグ関数、タプル関数等) 。組み込み関数と<a href="udf.html">ユーザ定義関数</a> (UDF) の間には大きく二つの違いがあります。まず、 Pig は元々組み込み関数の存在を知っているので、あえて登録する必要はありません。また、使う時に関数名をパッケージ名で修飾する必要もありません。
</p>	
</section>

<!-- ================================================================== -->
<!-- DYNAMIC INVOKERS -->
<section id="dynamic-invokers">
<title>動的呼び出し</title>

<p><a href="udf.html">ユーザ定義関数</a> (UDF) が用意されていない標準 Java ライブラリ関数を使うためには、動的呼び出しが使えます。動的呼び出しを使うと、 Java のリフレクションのコストが毎回掛かることと引き換えに、ラッパ UDF を用意すること無しに Java の関数が呼び出せます。
</p>

<source>
...
DEFINE UrlDecode InvokeForString('java.net.URLDecoder.decode', 'String String'); 
encoded_strings = LOAD 'encoded_strings.txt' as (encoded:chararray); 
decoded_strings = FOREACH encoded_strings GENERATE UrlDecode(encoded, 'UTF-8'); 
...
</source>

<p>今のところ、動的呼び出しは次のような静的メソッドの呼び出しに使えます:</p>
<ul>
<li>引数をひとつも取らないか、 String, int, long, double, float またそれらの配列のみを引数として取るメソッド</li>
<li>String, int, long, double, float のいずれかを戻すメソッド</li>
</ul>
<p>数値型として使えるのはプリミティブ型だけです。 Integer, Double 等のラッパ型は使えません。戻り値の型に応じて、 InvokeForString, InvokeForInt, InvokeForLong, InvokeForDouble, InvokeForFloat のいずれかを使う必要があります。</p>

<p>上記の例のように、 Java のメソッドと Pig の識別子を結びつけるためには、 <a href="basic.html#define">DEFINE</a> 文を使います。 InvokeFor* コンストラクタの最初の引数は目的となるメソッドのフルパスです。 2 つ目の引数は、 Java メソッドの引数の型を空白文字で区切った文字列です。 Java メソッドが引数を取らない場合は、 2 つ目の引数は省略するか、空文字列にします。有効な型名は string, long, float, double, int です。メソッドが引数として配列を取る場合、 Pig における型は 1 要素のタプルのバッグになります。配列型の型名は、単純に string[] のように表します。型名は大文字・小文字を区別しません。</p>

<p>配列型の引数が動的呼び出しで呼び出せることから、 org.apache.commons.math.stat.StatUtils のようなメソッドを使って、データセットをグルーピングした結果を処理させることもできます。これは便利ですが、 <a href="udf.html#algebraic-interface">Algebraic</a> インタフェースや <a href="udf.html#accumulator-interface">Accumulator</a> インタフェースを使って UDF を定義する場合と比べて、 Hadoop に最適化されていないことに注意してください。</p>
</section>
  
<!-- ======================================================== -->  
<!-- EVAL FUNCTIONS -->    
<section id="eval-functions">
<title>集合関数</title>


<!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->  
<section id="avg">
<title>AVG</title>
   <p>一列のバッグ中の数値の平均値を計算します。</p>
   <section>
   <title>文法</title>
   <table> 
      <tr>
            <td>
               <p>AVG(expression)</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>結果がバッグになる任意の式。バッグの要素は int, long, float, double のいずれかである必要があります。</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>用法</title>
   <p>AVG 関数は、一列のバッグ中の数値の平均を計算するために使います。 データセット全体の平均値を計算するためには、事前に GROUP ALL 文が必要です。グループごとの平均を計算するためには、事前に GROUP BY 文が必要です。</p>
   <p>現在、 AVG 関数は null 値を無視します。</p>      
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、学生ごとに GPA (成績評価値) を計算しています。関係 B のフィールド名については、 <a href="basic.html#GROUP">GROUP</a> を参照してください。</p>
<source>
A = LOAD 'student.txt' AS (name:chararray, term:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

C = FOREACH B GENERATE A.name, AVG(A.gpa);

DUMP C;
({(John),(John),(John),(John)},3.850000023841858)
({(Mary),(Mary),(Mary),(Mary)},3.925000011920929)
</source>
   </section>
   
   <section>
   <title>型テーブル</title>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>AVG </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>double 型にキャストされる</p>
            </td>
         </tr> 
   </table>
   </section></section>
   
   <!-- ++++++++++++++++++++++++++++++++++++++++++++++ --> 
   <section id="concat">
   <title>CONCAT</title>
   <p>同じ型の 2 つの式を連結します。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>CONCAT (expression, expression)</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>任意の式。</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>用法</title>
   <p>CONCAT 関数は 2 つの式を連結するために使います。 2 つの式の結果は同じ型である必要があります。</p>
   </section>

   
   <section>
   <title>例</title>
   <p>次の例ではフィールド f2, f3 を連結しています。</p>
<source>
A = LOAD 'data' as (f1:chararray, f2:chararray, f3:chararray);

DUMP A;
(apache,open,source)
(hadoop,map,reduce)
(pig,pig,latin)

X = FOREACH A GENERATE CONCAT(f2,f3);

DUMP X;
(opensource)
(mapreduce)
(piglatin)
</source>
</section>
</section>
  
  
  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->  
   <section id="count">
   <title>COUNT</title>
   <p>バッグ中の要素の数を数えます。</p>
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>COUNT(expression) </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>バッグ型の任意の式。</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>COUNT 関数はバッグ中の要素の数を数えるために使います。データセット全体で要素の数を数えるには事前に GROUP ALL 文が必要です。グループごとに要素の数を数えるには事前に GROUP BY 文が必要です。</p>

   <p>COUNT 関数は follows syntax semantics, null を無視します。つまり、タプルの最初のフィールドが null である場合、そのタプルは数えられません。 null を含めて数えたい場合は、 <a href="#count-star">COUNT_STAR</a> を使います。</p>
   
   <p>注記: COUNT 関数の引数としてタプル指定子 (*) を使うことはできません。つまり、 COUNT(*) は使えません。</p>
   </section>
   
   
   <section>
   <title>例</title>
   <p>次の例では、バッグ中のタプルの数を数えています。関係 B のフィールド名については <a href="basic.html#GROUP">GROUP</a> を参照してください。</p>
<source>
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY f1;

DUMP B;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(7,{(7,2,5)})
(8,{(8,3,4),(8,4,3)})

X = FOREACH B GENERATE COUNT(A);

DUMP X;
(1L)
(2L)
(1L)
(2L)
</source>
   </section>
   
   <section>
   <title>型テーブル</title>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>COUNT </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
         </tr> 
   </table>
   </section></section>
   
     <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
 <section id="count-star">
   <title>COUNT_STAR</title>
   <p>バッグ中の要素の数を数えます。</p>
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>COUNT_STAR(expression)  </p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>バッグ型の任意の式。</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>用法</title>
   <p>COUNT_STAR 関数はバッグ中の要素の数を数えます。データセット全体で要素を数えるには事前に GROUP ALL 文が必要です。グループごとに要素の数を数えるには事前に GROUP BY 文が必要です。</p>
   <p>COUNT_STAR は null 値を含んで要素の数を数えます (<a href="#count">COUNT</a> が null を無視するのと対照的です) 。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では COUNT_STAR 関数でバッグ中のタプルの数を数えています。</p>
<source>
X = FOREACH B GENERATE COUNT_STAR(A);
</source>
   </section>
    </section>
  
    <!-- ++++++++++++++++++++++++++++++++++++++++++++++ --> 
   <section id="diff">
   <title>DIFF</title>
   <p>2 つのバッグをタプル単位で比較し、片方にだけ存在するタプルをバッグに詰めて戻します。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>DIFF (expression, expression)</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>任意の型の式。</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>用法</title>
   <p>DIFF 関数はバッグの引数を 2 つ取り、それぞれを比較します。片方のバッグにだけ存在し、もう片方には存在しないタプルを、バッグに詰めて戻します。もし 2 つのバッグが一致したら、空のバッグを戻します。引数がバッグでない場合は、両引数それぞれをタプルに詰めた上で比較し、一致しなければ両タプルを詰めたバッグを、一致すれば空のバッグを戻します。現在の実装は、 2 つのバッグが同時にメモリに載せられることを前提としています。メモリに載らない場合でも DIFF 関数は機能しますが、非常に遅くなります。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、 DIFF 関数で 2 つのバッグ中のタプルを比較しています</p>
<source>
A = LOAD 'bag_data' AS (B1:bag{T1:tuple(t1:int,t2:int)},B2:bag{T2:tuple(f1:int,f2:int)});

DUMP A;
({(8,9),(0,1)},{(8,9),(1,1)})
({(2,3),(4,5)},{(2,3),(4,5)})
({(6,7),(3,7)},{(2,2),(3,7)})

DESCRIBE A;
a: {B1: {T1: (t1: int,t2: int)},B2: {T2: (f1: int,f2: int)}}

X = FOREACH A GENERATE DIFF(B1,B2);

grunt> dump x;
({(0,1),(1,1)})
({})
({(6,7),(2,2)})
</source>
   </section></section>


  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->   
<section id="isempty">
   <title>IsEmpty</title>
   <p>バッグもしくはマップが空かどうかチェックします。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>IsEmpty(expression)</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>任意の型の式。</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>IsEmpty 関数はバッグもしくはマップが空か、つまりデータを持っていないかどうかをチェックします。不要なレコードを除去するために使えます。</p></section>
   
   <section>
   <title>例</title>
   <p>次の例では、社会保障番号 (SSN) があるが名前がない学生を計算しています。</p>
<source>
SSN = load 'ssn.txt' using PigStorage() as (ssn:long);

SSN_NAME = load 'students.txt' using PigStorage() as (ssn:long, name:chararray);

/* SSN と SSN_NAME を左外部結合します。 */
X = JOIN SSN by ssn LEFT OUTER, SSN_NAME by ssn;

/* 名前がない学生の社会保障番号だけを残します。 */
Y = filter X by IsEmpty(SSN_NAME);
</source>
   </section></section>    
   

  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->   
   <section id="max">
   <title>MAX</title>
   <p>一要素のバッグから、数値あるいは文字列の最大値を求めます。データセット全体の最大値を得るためには事前に GROUP ALL 文が必要です。グループごとの最大値を得るためには事前に GROUP BY 文が必要です。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>MAX(expression)        </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>int, long, float, double, chararray のいずれかを要素とするバッグ型の式。</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>MAX 関数は一要素のバッグから数値か文字列の最大値を得ます。</p></section>
   
   <section>
   <title>例</title>
   <p>次の例では、それぞれの学生について、全学期中最大の GPA を計算しています (関係 B のフィールド名については、 <a href="basic.html#GROUP">GROUP</a> を参照してください) 。</p>
<source>
A = LOAD 'student' AS (name:chararray, session:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

X = FOREACH B GENERATE group, MAX(A.gpa);

DUMP X;
(John,4.0F)
(Mary,4.0F)
</source>
   </section>
   
   <section>
   <title>型テーブル</title>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>MAX </p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>double にキャストされる</p>
            </td>
         </tr> 
   </table>
   </section></section>
 
 
   <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->  
   <section id="min">
   <title>MIN</title>
   <p>一要素のバッグから、数値あるいは文字列の最小値を求めます。データセット全体の最小値を得るためには事前に GROUP ALL 文が必要です。グループごとの最小値を得るためには事前に GROUP BY 文が必要です。</p>
   <p></p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>MIN(expression)</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>int, long, float, double, chararray のいずれかを要素とするバッグ型の式。</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   
   <title>用法</title>
   <p>MAX 関数は一要素のバッグから数値か文字列の最小値を得ます。</p></section>
   
   <section>
   <title>例</title>
   <p>次の例では、それぞれの学生について、全学期中最小の GPA を計算しています (関係 B のフィールド名については、 <a href="basic.html#GROUP">GROUP</a> を参照してください) 。</p>
<source>
A = LOAD 'student' AS (name:chararray, session:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

X = FOREACH B GENERATE group, MIN(A.gpa);

DUMP X;
(John,3.7F)
(Mary,3.8F)
</source>
   </section>
   
   <section>
   <title>型テーブル</title>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>MIN </p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>double にキャストされる</p>
            </td>
         </tr> 
   </table>
   </section></section>
   
   
     <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="size">
   <title>SIZE</title>
   <p>データ型に応じて要素数を数えます。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>SIZE(expression)</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>任意の型の式。</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>SIZE 関数はデータ型に応じて要素数を数えます (詳しくは下記の型テーブルを見てください) 。 SIZE 関数は null を数に含めます。 SIZE は代数的関数ではありません。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、最初の列の文字数を数えています。</p>
<source>
A = LOAD 'data' as (f1:chararray, f2:chararray, f3:chararray);
(apache,open,source)
(hadoop,map,reduce)
(pig,pig,latin)

X = FOREACH A GENERATE SIZE(f1);

DUMP X;
(6L)
(6L)
(3L)
</source>
   </section>
   
   <section>
   <title>型テーブル</title>
   <table>
       <tr>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>1 を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>1 を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>1 を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>1 を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>配列中の文字の数を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p>配列中のバイト数を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>tuple </p>
            </td>
            <td>
               <p>タプル中のフィールド数を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bag </p>
            </td>
            <td>
               <p>バッグ中のタプル数を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>map </p>
            </td>
            <td>
               <p>マップ中のキー・値のペア数を戻します</p>
            </td>
         </tr> 
   </table></section></section>


  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->   
   <section id="sum">
   <title>SUM</title>
   <p>一列のバッグ中の数値の合計を計算します。データセット全体で合計を計算するには事前に GROUP ALL 文が必要です。グループごとに合計を計算するには事前に GROUP BY 文が必要です。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>SUM(expression)        </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>int, long, float, double, bytearray (double 型にキャストされる) いずれかの型の式。</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>SUM 関数は一列のバッグ中の数値の合計を計算します。</p></section>
   
   <section>
   <title>例</title>
   <p>次の例では、ペットの数を数えています (関係 B のフィールド名については <a href="basic.html#GROUP">GROUP 演算子</a> を参照してください) 。</p>
<source>
A = LOAD 'data' AS (owner:chararray, pet_type:chararray, pet_num:int);

DUMP A;
(Alice,turtle,1)
(Alice,goldfish,5)
(Alice,cat,2)
(Bob,dog,2)
(Bob,cat,2) 

B = GROUP A BY owner;

DUMP B;
(Alice,{(Alice,turtle,1),(Alice,goldfish,5),(Alice,cat,2)})
(Bob,{(Bob,dog,2),(Bob,cat,2)})

X = FOREACH B GENERATE group, SUM(A.pet_num);
DUMP X;
(Alice,8L)
(Bob,4L)
</source>
   </section>
   
   <section>
   <title>型テーブル</title>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>SUM </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>double 型にキャストされる</p>
            </td>
         </tr> 
   </table>
   </section></section>
   
     <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="tokenize">
   <title>TOKENIZE</title>
   <p>文字列を単語のバッグに分割します。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>TOKENIZE(expression [, 'field_delimiter'])        </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>chararray 型の式。</p>
            </td>
         </tr> 
          <tr>
            <td>
               <p>'field_delimiter'</p>
            </td>
            <td>
               <p>単一引用符で括った区切り文字 (省略可能) 。</p>
               <p>区切り文字を省略するか、 null を渡した場合は、次の文字が区切り文字とみなされます: 空白文字「 」、二重引用符「"」、コンマ「,」、丸括弧「()」、アスタリスク「*」。</p>
            </td>
         </tr>
   </table></section>
   
   <section>
   <title>用法</title>
   <p>TOKENIZE 関数は複数の単語からなる文字列 (すべての単語が一列に属する) を、単語のバッグ (各単語がそれぞれひとつのタプルに属する) に分割するために使います。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、それぞれの行の文字列を分割しています。</p>
<source>
A  = LOAD 'data' AS (f1:chararray);

DUMP A;
(Here is the first string.)
(Here is the second string.)
(Here is the third string.)

X = FOREACH A GENERATE TOKENIZE(f1);

DUMP X;
({(Here),(is),(the),(first),(string.)})
({(Here),(is),(the),(second),(string.)})
({(Here),(is),(the),(third),(string.)})
</source>
   <p>次の例では、区切り文字を指定しています。</p>
<source>
{code}
A = LOAD 'data' AS (f1:chararray);
B = FOREACH A TOKENIZE (f1,'||');
DUMP B;
{code} 
</source>
   </section></section></section>
   
   <!-- ======================================================================== -->
   <section id="load-store-functions">
   <title>ロード・ストア関数</title>
   <p>ロード・ストア関数は Pig にデータを入力する方法と、 Pig からデータを出力する方法を決定します。後述するように、 Pig は組み込みのロード・ストア関数をいくつか提供しています。また、独自のロード・ストア関数を作ることもできます (詳細は <a href="udf.html">ユーザ定義関数</a> を見てください) 。</p>
   
  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="handling-compression">
   <title>圧縮</title>

<p>圧縮がサポートされるか否かはロード・ストア関数ごとに異なります。 PigStorage と TextLoader は読み (ロード) 書き (ストア) ともに gzip 圧縮と bzip 圧縮をサポートします。 BinStorage は圧縮をサポートしません。</p>

<p>gzip 圧縮のファイルを扱うには、入力、出力ともにファイルの拡張子が .gz である必要があります。 gzip 圧縮されたファイルは複数の Map 処理に分割できません。これは、入力ファイル数と同じだけの Map 処理が起動されることを意味します。</p>

<source>
A = load ‘myinput.gz’;
store A into ‘myoutput.gz’; 
</source>

<p>bzip 圧縮のファイルを扱うには、入力、出力ともにファイルの拡張子が .bz か .bz2 である必要があります。 bzip 圧縮はブロック志向なので、 bzip 圧縮されたファイルは複数の Map 処理に分割できます。</p>

<source>
A = load ‘myinput.bz’;
store A into ‘myoutput.bz’; 
</source>

<p>注意: PigStorage と TextLoader が圧縮ファイルを正しく読めるのは、<em>ファイルが次のように連結されたのでない限りにおいて</em>です:</p>
  <ul>
      <li>
         <p>cat *.gz > text/concat.gz</p>
      </li>
      <li>
         <p>cat *.bz > text/concat.bz </p>
      </li>
      <li>
         <p>cat *.bz2 > text/concat.bz2</p>
      </li>
   </ul>
<p></p>
<p>gzip ファイルや bzip ファイルをこのように連結して Pig ジョブの入力とした場合、処理が失敗するのではなく、<em>誤った結果</em>が得られます。</p>

</section>

  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="binstorage">
   <title>BinStorage</title>
   <p>データを機械可読の形式で読み書きします。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>BinStorage()        </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>なし</p>
            </td>
            <td>
               <p>パラメータは無し</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>

   <p>Pig は複数の MapReduce ジョブ間で一時データを受け渡すために BinStorage を使っています。</p>
   <ul>
   <li>BinStorage 関数は機械可読の形式で格納されたデータを扱います。 BinStorage は<a href="#handling-compression">圧縮</a>をサポートしません。</li>
   <li>BinStorage は入力元の複数指定 (ファイル、ディレクトリ、グロブ) をサポートします。</li>
   </ul>
   <p>まれに、ユーザが自分のデータを BinStorage を使って保存することはありますが、 BinStorage は専用のバイナリ書式なので、元々のデータが BinStorage であることはありません。 BinStorage のデータは常に、他のデータの処理結果であるはずです。</p>
<p>あるユーザが次のようにしている例がありました:</p>

<source>
a = load 'b.txt' as (id, f);
b = group a by id;
store b into 'g' using BinStorage();
</source>

<p>その後、次のような処理を実行していました:</p>

<source>
a = load 'g/part*' using BinStorage() as (id, d:bag{t:(v, s)});
b = foreach a generate (double)id, flatten(d);
dump b;
</source>

<p>この処理の流れには問題があります。最初のスクリプトはデータ型を定義していないので、データは 1 つの bytearray と、 2 つの bytearray からなるタプルを含むバッグとして保存されます。二番目のスクリプトは bytearray を double にキャストしています。しかし、別のローダがデータを読み出しているため、 bytearray の形式が分からず、別の型へのキャスト方法も分かりません。この問題を解決するために、 Pig では:</p>

<ul>
<li>二番目のスクリプトの実行時に "ERROR 1118: Cannot cast bytes loaded from BinStorage. Please provide a custom converter." というエラーメッセージを表示します。</li>
<li id="custom-converter">あるいは、自作の変換器でキャストを実行することもできます。<br></br>
<source>
a = load 'g/part*' using BinStorage('Utf8StorageConverter') as (id, d:bag{t:(v, s)});
b = foreach a generate (double)id, flatten(d);
dump b;
</source>
</li>
</ul>
</section>
   
   <section>
   <title>例</title>
   <p>次の例では、 BinStorage をロード・ストア関数として使っています。</p>
<source>
A = LOAD 'data' USING BinStorage();

STORE X into 'output' USING BinStorage(); 
</source>

   <p>次の例では、複数の入力元を指定して BinStorage を使っています。</p>
<source>
A = LOAD 'input1.bin, input2.bin' USING BinStorage();
</source>

<p>BinStorage はデータの来歴を追跡しません。それでも  Pig が MapReduce ジョブ間で BinStorage を使う場合には、 Pig はどのキャスト関数を適用するべきかを把握していられます。しかし、次の例のように、ユーザが BinStorage を使ってデータを保存し、別の Pig Latin スクリプトでデータを読み出す時には、型情報が失われます。この場合、 BinStorage でデータを保存する前に、ユーザの責任で正しくデータをキャストする必要があります。
 </p>

<source>
raw = load 'sampledata' using BinStorage() as (col1,col2, col3);
-- null の列を持つ行を消す
A = filter raw by col1#'bcookie' is not null;

B = foreach A generate col1#'bcookie'  as reqcolumn;
describe B;
--B: {regcolumn: bytearray}
X = limit B 5;
dump X;
(36co9b55onr8s)
(36co9b55onr8s)
(36hilul5oo1q1)
(36hilul5oo1q1)
(36l4cj15ooa8a)

B = foreach A generate (chararray)col1#'bcookie'  as convertedcol;
describe B;
--B: {convertedcol: chararray}
X = limit B 5;
dump X; 
()
()
()
()
()
</source>
</section>
</section>
 
 
     <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="jsonloadstore">
   <title>JsonLoader, JsonStorage</title>
   <p>JSON のデータを読み込みまたは書き込みます。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>JsonLoader( [‘schema’] ) </p>
            </td>
        </tr> 
        <tr>
            <td>
               <p>JsonStorage( ) </p>
            </td>
        </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>schema</p>
            </td>
            <td>
               <p>単一引用符で括った Pig のスキーマ (省略可能)</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>JsonLoader は JSON データを読み込むために使います。</p>
   
    <p>JsonStorage は JSON データを書き込むために使います。</p>
   
   <p>JsonLoader と JsonStorage に区切り文字はありません。データは標準的な JSON 形式でエンコードされます。 JsonLoader は引数としてスキーマを取ることもできます。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、スキーマを指定してデータを読み込んでいます。</p>
<source>
a = load 'a.json' using JsonLoader('a0:int,a1:{(a10:int,a11:chararray)},a2:(a20:double,a21:bytearray),a3:[chararray]');  
</source>

   <p>次の例では、スキーマを指定せずにデータを読み込んでいます。 JsonStorage が生成した .pig_schema というファイルが入力ディレクトリに存在する場合、このようにすることが可能です。</p>
<source>
a = load 'a.json' using JsonLoader(); 
</source>
   </section></section>
    
 
 
 

   
     <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="pigdump">
   <title>PigDump</title>
   <p>データを UTF-8 形式で保存します。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>PigDump()        </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>なし</p>
            </td>
            <td>
               <p>パラメータは無し</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>PigDump はデータを人間が読める UTF-8 形式で保存します。</p></section>
   
   <section>
   <title>例</title>
   <p>次の例では、 PigDump をストア関数として使っています。</p>
<source>
STORE X INTO 'output' USING PigDump();
</source>
   </section></section>
   
   
      <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->  
   <section id="pigstorage">
   <title>PigStorage</title>
   <p>データを構造化されたテキストファイルとして読み込みまたは書き込みます。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>PigStorage( [field_delimiter] , ['options'] ) </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p id="field-delimiter">field_delimiter</p>
            </td>
            <td>
               <p>デフォルトの区切りはタブ文字 ('\t') です。</p>
               <p>その他の区切り文字を使う際は単一引用符に括って指定します。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p id="pigstorage-options">'options'</p>
            </td>
            <td>
               <p>オプションをスペース区切りで指定します (‘optionA  optionB  optionC’)</p>
               <p>現在サポートされているオプションは次の通り:</p>
               <ul>
					<li>(‘schema’) - 関係のスキーマを JSON の隠しファイルとして保存します。</li>
					<li>(‘noschema’) - ロード時にスキーマファイルを無視します。</li>
                                        <li>('tagsource') - 入力ファイル名をレコードの最初の列として追加します。</li>
				</ul>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>PigStorage は Pig のデフォルトのロード・ストア関数です。 PigStorage は人間が読める UTF-8 形式の構造化されたテキストファイルをサポートします。圧縮、非圧縮いずれも可能です (詳細は <a href="#handling-compression">圧縮</a> を見てください) 。 Pig の<a href="basic.html#data-types">データ型</a> は、単純型、複合型ともすべて読み書きできます。ロード時の入力データはファイル、ディレクトリ、グロブのいずれかで指定します。</p>

 <p><strong>LOAD 文、 STORE 文</strong></p> 
  <p>LOAD 文 - PigStorage はタブ ('\t') かその他指定されたフィールド区切り文字で書式化されたデータを読み込みます。</p>

   <p>STORE 文 - PigStorage はPigStorage はタブ ('\t') かその他指定されたフィールド区切り文字と、行区切り文字 ('\n') で書式化されたデータを出力します。</p>

 <p><strong>フィールド区切り・レコード区切り</strong></p> 
   <p>フィールド区切り - LOAD 文、 STORE 文とも、デフォルトのフィールド区切りはタブ文字 ('\t') です。他の文字をフィールド区切りとして使う場合は、たとえば ^A または Ctrl-A であれば、 UTF-16 エンコーディングの Unicode (\u0001) で指定します (詳しくはWikipediaの <a href="http://ja.wikipedia.org/wiki/ASCII">ASCII</a>, <a href="http://ja.wikipedia.org/wiki/Unicode">Unicode</a>, and <a href="http://ja.wikipedia.org/wiki/UTF-16">UTF-16</a> を参照してください) 。</p>
   
   <p>レコード区切り - LOAD 文では Pig は LF ('\n'), CR ('\r' または Ctrl-M), または CR + LF ('\r\n') をレコード区切りとして扱います (これらの文字をフィールド区切りとして用いてはいけません) 。 STORE 文では LF ('\n') をレコード区切りとして使います。</p>
   
<p><strong>スキーマ</strong></p>    
   
<p>schema オプションを指定すると、データの保存時に ".pig_schema" という隠しファイルが出力ディレクトリに作成されます。このファイルは PigStorage によるロード時に (schema オプションが指定されるか否かにかかわらず) 使用されます。これによって、ユーザが AS 節で明示的にスキーマを指定することなしに、フィールド名と型が決定できます。ただし、 <code>noschema</code> オプションが指定された場合には、 ".pig_schema" ファイルは無視されます。複数の矛盾するスキーマファイルが存在する場合には、それらをマージすることはなく、単純に最初に見つかったスキーマファイルが使われます。</p>

<p>加えて、 schema オプションが指定された場合には、出力ディレクトリに ".pig_headers" ファイルも作成されます。このファイルは単純に列の別名を羅列したものです。これによって、ヘッダ行を扱うツール向けにデータをエクスポートするのが簡単になります (単純にヘッダ行をデータに追加すればよいのです) 。</p>

<p>schema オプションが指定されなかった場合には、データ保存時にスキーマは書き出されません。</p>

<p>noschema オプションが指定されなかった時にスキーマファイルが見つかった場合、スキーマファイルはロードに利用されます。</p>

<p>スキーマファイルを使うか否かにかかわらず、常に正しい区切り文字を指定する必要があることに注意してください。区切り文字を "#" としてデータを保存した後に、デフォルトの区切り文字でデータを読み込んだら、データは正しく解釈されません。</p>   

<p><strong>レコードの起源</strong></p>
<p>tagsource オプションが指定された場合には、 PigStorage はレコードの最初に INPUT_FILE_NAME 擬似列を追加します。名前が示すとおり、この列にはレコードの読み込み元のファイル名が格納されます。</p>
   
  <p><strong>複合データ型</strong></p>   
  <p>複合型の書式は次の通りです:</p>
 <ul>
		<li><a href="basic.html#tuple">タプル</a>: () で括られ、要素間は "," で区切られます
		<ul>
			<li>空でないタプル: (item1,item2,item3)</li>
		    <li>空のタプル: ()</li>
		</ul>
		</li>
		<li><a href="basic.html#bag">バッグ</a>: {} で括られ、タプルは "," で区切られます
		<ul>
			<li>空でないバッグ: {code}{(tuple1),(tuple2),(tuple3)}{code}</li>
		    <li>空のバッグ: {}</li>
		</ul>		
		</li>
		<li><a href="basic.html#map">マップ</a>: [] で括られ、要素間は "," で区切られ、キーと値は "#" で区切られます
		<ul>
			<li>空でないマップ: [key1#value1,key2#value2]</li>
		    <li>空のマップ: []</li>
		</ul>		
		</li>
</ul>
   <p>LOAD 文でスキーマを指定していた場合、 Pig はスキーマに従って複合データ型を変換します。変換が失敗した場合には、その項目は null になります (詳細は <a href="basic.html#nulls">Pig Latin における null</a> を見てください) 。</p>
   

   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、 PigStorage を使って、 input.txt を、フィールドがタブ区切り、レコードが改行区切りのデータとして読み込んでいます。 2 つの行は同じ意味になります。</p>
<source>
A = LOAD 'student' USING PigStorage('\t') AS (name: chararray, age:int, gpa: float); 

A = LOAD 'student' AS (name: chararray, age:int, gpa: float);
</source>
   
   <p>次の例では、 PigStorage を使って、 X の内容をアスタリスク ( * ) 区切りのファイル群として保存しています。この STORE 文では、 output という名前のディレクトリの下に、 part-nnnnn (たとえば part-00000) という名前でファイルが保存されます。</p>
<source>
STORE X INTO  'output' USING PigStorage('*');
</source>

<p>次の例では、 PigStorage を使って、複合型のデータ (マップと double からなるバッグ) を読み込んでいます。</p>
<source>
a = load '1.txt' as (a0:{t:(m:map[int],d:double)});

{([foo#1,bar#2],34.0),([white#3,yellow#4],45.0)} : 正しいデータ
{([foo#badint],baddouble)} : badint と baddouble で変換が失敗し、結局 {([foo#],)} として読み込まれます
{} : 正しい空のバッグ
</source>
</section>
</section>
   
   
  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="textloader">
   <title>TextLoader</title>
   <p>UTF-8 形式の構造化されていないデータを読み込みます。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>TextLoader()</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>なし</p>
            </td>
            <td>
               <p>パラメータは無し</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>TextLoader は UTF-8 形式の構造化されていないファイルに使います。読み込まれたそれぞれのタプルは、読み込んだ文字列の 1 行を 1 つのフィールドとして持ちます。 TextLoader は<a href="#handling-compression">圧縮</a>をサポートします。</p>
   <p>現在のところ、 TextLoader における圧縮には制限があります。</p>  
   <p>TextLoader をデータの保存に使うことはできません。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、 LOAD 時に TextLoader を使っています。</p>
<source>
A = LOAD 'data' USING TextLoader();
</source>
   </section></section></section>
   

<!-- ======================================================== -->  
<!-- ======================================================== -->  
<!-- Math Functions -->
<section id="math-functions">
<title>数学関数</title>

<p>数学関数に関する一般的な情報については、<a href="http://docs.oracle.com/javase/jp/6/api/">Java API 仕様</a>、および <a href="http://docs.oracle.com/javase/jp/6/api/java/lang/Math.html">Math クラス</a>を見てください。ただし、下記の点に注意してください:</p>

<ul>
		<li>
<p>Pig の関数名はすべて大文字です。大文字・小文字は区別されます。</p>
	</li>
	<li>
<p>いくつかの場合に Pig は Java API 仕様の記述とは異なった形で結果を戻します:</p>
<ul>
	<li>
<p>結果が null か空だった場合、 Pig は null を戻します。</p>
	</li>
		<li>
<p>結果が NaN だった場合、 Pig は null を戻します。</p>
	</li>
		<li>
<p>Pig は引数を処理出来なかった場合に例外を発生します。</p>
	</li>
</ul> 
	</li>
</ul> 
 
 
   <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
<section id="abs">
   <title>ABS</title>
   <p>引数の絶対値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>ABS(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>int, long, float, double のいずれかの型の式。</p>
            </td>
         </tr>
          
   </table></section>
   
<section>
     <title>用法</title>
     <p>ABS 関数は絶対値を求めるために使います。引数が非負の値 (x &#8805; 0) である時は、引数の値をそのまま戻します。引数が負の値 (x &lt; 0) である時は、反数を戻します。</p>

</section>
   
</section>

  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
    
<section id="acos">
   <title>ACOS</title>
   <p>引数のアークコサイン (逆余弦) の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>ACOS(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>ACOS 関数はアークコサイン (逆余弦) の値を求めるために使います。</p>
   </section>
   
</section>    
   
  <!-- ======================================================== -->     
    <section id="asin">
   <title>ASIN</title>
   <p>引数のアークサイン (逆正弦) の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>ASIN(expression)</p>
            </td>
         </tr>
        
   </table>
 </section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>ASIN 関数は引数のアークサイン (逆正弦) の値を求めるために使います。</p>
   </section>
</section>
   
  <!-- ======================================================== -->  
  
 <section id="atan">
   <title>ATAN</title>
   <p>引数のアークタンジェント (逆正接) の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>ATAN(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>ATAN 関数はアークタンジェント (逆正接) の値を求めるために使います。</p>
   </section>
   
</section>  

  <!-- ======================================================== -->  
  
 <section id="cbrt">
   <title>CBRT</title>
   <p>引数の立方根の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>CBRT(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>CBRT 関数は立方根の値を求めるために使います。</p>
   </section>

</section>  

 <!-- ======================================================== -->  
  
 <section id="ceil">
   <title>CEIL</title>
   <p>引数の値を整数に切り上げた値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>CEIL(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>CEIL 関数は数値を整数に切り上げるために使います。この関数が数値を小さくすることはありません。</p>
        <table>
       <tr>
            <td>
               <p>x</p>
            </td>
            <td>
               <p>CEIL(x)</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p> 4.6</p>
            </td>
            <td>
               <p> 5</p>
            </td>
         </tr>
        
        <tr>
            <td>
               <p> 3.5</p>
            </td>
            <td>
               <p> 4</p>
            </td>
         </tr>
        
         <tr>
            <td>
               <p> 2.4</p>
            </td>
            <td>
               <p> 3</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p>1.0</p>
            </td>
            <td>
               <p>1</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p>-1.0</p>
            </td>
            <td>
               <p>-1</p>
            </td>
         </tr>
        
                <tr>
            <td>
               <p>-2.4</p>
            </td>
            <td>
               <p>-2</p>
            </td>
         </tr>
        
         <tr>
            <td>
               <p>-3.5</p>
            </td>
            <td>
               <p>-3</p>
            </td>
         </tr>
        
                <tr>
            <td>
               <p>-4.6</p>
            </td>
            <td>
               <p>-4</p>
            </td>
         </tr>
        
   </table>

   </section>
</section>    

  <!-- ======================================================== -->  
  
 <section id="cos">
   <title>COS</title>
   <p>引数のコサイン (余弦) の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>COS(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>角度を表す double 型の値。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>COS 関数はコサインの値を求めるために使います。</p>
   </section>
   
</section>    
  
<!-- ======================================================== -->  
  
 <section id="cosh">
   <title>COSH</title>
   <p>引数のハイパボリックコサインの値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>COSH(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の値。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>COSH 関数はハイパボリックコサインの値を求めるために使います。</p>
   </section>
</section>    
  


<!-- ======================================================== -->  
  
 <section id="exp">
   <title>EXP</title>
   <p>オイラー数の x 乗の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>EXP(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の値。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>EXP 関数は、引数 x に対して、オイラー数 e を x 乗した値を求めるために使います。</p>
   </section>
</section>    
  
<!-- ======================================================== -->  
  
 <section id="floor">
   <title>FLOOR</title>
   <p>引数の値を整数に切り下げた値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>FLOOR(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>FLOOR 関数は数値を整数に切り下げるために使います。この関数が数値を大きくすることはありません。</p>
     
     
        <table>
       <tr>
            <td>
               <p>x</p>
            </td>
            <td>
               <p>CEIL(x)</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p> 4.6</p>
            </td>
            <td>
               <p> 4</p>
            </td>
         </tr>
        
        <tr>
            <td>
               <p> 3.5</p>
            </td>
            <td>
               <p> 3</p>
            </td>
         </tr>
        
         <tr>
            <td>
               <p> 2.4</p>
            </td>
            <td>
               <p> 2</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p>1.0</p>
            </td>
            <td>
               <p>1</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p>-1.0</p>
            </td>
            <td>
               <p>-1</p>
            </td>
         </tr>
        
                <tr>
            <td>
               <p>-2.4</p>
            </td>
            <td>
               <p>-3</p>
            </td>
         </tr>
        
         <tr>
            <td>
               <p>-3.5</p>
            </td>
            <td>
               <p>-4</p>
            </td>
         </tr>
        
                <tr>
            <td>
               <p>-4.6</p>
            </td>
            <td>
               <p>-5</p>
            </td>
         </tr>
        
   </table>
   </section>
</section>      
<!-- ======================================================== -->  
  
 <section id="log">
   <title>LOG</title>
   <p>引数の自然対数 (e を底とする) を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>LOG(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>LOG 関数は引数の自然対数 (e 底とする) を求めるために使います。</p>
   </section>
</section>     
  
  <!-- ======================================================== -->  
  
 <section id="log10">
   <title>LOG10</title>
   <p>引数の 10 を底とする対数を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>LOG10(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>LOG10 関数は 10 を底とする対数を求めるために使います。</p>
   </section>
</section>     

  <!-- ======================================================== -->  
  
 <section id="random">
   <title>RANDOM</title>
   <p>擬似乱数を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>RANDOM( )</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>N/A</p>
            </td>
            <td>
               <p>引数はありません。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>RANDOM 関数は 0.0 以上 1.0 未満の double 型の擬似乱数を求めるために使います。</p>  
   </section>
</section>     
  
<!-- ======================================================== -->  
  
 <section id="round">
   <title>ROUND</title>
   <p>引数の数値を整数に丸めます。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>ROUND(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>float 型か double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>ROUND 関数は数値を整数に丸めるために使います。引数が float の時は結果は int に、引数が double の時は結果は long になります。</p>
        <table>
       <tr>
            <td>
               <p>x</p>
            </td>
            <td>
               <p>ROUND(x)</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p> 4.6</p>
            </td>
            <td>
               <p> 5</p>
            </td>
         </tr>
        
        <tr>
            <td>
               <p> 3.5</p>
            </td>
            <td>
               <p> 4</p>
            </td>
         </tr>
        
         <tr>
            <td>
               <p> 2.4</p>
            </td>
            <td>
               <p> 2</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p>1.0</p>
            </td>
            <td>
               <p>1</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p>-1.0</p>
            </td>
            <td>
               <p>-1</p>
            </td>
         </tr>
        
                <tr>
            <td>
               <p>-2.4</p>
            </td>
            <td>
               <p>-2</p>
            </td>
         </tr>
        
         <tr>
            <td>
               <p>-3.5</p>
            </td>
            <td>
               <p>-3</p>
            </td>
         </tr>
        
                <tr>
            <td>
               <p>-4.6</p>
            </td>
            <td>
               <p>-5</p>
            </td>
         </tr>
        
   </table>
   </section>
</section>       
  
<!-- ======================================================== -->  
 <section id="sin">
   <title>SIN</title>
   <p>引数のサイン (正弦) の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>SIN(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>SIN 関数は引数のサイン (正弦) の値を求めるために使います。</p>
   </section>
</section>       
  
<!-- ======================================================== -->  
 <section id="sinh">
   <title>SINH</title>
   <p>引数のハイパボリックサインの値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>SINH(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>SINH 関数はハイパボリックサインの値を求めるために使います。</p>
   </section>
</section>


<!-- ======================================================== -->  
 <section id="sqrt">
   <title>SQRT</title>
   <p>引数の正の平方根を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>SQRT(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>SQRT 関数は正の平方根を求めるために使います。</p>
   </section>
</section>

<!-- ======================================================== -->  
 <section id="tan">
   <title>TAN</title>
   <p>引数のタンジェント (正接) の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>TAN(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>角度を表す double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>TAN 関数はタンジェント (正接) の値を求めるために使います。</p>
   </section>

</section>

<!-- ======================================================== -->  
 <section id="tanh">
   <title>TANH</title>
   <p>引数のハイパボリックタンジェントの値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>TANH(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>TANH 関数はハイパボリックタンジェントの値を求めるために使います。</p>
   </section>
</section>
</section>
<!-- End Math Functions --> 


<!-- ======================================================== -->
<!-- ======================================================== -->   

<!-- String Functions -->
<section id="string-functions">
<title>文字列関数</title>

<p>文字列関数に関する一般的な情報については、 <a href="http://docs.oracle.com/javase/jp/6/api/">Java API 仕様</a>、および <a href="http://docs.oracle.com/javase/jp/6/api/java/lang/String.html">String クラス</a>を見てください。ただし、下記の点に注意してください:</p>

<ul>
	<li>
<p>Pig の関数名はすべて大文字です。大文字・小文字は区別されます。</p>
	</li>
		<li>
<p>Pig の文字列関数は、関数の適用対象となる文字列を、最初の引数として取ります。</p>
	</li>
		<li>
<p>Pig は Java API 仕様の記述とは異なった形で結果を戻す場合があります。引数のいずれかが null であったり、引数の数が足りなかった場合、 Pig は null を戻します。</p>
	</li>

</ul>
 
   <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
 <section id="indexof">
   <title>INDEXOF</title>
   <p>文字列中で、開始位置から文字を前方に探索した時に、最初に出現する位置のインデックスを戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>INDEXOF(string, 'character', startIndex)</p>
            </td>
         </tr>
   </table>
 </section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>探索対象の文字列。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>'character'</p>
            </td>
            <td>
               <p>単一引用符に括った、探索する文字。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>startIndex</p>
            </td>
            <td>
               <p>探索開始位置の、 0 始まりのインデックス。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>用法</title>
     <p>INDEXOF 関数は文字の最初の出現位置を求めるために使います。指定した開始位置から前方探索します。</p>

</section>
</section> 

<!-- ======================================================== -->  
 <section id="last-index-of">
   <title>LAST_INDEX_OF</title>
   <p>文字列中で、開始位置から文字を後方に探索した時に、最後方で出現する位置のインデックスを戻します。</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>LAST_INDEX_OF(string, 'character', startIndex)</p>
            </td>
         </tr>
   </table>
   </section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>探索対象の文字列。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>'character'</p>
            </td>
            <td>
               <p>単一引用符に括った、探索する文字。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>startIndex</p>
            </td>
            <td>
               <p>探索開始位置の、 0 始まりのインデックス。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>用法</title>
     <p>LAST_INDEX_OF 関数は文字の最後方の出現位置を求めるために使います。指定した開始位置から後方探索します。</p>
</section>
</section> 


<!-- ======================================================== -->  
 <section id="lcfirst">
   <title>LCFIRST</title>
   <p>文字列中の最初の文字を小文字にします。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>LCFIRST(expression)</p>
            </td>
         </tr>
   </table>
 </section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>chararray 型の式。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>用法</title>
     <p>LCFIRST 関数は文字列中の最初の文字を小文字にするために使います。</p>
</section>
</section> 

<!-- ======================================================== -->  
 <section id="lower">
   <title>LOWER</title>
   <p>文字列中のすべての文字を小文字にします。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>LOWER(expression)</p>
            </td>
         </tr>
   </table>
</section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>chararray 型の式。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>用法</title>
     <p>LOWER 関数は文字列中のすべての文字を小文字にするために使います。</p>
</section>
</section> 


<!-- ======================================================== -->
 <section id="regex-extract">
   <title>REGEX_EXTRACT </title>
   <p>正規表現マッチを行い、マッチしたグループをインデックス指定で抜き出します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>REGEX_EXTRACT (string, regex, index)</p>
            </td>
         </tr>
   </table>
 </section>

<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>マッチ対象の文字列。</p>
            </td>
         </tr> 
        <tr>
            <td>
               <p>regex</p>
            </td>
            <td>
               <p>正規表現。</p>
            </td>
         </tr> 
         
                <tr>
            <td>
               <p>index</p>
            </td>
            <td>
               <p>抜き出すグループのインデックス。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>用法</title>
     <p>REGEX_EXTRACT 関数は正規表現マッチを行い、マッチしたグループを 1 始まりのインデックス指定で抜き出します。 Java 標準の正規表現を使います。</p>
     <p>指定したインデックスに対応するグループを文字列として戻します。グループがマッチしなければ、 null を戻します。</p>
 </section>
 
 <section>
     <title>例</title>
     <p>次の例では、文字列 '192.168.1.5' が戻ります。</p>
 <source>
REGEX_EXTRACT('192.168.1.5:8020', '(.*)\:(.*)', 1);
</source>
     
 </section>

</section>

<!-- ======================================================== -->
 <section id="regex-extract-all">
   <title>REGEX_EXTRACT_ALL </title>
   <p>正規表現マッチを行い、マッチしたグループをすべて戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>REGEX_EXTRACT_ALL (string, regex)</p>
            </td>
         </tr>
   </table>
 </section>

<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>マッチ対象の文字列。</p>
            </td>
         </tr> 
         
                <tr>
            <td>
               <p>regex</p>
            </td>
            <td>
               <p>正規表現。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>文法</title>
     <p>REGEX_EXTRACT_ALL 関数は正規表現マッチを行い、マッチしたグループをすべて得るために使います。 Java 標準の正規表現を使います。</p>
     <p>各要素がマッチしたグループからなるタプルを戻します。マッチしなければ、空のタプルが戻ります。</p>
 </section>
 
 <section>
     <title>例</title>
     <p>次の例では、タプル (192.168.1.5,8020) が戻ります。</p>
 <source>
REGEX_EXTRACT_ALL('192.168.1.5:8020', '(.*)\:(.*)');
</source>
     
 </section>

</section>


<!-- ======================================================== -->  
 <section id="replace">
   <title>REPLACE</title>
   <p>既存の部分文字列を新しい文字列に置き換えます。</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>REPLACE(string, 'oldChar', 'newChar');</p>
            </td>
         </tr>  
   </table>
 </section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>置き換え対象の文字列。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>'oldChar'</p>
            </td>
            <td>
               <p>単一引用符に括った、置き換える元の部分文字列。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>'newChar'</p>
            </td>
            <td>
               <p>単一引用符に括った、置き換え先の文字列。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>用法</title>
     <p>REPLACE 関数は既存の部分文字列を新しい文字列で置き換えるために使います。</p>
     <p>例えば、 "open source software" を "open wiki software" に置き換えるためには次のようにします: REPLACE(string,'software','wiki')</p>
</section>
</section> 

<!-- ======================================================== -->  
 <section id="strsplit">
   <title>STRSPLIT</title>
   <p>文字列を正規表現で分割します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>STRSPLIT(string, regex, limit)</p>
            </td>
         </tr> 
        
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>分割対象の文字列。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>regex</p>
            </td>
            <td>
               <p>正規表現。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>Limit</p>
            </td>
            <td>
               <p>分割の最大数。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>用法</title>
     <p>STRSPLIT 関数は文字列を正規表現で分割するために使います。</p>
     <p>たとえば、 "open:source:software" という文字列に対して STRSPLIT(string, ':',2) は、 (open,source:software) を戻します。 STRSPLIT(string, ':',3) は (open,source,software) を戻します。</p>
</section>
</section> 

<!-- ======================================================== -->  
 <section id="substring">
   <title>SUBSTRING</title>
   <p>部分文字列を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>SUBSTRING(string, startIndex, stopIndex)</p>
            </td>
         </tr> 
        
   </table></section>
   
<section>
   <title>定義</title>
   <table>
          <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>部分文字列を切り出す対象の文字列。</p>
            </td>
         </tr> 
       <tr>
            <td>
               <p>startIndex</p>
            </td>
            <td>
               <p>部分文字列の最初の文字のインデックスを表す int 型の式。</p>
               <p>0 始まりのインデックスです。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>stopIndex</p>
            </td>
            <td>
               <p>最後の文字の<em>次の文字</em>のインデックスを表す int 型の式。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>用法</title>
     <p>SUBSTRING 関数は部分文字列を求めるために使います。</p>
          <p>フィールド alpha の内容が文字列 "ABCDEF" の時、 "BCD" を戻すためには次のようにします: SUBSTRING(alpha, 1, 4) 。 1 は部分文字列の最初の文字である "B" のインデックスです。 4 は部分文字列の最後の文字の<em>次の文字</em>である "E" のインデックスです。</p>
</section>
</section> 

<!-- ======================================================== -->  
 <section id="trim">
   <title>TRIM</title>
   <p>先頭および最後尾の空白文字を取り除いた文字列を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>TRIM(expression)</p>
            </td>
         </tr> 
        
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>chararray 型の式。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>文法</title>
     <p>TRIM 関数は、先頭および最後尾の空白文字を取り除くために使います。</p>
</section>
</section> 

<!-- ======================================================== -->  
 <section id="ucfirst">
   <title>UCFIRST</title>
   <p>文字列中の最初の文字を大文字にします。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>UCFIRST(expression)</p>
            </td>
         </tr> 
        
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>chararray 型の式。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>用法</title>
     <p>UCFIRST 関数は文字列中の最初の文字を大文字にするために使います。</p>
</section>
</section>

<!-- ======================================================== -->  
 <section id="upper">
   <title>UPPER</title>
   <p>文字列中のすべての文字を大文字にします。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>UPPER(expression)</p>
            </td>
         </tr> 
        
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>chararray 型の式。</p>
            </td>
         </tr> 
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>UPPER 関数は文字列中のすべての文字を大文字にするために使います。</p>
   </section>
</section>
 
</section>
<!-- End String Functions -->


<!-- ======================================================== -->
<!-- ======================================================== -->
<!-- Other Functions -->
<section id="bag-tuple-functions">
<title>タプル、バッグ、マップ関数</title>

<!-- ======================================================== -->  
 <section id="totuple">
   <title>TOTUPLE</title>
   <p>1 つから複数の要素をタプルにまとめます。</p>


<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>TOTUPLE(expression [, expression ...])</p>
            </td>
         </tr> 
        
   </table>
 </section>

<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>任意の型の式。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>用法</title>
     <p>TOTUPLE 関数は 1 つから複数の要素をタプルにまとめるために使います。</p>
        <p><a href="basic.html#tuple">タプル</a>と<a href="basic.html#type-construction">型構築演算子</a>も参照してください。</p>
 </section>
 
 <section>
     <title>例</title>
     <p>次の例では、フィールド f1, f2, f3 をタプルにまとめています。</p>
 <source>
a = LOAD 'student' AS (f1:chararray, f2:int, f3:float);
DUMP a;

(John,18,4.0)
(Mary,19,3.8)
(Bill,20,3.9)
(Joe,18,3.8)

b = FOREACH a GENERATE TOTUPLE(f1,f2,f3);
DUMP b;

((John,18,4.0))
((Mary,19,3.8))
((Bill,20,3.9))
((Joe,18,3.8))
</source>
 </section>
</section>

<!-- ======================================================== -->
 <section id="tobag">
   <title>TOBAG</title>
   <p>1 つから複数の要素をバッグにまとめます。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>TOBAG(expression [, expression ...])</p>
            </td>
         </tr> 
        
   </table>
 </section>

<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>任意の型の式。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>用法</title>
     <p>TOBAG 関数は 1 つから複数の式をそれぞれタプルに括った上でバッグにまとめます。</p>
     <p><a href="basic.html#bag">バッグ</a>と<a href="basic.html#type-construction">型構築演算子</a>も参照してください。</p>
 </section>
 
 <section>
     <title>例</title>
     <p>次の例では、フィールド f1 と f3 をそれぞれタプルに括って、バッグにまとめています。</p>
 <source>
a = LOAD 'student' AS (f1:chararray, f2:int, f3:float);
DUMP a;

(John,18,4.0)
(Mary,19,3.8)
(Bill,20,3.9)
(Joe,18,3.8)

b = FOREACH a GENERATE TOBAG(f1,f3);
DUMP b;

({(John),(4.0)})
({(Mary),(3.8)})
({(Bill),(3.9)})
({(Joe),(3.8)})
</source>
     
 </section>

</section>


<!-- ======================================================== -->
 <section id="tomap">
   <title>TOMAP</title>
   <p>キー・値のペアの並びをマップにまとめます。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>TOMAP(key-expression, value-expression [, key-expression, value-expression ...])</p>
            </td>
         </tr> 
        
   </table>
 </section>

<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>key-expression</p>
            </td>
            <td>
               <p>chararray 型の式。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>value-expression</p>
            </td>
            <td>
               <p>マップの値としてサポートされている任意の型の式。</p>
            </td>
         </tr>
   </table>
</section>

<section>
     <title>用法</title>
     <p>TOMAP 関数はキー・値のペアの並びをマップにまとめます。下記の点に注意してください:</p>
     <ul>
<li>引数の数は偶数である必要があります。</li>
<li>各要素はマップ型のルールを満たす必要があります:
<ul>
<li>奇数番目の引数はマップのキーになるため、 chararray 型である必要があります。マップのキーとして許されるのは chararray 型だけだからです。</li>
<li>偶数番目の引数はマップの値になるため、マップの値として許される型である必要があります。</li>
</ul>
</li>
     </ul>
 <p><a href="basic.html#map">マップ</a>と<a href="basic.html#type-construction">型構築演算子</a>も参照してください。</p>  
 </section>
 
 <section>
     <title>例</title>
     <p>次の例では、学生の名前 (chararray 型) をキーとし、 GPA (float 型) を値とするマップを作っています。</p>
 <source>
A = load 'students' as (name:chararray, age:int, gpa:float);
B = foreach A generate TOMAP(name, gpa);
store B into ‘results’;

Input (students)
joe smith 20 3.5
amy chen 22 3.2
leo allen 18 2.1

Output (results)
[joe smith#3.5]
[amy chen#3.2]
[leo allen#2.1]
</source>
     
 </section>

</section>



 <!-- ======================================================== -->  
 <section id="topx">
   <title>TOP</title>
   <p>バッグの各タプルを特定の列が大きい方から N 個のタプルを戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>TOP(topN,column,relation)</p>
            </td>
         </tr> 
        
   </table>
 </section>

<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>topN</p>
            </td>
            <td>
               <p>結果として切り出すタプルの個数を表す int 型の式。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>column</p>
            </td>
            <td>
               <p>タプル中の比較する列のインデックス。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>relation</p>
            </td>
            <td>
               <p>比較する列を含むバッグ。</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>用法</title>
     <p>TOP 関数はバッグの各要素について、特定の列の値が大きい方から、最初の引数で指定した個数分のタプルを含むバッグを戻します。タプル同士の比較は、タプル中の単一の列で行われます。列の一は二番目の引数で指定します。この関数は、バッグ中のすべてのタプルについて、比較に使う列が同じ型の値を保持していることを前提としています。</p>
</section>
 
 <section>
     <title>例</title>
     <p>次の例では、出現度数の上位 10 件を戻しています。</p>
 <source>
A = LOAD 'data' as (first: chararray, second: chararray);
B = GROUP A BY (first, second);
C = FOREACH B generate FLATTEN(group), COUNT(A) as count;
D = GROUP C BY first; // first 列のみでグループ化
topResults = FOREACH D {
    result = TOP(10, 2, C); // second 列の値が大きい方から 10 件を取得します
    GENERATE FLATTEN(result);
}
</source>
     
 </section>
</section>
</section>
<!-- End Other Functions -->

  </body>
</document>

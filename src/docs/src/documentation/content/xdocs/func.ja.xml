<?xml version="1.0" encoding="UTF-8"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">

<document>
  <header>
    <title>組み込み関数 (Built In Functions)</title>
  </header>
  <body>
  
<section id="built-in-functions">
<title>導入</title>
<p>
Pig には多くの関数が組み込まれています (集合関数、ロード・ストア関数、数学関数、文字列関数、バッグ関数、タプル関数等) 。組み込み関数と<a href="udf.html">ユーザ定義関数</a> (UDF) の間には大きく二つの違いがあります。まず、 Pig は元々組み込み関数の存在を知っているので、あえて登録する必要はありません。また、使う時に関数名をパッケージ名で修飾する必要もありません。
</p>	
</section>

<!-- ================================================================== -->
<!-- DYNAMIC INVOKERS -->
<section id="dynamic-invokers">
<title>動的呼び出し</title>

<p><a href="udf.html">ユーザ定義関数</a> (UDF) が用意されていない標準 Java ライブラリ関数を使うためには、動的呼び出しが使えます。動的呼び出しを使うと、 Java のリフレクションのコストが毎回掛かることと引き換えに、ラッパ UDF を用意すること無しに Java の関数が呼び出せます。
</p>

<source>
...
DEFINE UrlDecode InvokeForString('java.net.URLDecoder.decode', 'String String'); 
encoded_strings = LOAD 'encoded_strings.txt' as (encoded:chararray); 
decoded_strings = FOREACH encoded_strings GENERATE UrlDecode(encoded, 'UTF-8'); 
...
</source>

<p>今のところ、動的呼び出しは次のような静的メソッドの呼び出しに使えます:</p>
<ul>
<li>引数をひとつも取らないか、 String, int, long, double, float またそれらの配列のみを引数として取るメソッド</li>
<li>String, int, long, double, float のいずれかを戻すメソッド</li>
</ul>
<p>数値型として使えるのはプリミティブ型だけです。 Integer, Double 等のラッパ型は使えません。戻り値の型に応じて、 InvokeForString, InvokeForInt, InvokeForLong, InvokeForDouble, InvokeForFloat のいずれかを使う必要があります。</p>

<p>上記の例のように、 Java のメソッドと Pig の識別子を結びつけるためには、 <a href="basic.html#define">DEFINE</a> 文を使います。 InvokeFor* コンストラクタの最初の引数は目的となるメソッドのフルパスです。 2 つ目の引数は、 Java メソッドの引数の型を空白文字で区切った文字列です。 Java メソッドが引数を取らない場合は、 2 つ目の引数は省略するか、空文字列にします。有効な型名は string, long, float, double, int です。メソッドが引数として配列を取る場合、 Pig における型は 1 要素のタプルのバッグになります。配列型の型名は、単純に string[] のように表します。型名は大文字・小文字を区別しません。</p>

<p>配列型の引数が動的呼び出しで呼び出せることから、 org.apache.commons.math.stat.StatUtils のようなメソッドを使って、データセットをグルーピングした結果を処理させることもできます。これは便利ですが、 <a href="udf.html#algebraic-interface">Algebraic</a> インタフェースや <a href="udf.html#accumulator-interface">Accumulator</a> インタフェースを使って UDF を定義する場合と比べて、 Hadoop に最適化されていないことに注意してください。</p>
</section>
  
<!-- ======================================================== -->  
<!-- EVAL FUNCTIONS -->    
<section id="eval-functions">
<title>集合関数</title>


<!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->  
<section id="avg">
<title>AVG</title>
   <p>一列のバッグ中の数値の平均値を計算します。</p>
   <section>
   <title>文法</title>
   <table> 
      <tr>
            <td>
               <p>AVG(expression)</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>結果がバッグになる任意の式。バッグの要素は int, long, float, double のいずれかである必要があります。</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>用法</title>
   <p>AVG 関数は、一列のバッグ中の数値の平均を計算するために使います。 データセット全体の平均値を計算するためには、事前に GROUP ALL 文が必要です。グループごとの平均を計算するためには、事前に GROUP BY 文が必要です。</p>
   <p>現在、 AVG 関数は null 値を無視します。</p>      
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、学生ごとに GPA (成績評価値) を計算しています。関係 B のフィールド名については、 <a href="basic.html#GROUP">GROUP</a> を参照してください。</p>
<source>
A = LOAD 'student.txt' AS (name:chararray, term:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

C = FOREACH B GENERATE A.name, AVG(A.gpa);

DUMP C;
({(John),(John),(John),(John)},3.850000023841858)
({(Mary),(Mary),(Mary),(Mary)},3.925000011920929)
</source>
   </section>
   
   <section>
   <title>型テーブル</title>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>AVG </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>double 型にキャストされる</p>
            </td>
         </tr> 
   </table>
   </section></section>
   
   <!-- ++++++++++++++++++++++++++++++++++++++++++++++ --> 
   <section id="concat">
   <title>CONCAT</title>
   <p>同じ型の 2 つの式を連結します。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>CONCAT (expression, expression)</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>任意の式。</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>用法</title>
   <p>CONCAT 関数は 2 つの式を連結するために使います。 2 つの式の結果は同じ型である必要があります。</p>
   </section>

   
   <section>
   <title>例</title>
   <p>次の例ではフィールド f2, f3 を連結しています。</p>
<source>
A = LOAD 'data' as (f1:chararray, f2:chararray, f3:chararray);

DUMP A;
(apache,open,source)
(hadoop,map,reduce)
(pig,pig,latin)

X = FOREACH A GENERATE CONCAT(f2,f3);

DUMP X;
(opensource)
(mapreduce)
(piglatin)
</source>
</section>
</section>
  
  
  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->  
   <section id="count">
   <title>COUNT</title>
   <p>バッグ中の要素の数を数えます。</p>
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>COUNT(expression) </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>バッグ型の任意の式。</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>COUNT 関数はバッグ中の要素の数を数えるために使います。データセット全体で要素の数を数えるには事前に GROUP ALL 文が必要です。グループごとに要素の数を数えるには事前に GROUP BY 文が必要です。</p>

   <p>COUNT 関数は follows syntax semantics, null を無視します。つまり、タプルの最初のフィールドが null である場合、そのタプルは数えられません。 null を含めて数えたい場合は、 <a href="#count-star">COUNT_STAR</a> を使います。</p>
   
   <p>注記: COUNT 関数の引数としてタプル指定子 (*) を使うことはできません。つまり、 COUNT(*) は使えません。</p>
   </section>
   
   
   <section>
   <title>例</title>
   <p>次の例では、バッグ中のタプルの数を数えています。関係 B のフィールド名については <a href="basic.html#GROUP">GROUP</a> を参照してください。</p>
<source>
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY f1;

DUMP B;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(7,{(7,2,5)})
(8,{(8,3,4),(8,4,3)})

X = FOREACH B GENERATE COUNT(A);

DUMP X;
(1L)
(2L)
(1L)
(2L)
</source>
   </section>
   
   <section>
   <title>型テーブル</title>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>COUNT </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
         </tr> 
   </table>
   </section></section>
   
     <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
 <section id="count-star">
   <title>COUNT_STAR</title>
   <p>バッグ中の要素の数を数えます。</p>
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>COUNT_STAR(expression)  </p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>バッグ型の任意の式。</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>用法</title>
   <p>COUNT_STAR 関数はバッグ中の要素の数を数えます。データセット全体で要素を数えるには事前に GROUP ALL 文が必要です。グループごとに要素の数を数えるには事前に GROUP BY 文が必要です。</p>
   <p>COUNT_STAR は null 値を含んで要素の数を数えます (<a href="#count">COUNT</a> が null を無視するのと対照的です) 。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では COUNT_STAR 関数でバッグ中のタプルの数を数えています。</p>
<source>
X = FOREACH B GENERATE COUNT_STAR(A);
</source>
   </section>
    </section>
  
    <!-- ++++++++++++++++++++++++++++++++++++++++++++++ --> 
   <section id="diff">
   <title>DIFF</title>
   <p>2 つのバッグをタプル単位で比較し、片方にだけ存在するタプルをバッグに詰めて戻します。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>DIFF (expression, expression)</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>任意の型の式。</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>用法</title>
   <p>DIFF 関数はバッグの引数を 2 つ取り、それぞれを比較します。片方のバッグにだけ存在し、もう片方には存在しないタプルを、バッグに詰めて戻します。もし 2 つのバッグが一致したら、空のバッグを戻します。引数がバッグでない場合は、両引数それぞれをタプルに詰めた上で比較し、一致しなければ両タプルを詰めたバッグを、一致すれば空のバッグを戻します。現在の実装は、 2 つのバッグが同時にメモリに載せられることを前提としています。メモリに載らない場合でも DIFF 関数は機能しますが、非常に遅くなります。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、 DIFF 関数で 2 つのバッグ中のタプルを比較しています</p>
<source>
A = LOAD 'bag_data' AS (B1:bag{T1:tuple(t1:int,t2:int)},B2:bag{T2:tuple(f1:int,f2:int)});

DUMP A;
({(8,9),(0,1)},{(8,9),(1,1)})
({(2,3),(4,5)},{(2,3),(4,5)})
({(6,7),(3,7)},{(2,2),(3,7)})

DESCRIBE A;
a: {B1: {T1: (t1: int,t2: int)},B2: {T2: (f1: int,f2: int)}}

X = FOREACH A GENERATE DIFF(B1,B2);

grunt> dump x;
({(0,1),(1,1)})
({})
({(6,7),(2,2)})
</source>
   </section></section>


  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->   
<section id="isempty">
   <title>IsEmpty</title>
   <p>バッグもしくはマップが空かどうかチェックします。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>IsEmpty(expression)</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>任意の型の式。</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>IsEmpty 関数はバッグもしくはマップが空か、つまりデータを持っていないかどうかをチェックします。不要なレコードを除去するために使えます。</p></section>
   
   <section>
   <title>例</title>
   <p>次の例では、社会保障番号 (SSN) があるが名前がない学生を計算しています。</p>
<source>
SSN = load 'ssn.txt' using PigStorage() as (ssn:long);

SSN_NAME = load 'students.txt' using PigStorage() as (ssn:long, name:chararray);

/* SSN と SSN_NAME を左外部結合します。 */
X = JOIN SSN by ssn LEFT OUTER, SSN_NAME by ssn;

/* 名前がない学生の社会保障番号だけを残します。 */
Y = filter X by IsEmpty(SSN_NAME);
</source>
   </section></section>    
   

  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->   
   <section id="max">
   <title>MAX</title>
   <p>一要素のバッグから、数値あるいは文字列の最大値を求めます。データセット全体の最大値を得るためには事前に GROUP ALL 文が必要です。グループごとの最大値を得るためには事前に GROUP BY 文が必要です。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>MAX(expression)        </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>int, long, float, double, chararray のいずれかを要素とするバッグ型の式。</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>MAX 関数は一要素のバッグから数値か文字列の最大値を得ます。</p></section>
   
   <section>
   <title>例</title>
   <p>次の例では、それぞれの学生について、全学期中最大の GPA を計算しています (関係 B のフィールド名については、 <a href="basic.html#GROUP">GROUP</a> を参照してください) 。</p>
<source>
A = LOAD 'student' AS (name:chararray, session:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

X = FOREACH B GENERATE group, MAX(A.gpa);

DUMP X;
(John,4.0F)
(Mary,4.0F)
</source>
   </section>
   
   <section>
   <title>型テーブル</title>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>MAX </p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>double にキャストされる</p>
            </td>
         </tr> 
   </table>
   </section></section>
 
 
   <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->  
   <section id="min">
   <title>MIN</title>
   <p>一要素のバッグから、数値あるいは文字列の最小値を求めます。データセット全体の最小値を得るためには事前に GROUP ALL 文が必要です。グループごとの最小値を得るためには事前に GROUP BY 文が必要です。</p>
   <p></p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>MIN(expression)</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>int, long, float, double, chararray のいずれかを要素とするバッグ型の式。</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   
   <title>用法</title>
   <p>MAX 関数は一要素のバッグから数値か文字列の最小値を得ます。</p></section>
   
   <section>
   <title>例</title>
   <p>次の例では、それぞれの学生について、全学期中最小の GPA を計算しています (関係 B のフィールド名については、 <a href="basic.html#GROUP">GROUP</a> を参照してください) 。</p>
<source>
A = LOAD 'student' AS (name:chararray, session:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

X = FOREACH B GENERATE group, MIN(A.gpa);

DUMP X;
(John,3.7F)
(Mary,3.8F)
</source>
   </section>
   
   <section>
   <title>型テーブル</title>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>MIN </p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>double にキャストされる</p>
            </td>
         </tr> 
   </table>
   </section></section>
   
   
     <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="size">
   <title>SIZE</title>
   <p>データ型に応じて要素数を数えます。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>SIZE(expression)</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>任意の型の式。</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>SIZE 関数はデータ型に応じて要素数を数えます (詳しくは下記の型テーブルを見てください) 。 SIZE 関数は null を数に含めます。 SIZE は代数的関数ではありません。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、最初の列の文字数を数えています。</p>
<source>
A = LOAD 'data' as (f1:chararray, f2:chararray, f3:chararray);
(apache,open,source)
(hadoop,map,reduce)
(pig,pig,latin)

X = FOREACH A GENERATE SIZE(f1);

DUMP X;
(6L)
(6L)
(3L)
</source>
   </section>
   
   <section>
   <title>型テーブル</title>
   <table>
       <tr>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>1 を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>1 を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>1 を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>1 を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>配列中の文字の数を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bytearray </p>
            </td>
            <td>
               <p>配列中のバイト数を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>tuple </p>
            </td>
            <td>
               <p>タプル中のフィールド数を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>bag </p>
            </td>
            <td>
               <p>バッグ中のタプル数を戻します</p>
            </td>
         </tr>
         <tr>
            <td>
               <p>map </p>
            </td>
            <td>
               <p>マップ中のキー・値のペア数を戻します</p>
            </td>
         </tr> 
   </table></section></section>


  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->   
   <section id="sum">
   <title>SUM</title>
   <p>一列のバッグ中の数値の合計を計算します。データセット全体で合計を計算するには事前に GROUP ALL 文が必要です。グループごとに合計を計算するには事前に GROUP BY 文が必要です。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>SUM(expression)        </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>int, long, float, double, bytearray (double 型にキャストされる) いずれかの型の式。</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>SUM 関数は一列のバッグ中の数値の合計を計算します。</p></section>
   
   <section>
   <title>例</title>
   <p>次の例では、ペットの数を数えています (関係 B のフィールド名については <a href="basic.html#GROUP">GROUP 演算子</a> を参照してください) 。</p>
<source>
A = LOAD 'data' AS (owner:chararray, pet_type:chararray, pet_num:int);

DUMP A;
(Alice,turtle,1)
(Alice,goldfish,5)
(Alice,cat,2)
(Bob,dog,2)
(Bob,cat,2) 

B = GROUP A BY owner;

DUMP B;
(Alice,{(Alice,turtle,1),(Alice,goldfish,5),(Alice,cat,2)})
(Bob,{(Bob,dog,2),(Bob,cat,2)})

X = FOREACH B GENERATE group, SUM(A.pet_num);
DUMP X;
(Alice,8L)
(Bob,4L)
</source>
   </section>
   
   <section>
   <title>型テーブル</title>
   <table>
         <tr>
            <td>
               <p></p>
            </td>
            <td>
               <p>int </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>float </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>chararray </p>
            </td>
            <td>
               <p>bytearray </p>
            </td>
         </tr>
         <tr>
            <td>
               <p>SUM </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>long </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>double </p>
            </td>
            <td>
               <p>エラー</p>
            </td>
            <td>
               <p>double 型にキャストされる</p>
            </td>
         </tr> 
   </table>
   </section></section>
   
     <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="tokenize">
   <title>TOKENIZE</title>
   <p>文字列を単語のバッグに分割します。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>TOKENIZE(expression [, 'field_delimiter'])        </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>chararray 型の式。</p>
            </td>
         </tr> 
          <tr>
            <td>
               <p>'field_delimiter'</p>
            </td>
            <td>
               <p>単一引用符で括った区切り文字 (省略可能) 。</p>
               <p>区切り文字を省略するか、 null を渡した場合は、次の文字が区切り文字とみなされます: 空白文字「 」、二重引用符「"」、コンマ「,」、丸括弧「()」、アスタリスク「*」。</p>
            </td>
         </tr>
   </table></section>
   
   <section>
   <title>用法</title>
   <p>TOKENIZE 関数は複数の単語からなる文字列 (すべての単語が一列に属する) を、単語のバッグ (各単語がそれぞれひとつのタプルに属する) に分割するために使います。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、それぞれの行の文字列を分割しています。</p>
<source>
A  = LOAD 'data' AS (f1:chararray);

DUMP A;
(Here is the first string.)
(Here is the second string.)
(Here is the third string.)

X = FOREACH A GENERATE TOKENIZE(f1);

DUMP X;
({(Here),(is),(the),(first),(string.)})
({(Here),(is),(the),(second),(string.)})
({(Here),(is),(the),(third),(string.)})
</source>
   <p>次の例では、区切り文字を指定しています。</p>
<source>
{code}
A = LOAD 'data' AS (f1:chararray);
B = FOREACH A TOKENIZE (f1,'||');
DUMP B;
{code} 
</source>
   </section></section></section>
   
   <!-- ======================================================================== -->
   <section id="load-store-functions">
   <title>ロード・ストア関数</title>
   <p>ロード・ストア関数は Pig にデータを入力する方法と、 Pig からデータを出力する方法を決定します。後述するように、 Pig は組み込みのロード・ストア関数をいくつか提供しています。また、独自のロード・ストア関数を作ることもできます (詳細は <a href="udf.html">ユーザ定義関数</a> を見てください) 。</p>
   
  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="handling-compression">
   <title>圧縮</title>

<p>圧縮がサポートされるか否かはロード・ストア関数ごとに異なります。 PigStorage と TextLoader は読み (ロード) 書き (ストア) ともに gzip 圧縮と bzip 圧縮をサポートします。 BinStorage は圧縮をサポートしません。</p>

<p>gzip 圧縮のファイルを扱うには、入力、出力ともにファイルの拡張子が .gz である必要があります。 gzip 圧縮されたファイルは複数の Map 処理に分割できません。これは、入力ファイル数と同じだけの Map 処理が起動されることを意味します。</p>

<source>
A = load ‘myinput.gz’;
store A into ‘myoutput.gz’; 
</source>

<p>bzip 圧縮のファイルを扱うには、入力、出力ともにファイルの拡張子が .bz か .bz2 である必要があります。 bzip 圧縮はブロック志向なので、 bzip 圧縮されたファイルは複数の Map 処理に分割できます。</p>

<source>
A = load ‘myinput.bz’;
store A into ‘myoutput.bz’; 
</source>

<p>注意: PigStorage と TextLoader が圧縮ファイルを正しく読めるのは、<em>ファイルが次のように連結されたのでない限りにおいて</em>です:</p>
  <ul>
      <li>
         <p>cat *.gz > text/concat.gz</p>
      </li>
      <li>
         <p>cat *.bz > text/concat.bz </p>
      </li>
      <li>
         <p>cat *.bz2 > text/concat.bz2</p>
      </li>
   </ul>
<p></p>
<p>gzip ファイルや bzip ファイルをこのように連結して Pig ジョブの入力とした場合、処理が失敗するのではなく、<em>誤った結果</em>が得られます。</p>

</section>

  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="binstorage">
   <title>BinStorage</title>
   <p>データを機械可読の形式で読み書きします。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>BinStorage()        </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>なし</p>
            </td>
            <td>
               <p>パラメータは無し</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>

   <p>Pig は複数の MapReduce ジョブ間で一時データを受け渡すために BinStorage を使っています。</p>
   <ul>
   <li>BinStorage 関数は機械可読の形式で格納されたデータを扱います。 BinStorage は<a href="#handling-compression">圧縮</a>をサポートしません。</li>
   <li>BinStorage は入力元の複数指定 (ファイル、ディレクトリ、グロブ) をサポートします。</li>
   </ul>
   <p>まれに、ユーザが自分のデータを BinStorage を使って保存することはありますが、 BinStorage は専用のバイナリ書式なので、元々のデータが BinStorage であることはありません。 BinStorage のデータは常に、他のデータの処理結果であるはずです。</p>
<p>あるユーザが次のようにしている例がありました:</p>

<source>
a = load 'b.txt' as (id, f);
b = group a by id;
store b into 'g' using BinStorage();
</source>

<p>その後、次のような処理を実行していました:</p>

<source>
a = load 'g/part*' using BinStorage() as (id, d:bag{t:(v, s)});
b = foreach a generate (double)id, flatten(d);
dump b;
</source>

<p>この処理の流れには問題があります。最初のスクリプトはデータ型を定義していないので、データは 1 つの bytearray と、 2 つの bytearray からなるタプルを含むバッグとして保存されます。二番目のスクリプトは bytearray を double にキャストしています。しかし、別のローダがデータを読み出しているため、 bytearray の形式が分からず、別の型へのキャスト方法も分かりません。この問題を解決するために、 Pig では:</p>

<ul>
<li>二番目のスクリプトの実行時に "ERROR 1118: Cannot cast bytes loaded from BinStorage. Please provide a custom converter." というエラーメッセージを表示します。</li>
<li id="custom-converter">あるいは、自作の変換器でキャストを実行することもできます。<br></br>
<source>
a = load 'g/part*' using BinStorage('Utf8StorageConverter') as (id, d:bag{t:(v, s)});
b = foreach a generate (double)id, flatten(d);
dump b;
</source>
</li>
</ul>
</section>
   
   <section>
   <title>例</title>
   <p>次の例では、 BinStorage をロード・ストア関数として使っています。</p>
<source>
A = LOAD 'data' USING BinStorage();

STORE X into 'output' USING BinStorage(); 
</source>

   <p>次の例では、複数の入力元を指定して BinStorage を使っています。</p>
<source>
A = LOAD 'input1.bin, input2.bin' USING BinStorage();
</source>

<p>BinStorage はデータの来歴を追跡しません。それでも  Pig が MapReduce ジョブ間で BinStorage を使う場合には、 Pig はどのキャスト関数を適用するべきかを把握していられます。しかし、次の例のように、ユーザが BinStorage を使ってデータを保存し、別の Pig Latin スクリプトでデータを読み出す時には、型情報が失われます。この場合、 BinStorage でデータを保存する前に、ユーザの責任で正しくデータをキャストする必要があります。
 </p>

<source>
raw = load 'sampledata' using BinStorage() as (col1,col2, col3);
-- null の列を持つ行を消す
A = filter raw by col1#'bcookie' is not null;

B = foreach A generate col1#'bcookie'  as reqcolumn;
describe B;
--B: {regcolumn: bytearray}
X = limit B 5;
dump X;
(36co9b55onr8s)
(36co9b55onr8s)
(36hilul5oo1q1)
(36hilul5oo1q1)
(36l4cj15ooa8a)

B = foreach A generate (chararray)col1#'bcookie'  as convertedcol;
describe B;
--B: {convertedcol: chararray}
X = limit B 5;
dump X; 
()
()
()
()
()
</source>
</section>
</section>
 
 
     <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="jsonloadstore">
   <title>JsonLoader, JsonStorage</title>
   <p>JSON のデータを読み込みまたは書き込みます。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>JsonLoader( [‘schema’] ) </p>
            </td>
        </tr> 
        <tr>
            <td>
               <p>JsonStorage( ) </p>
            </td>
        </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>schema</p>
            </td>
            <td>
               <p>単一引用符で括った Pig のスキーマ (省略可能)</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>JsonLoader は JSON データを読み込むために使います。</p>
   
    <p>JsonStorage は JSON データを書き込むために使います。</p>
   
   <p>JsonLoader と JsonStorage に区切り文字はありません。データは標準的な JSON 形式でエンコードされます。 JsonLoader は引数としてスキーマを取ることもできます。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、スキーマを指定してデータを読み込んでいます。</p>
<source>
a = load 'a.json' using JsonLoader('a0:int,a1:{(a10:int,a11:chararray)},a2:(a20:double,a21:bytearray),a3:[chararray]');  
</source>

   <p>次の例では、スキーマを指定せずにデータを読み込んでいます。 JsonStorage が生成した .pig_schema というファイルが入力ディレクトリに存在する場合、このようにすることが可能です。</p>
<source>
a = load 'a.json' using JsonLoader(); 
</source>
   </section></section>
    
 
 
 

   
     <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="pigdump">
   <title>PigDump</title>
   <p>データを UTF-8 形式で保存します。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>PigDump()        </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>なし</p>
            </td>
            <td>
               <p>パラメータは無し</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>PigDump はデータを人間が読める UTF-8 形式で保存します。</p></section>
   
   <section>
   <title>例</title>
   <p>次の例では、 PigDump をストア関数として使っています。</p>
<source>
STORE X INTO 'output' USING PigDump();
</source>
   </section></section>
   
   
      <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->  
   <section id="pigstorage">
   <title>PigStorage</title>
   <p>データを構造化されたテキストファイルとして読み込みまたは書き込みます。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>PigStorage( [field_delimiter] , ['options'] ) </p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p id="field-delimiter">field_delimiter</p>
            </td>
            <td>
               <p>デフォルトの区切りはタブ文字 ('\t') です。</p>
               <p>その他の区切り文字を使う際は単一引用符に括って指定します。</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p id="pigstorage-options">'options'</p>
            </td>
            <td>
               <p>オプションをスペース区切りで指定します (‘optionA  optionB  optionC’)</p>
               <p>現在サポートされているオプションは次の通り:</p>
               <ul>
					<li>(‘schema’) - 関係のスキーマを JSON の隠しファイルとして保存します。</li>
					<li>(‘noschema’) - ロード時にスキーマファイルを無視します。</li>
                                        <li>('tagsource') - 入力ファイル名をレコードの最初の列として追加します。</li>
				</ul>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>PigStorage は Pig のデフォルトのロード・ストア関数です。 PigStorage は人間が読める UTF-8 形式の構造化されたテキストファイルをサポートします。圧縮、非圧縮いずれも可能です (詳細は <a href="#handling-compression">圧縮</a> を見てください) 。 Pig の<a href="basic.html#data-types">データ型</a> は、単純型、複合型ともすべて読み書きできます。ロード時の入力データはファイル、ディレクトリ、グロブのいずれかで指定します。</p>

 <p><strong>LOAD 文、 STORE 文</strong></p> 
  <p>LOAD 文 - PigStorage はタブ ('\t') かその他指定されたフィールド区切り文字で書式化されたデータを読み込みます。</p>

   <p>STORE 文 - PigStorage はPigStorage はタブ ('\t') かその他指定されたフィールド区切り文字と、行区切り文字 ('\n') で書式化されたデータを出力します。</p>

 <p><strong>フィールド区切り・レコード区切り</strong></p> 
   <p>フィールド区切り - LOAD 文、 STORE 文とも、デフォルトのフィールド区切りはタブ文字 ('\t') です。他の文字をフィールド区切りとして使う場合は、たとえば ^A または Ctrl-A であれば、 UTF-16 エンコーディングの Unicode (\u0001) で指定します (詳しくはWikipediaの <a href="http://ja.wikipedia.org/wiki/ASCII">ASCII</a>, <a href="http://ja.wikipedia.org/wiki/Unicode">Unicode</a>, and <a href="http://ja.wikipedia.org/wiki/UTF-16">UTF-16</a> を参照してください) 。</p>
   
   <p>レコード区切り - LOAD 文では Pig は LF ('\n'), CR ('\r' または Ctrl-M), または CR + LF ('\r\n') をレコード区切りとして扱います (これらの文字をフィールド区切りとして用いてはいけません) 。 STORE 文では LF ('\n') をレコード区切りとして使います。</p>
   
<p><strong>スキーマ</strong></p>    
   
<p>schema オプションを指定すると、データの保存時に ".pig_schema" という隠しファイルが出力ディレクトリに作成されます。このファイルは PigStorage によるロード時に (schema オプションが指定されるか否かにかかわらず) 使用されます。これによって、ユーザが AS 節で明示的にスキーマを指定することなしに、フィールド名と型が決定できます。ただし、 <code>noschema</code> オプションが指定された場合には、 ".pig_schema" ファイルは無視されます。複数の矛盾するスキーマファイルが存在する場合には、それらをマージすることはなく、単純に最初に見つかったスキーマファイルが使われます。</p>

<p>加えて、 schema オプションが指定された場合には、出力ディレクトリに ".pig_headers" ファイルも作成されます。このファイルは単純に列の別名を羅列したものです。これによって、ヘッダ行を扱うツール向けにデータをエクスポートするのが簡単になります (単純にヘッダ行をデータに追加すればよいのです) 。</p>

<p>schema オプションが指定されなかった場合には、データ保存時にスキーマは書き出されません。</p>

<p>noschema オプションが指定されなかった時にスキーマファイルが見つかった場合、スキーマファイルはロードに利用されます。</p>

<p>スキーマファイルを使うか否かにかかわらず、常に正しい区切り文字を指定する必要があることに注意してください。区切り文字を "#" としてデータを保存した後に、デフォルトの区切り文字でデータを読み込んだら、データは正しく解釈されません。</p>   

<p><strong>レコードの起源</strong></p>
<p>tagsource オプションが指定された場合には、 PigStorage はレコードの最初に INPUT_FILE_NAME 擬似列を追加します。名前が示すとおり、この列にはレコードの読み込み元のファイル名が格納されます。</p>
   
  <p><strong>複合データ型</strong></p>   
  <p>複合型の書式は次の通りです:</p>
 <ul>
		<li><a href="basic.html#tuple">タプル</a>: () で括られ、要素間は "," で区切られます
		<ul>
			<li>空でないタプル: (item1,item2,item3)</li>
		    <li>空のタプル: ()</li>
		</ul>
		</li>
		<li><a href="basic.html#bag">バッグ</a>: {} で括られ、タプルは "," で区切られます
		<ul>
			<li>空でないバッグ: {code}{(tuple1),(tuple2),(tuple3)}{code}</li>
		    <li>空のバッグ: {}</li>
		</ul>		
		</li>
		<li><a href="basic.html#map">マップ</a>: [] で括られ、要素間は "," で区切られ、キーと値は "#" で区切られます
		<ul>
			<li>空でないマップ: [key1#value1,key2#value2]</li>
		    <li>空のマップ: []</li>
		</ul>		
		</li>
</ul>
   <p>LOAD 文でスキーマを指定していた場合、 Pig はスキーマに従って複合データ型を変換します。変換が失敗した場合には、その項目は null になります (詳細は <a href="basic.html#nulls">Pig Latin における null</a> を見てください) 。</p>
   

   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、 PigStorage を使って、 input.txt を、フィールドがタブ区切り、レコードが改行区切りのデータとして読み込んでいます。 2 つの行は同じ意味になります。</p>
<source>
A = LOAD 'student' USING PigStorage('\t') AS (name: chararray, age:int, gpa: float); 

A = LOAD 'student' AS (name: chararray, age:int, gpa: float);
</source>
   
   <p>次の例では、 PigStorage を使って、 X の内容をアスタリスク ( * ) 区切りのファイル群として保存しています。この STORE 文では、 output という名前のディレクトリの下に、 part-nnnnn (たとえば part-00000) という名前でファイルが保存されます。</p>
<source>
STORE X INTO  'output' USING PigStorage('*');
</source>

<p>次の例では、 PigStorage を使って、複合型のデータ (マップと double からなるバッグ) を読み込んでいます。</p>
<source>
a = load '1.txt' as (a0:{t:(m:map[int],d:double)});

{([foo#1,bar#2],34.0),([white#3,yellow#4],45.0)} : 正しいデータ
{([foo#badint],baddouble)} : badint と baddouble で変換が失敗し、結局 {([foo#],)} として読み込まれます
{} : 正しい空のバッグ
</source>
</section>
</section>
   
   
  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
   <section id="textloader">
   <title>TextLoader</title>
   <p>UTF-8 形式の構造化されていないデータを読み込みます。</p>
   
   <section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>TextLoader()</p>
            </td>
         </tr> 
   </table>
   </section>
   
   <section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>なし</p>
            </td>
            <td>
               <p>パラメータは無し</p>
            </td>
         </tr> 
   </table></section>
   
   <section>
   <title>用法</title>
   <p>TextLoader は UTF-8 形式の構造化されていないファイルに使います。読み込まれたそれぞれのタプルは、読み込んだ文字列の 1 行を 1 つのフィールドとして持ちます。 TextLoader は<a href="#handling-compression">圧縮</a>をサポートします。</p>
   <p>現在のところ、 TextLoader における圧縮には制限があります。</p>  
   <p>TextLoader をデータの保存に使うことはできません。</p>
   </section>
   
   <section>
   <title>例</title>
   <p>次の例では、 LOAD 時に TextLoader を使っています。</p>
<source>
A = LOAD 'data' USING TextLoader();
</source>
   </section></section></section>
   

<!-- ======================================================== -->  
<!-- ======================================================== -->  
<!-- Math Functions -->
<section id="math-functions">
<title>数学関数</title>

<p>数学関数について一般的な情報は 、<a href="http://docs.oracle.com/javase/jp/6/api/">Java API 仕様</a>、および <a href="http://docs.oracle.com/javase/jp/6/api/java/lang/Math.html">Math クラス</a> を見てください。ただし、下記の点に注意してください:</p>

<ul>
		<li>
<p>Pig の関数名はすべて大文字です。大文字・小文字は区別されます。</p>
	</li>
	<li>
<p>いくつかの場合に Pig は Java API 仕様の記述とは異なった形で結果を戻します:</p>
<ul>
	<li>
<p>結果が null か空だった場合、 Pig は null を戻します。</p>
	</li>
		<li>
<p>結果が NaN だった場合、 Pig は null を戻します。</p>
	</li>
		<li>
<p>Pig は引数を処理出来なかった場合に例外を発生します。</p>
	</li>
</ul> 
	</li>
</ul> 
 
 
   <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
<section id="abs">
   <title>ABS</title>
   <p>引数の絶対値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>ABS(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>int, long, float, double のいずれかの型の式。</p>
            </td>
         </tr>
          
   </table></section>
   
<section>
     <title>用法</title>
     <p>ABS 関数は絶対値を求めるために使います。引数が非負の値 (x &#8805; 0) である時は、引数の値をそのまま戻します。引数が負の値 (x &lt; 0) である時は、反数を戻します。</p>

</section>
   
</section>

  <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
    
<section id="acos">
   <title>ACOS</title>
   <p>引数のアークコサイン (逆余弦) の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>ACOS(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>ACOS 関数はアークコサイン (逆余弦) の値を求めるために使います。</p>
   </section>
   
</section>    
   
  <!-- ======================================================== -->     
    <section id="asin">
   <title>ASIN</title>
   <p>引数のアークサイン (逆正弦) の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>ASIN(expression)</p>
            </td>
         </tr>
        
   </table>
 </section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>ASIN 関数は引数のアークサイン (逆正弦) の値を求めるために使います。</p>
   </section>
</section>
   
  <!-- ======================================================== -->  
  
 <section id="atan">
   <title>ATAN</title>
   <p>引数のアークタンジェント (逆正接) の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>ATAN(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>ATAN 関数はアークタンジェント (逆正接) の値を求めるために使います。</p>
   </section>
   
</section>  

  <!-- ======================================================== -->  
  
 <section id="cbrt">
   <title>CBRT</title>
   <p>引数の立方根の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>CBRT(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>CBRT 関数は立方根の値を求めるために使います。</p>
   </section>

</section>  

 <!-- ======================================================== -->  
  
 <section id="ceil">
   <title>CEIL</title>
   <p>引数の値を整数に切り上げた値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>CEIL(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の式。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>CEIL 関数は整数に切り上げるために使います。この関数が数値を小さくすることはありません。</p>
        <table>
       <tr>
            <td>
               <p>x</p>
            </td>
            <td>
               <p>CEIL(x)</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p> 4.6</p>
            </td>
            <td>
               <p> 5</p>
            </td>
         </tr>
        
        <tr>
            <td>
               <p> 3.5</p>
            </td>
            <td>
               <p> 4</p>
            </td>
         </tr>
        
         <tr>
            <td>
               <p> 2.4</p>
            </td>
            <td>
               <p> 3</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p>1.0</p>
            </td>
            <td>
               <p>1</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p>-1.0</p>
            </td>
            <td>
               <p>-1</p>
            </td>
         </tr>
        
                <tr>
            <td>
               <p>-2.4</p>
            </td>
            <td>
               <p>-2</p>
            </td>
         </tr>
        
         <tr>
            <td>
               <p>-3.5</p>
            </td>
            <td>
               <p>-3</p>
            </td>
         </tr>
        
                <tr>
            <td>
               <p>-4.6</p>
            </td>
            <td>
               <p>-4</p>
            </td>
         </tr>
        
   </table>

   </section>
</section>    

  <!-- ======================================================== -->  
  
 <section id="cos">
   <title>COS</title>
   <p>引数のコサイン (余弦) の値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>COS(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>角度を表す double 型の値。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>COS 関数はコサインの値を求めるために使います。</p>
   </section>
   
</section>    
  
<!-- ======================================================== -->  
  
 <section id="cosh">
   <title>COSH</title>
   <p>引数のハイパボリックコサインの値を戻します。</p>

<section>
   <title>文法</title>
   <table>
       <tr>
            <td>
               <p>COSH(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>定義</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>double 型の値。</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>用法</title>
     <p>COSH 関数はハイパボリックコサインの値を求めるために使います。</p>
   </section>
</section>    
  


<!-- ======================================================== -->  
  
 <section id="exp">
   <title>EXP</title>
   <p>Returns Euler's number e raised to the power of x.
</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>EXP(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result is type double.</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>Usage</title>
     <p>
Use the EXP function to return the value of Euler's number e raised to the power of x (where x is the result value of the expression).
     </p>
   </section>
</section>    
  
<!-- ======================================================== -->  
  
 <section id="floor">
   <title>FLOOR</title>
   <p>Returns the value of an expression rounded down to the nearest integer. 
</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>FLOOR(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result is type double.</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>Usage</title>
     <p>
Use the FLOOR function to return the value of an expression rounded down to the nearest integer. 
This function never increases the result value.
     </p>
     
     
        <table>
       <tr>
            <td>
               <p>x</p>
            </td>
            <td>
               <p>CEIL(x)</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p> 4.6</p>
            </td>
            <td>
               <p> 4</p>
            </td>
         </tr>
        
        <tr>
            <td>
               <p> 3.5</p>
            </td>
            <td>
               <p> 3</p>
            </td>
         </tr>
        
         <tr>
            <td>
               <p> 2.4</p>
            </td>
            <td>
               <p> 2</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p>1.0</p>
            </td>
            <td>
               <p>1</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p>-1.0</p>
            </td>
            <td>
               <p>-1</p>
            </td>
         </tr>
        
                <tr>
            <td>
               <p>-2.4</p>
            </td>
            <td>
               <p>-3</p>
            </td>
         </tr>
        
         <tr>
            <td>
               <p>-3.5</p>
            </td>
            <td>
               <p>-4</p>
            </td>
         </tr>
        
                <tr>
            <td>
               <p>-4.6</p>
            </td>
            <td>
               <p>-5</p>
            </td>
         </tr>
        
   </table>
   </section>
</section>      
<!-- ======================================================== -->  
  
 <section id="log">
   <title>LOG</title>
   <p>Returns the natural logarithm (base e) of an expression.</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>LOG(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result is type double.</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>Usage</title>
     <p>
Use the LOG function to return the natural logarithm (base e) of an expression.
     </p>
   </section>
</section>     
  
  <!-- ======================================================== -->  
  
 <section id="log10">
   <title>LOG10</title>
   <p>Returns the base 10 logarithm of an expression.</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>LOG10(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result is type double.</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>Usage</title>
     <p>
Use the LOG10 function to return the base 10 logarithm of an expression.
     </p>
   </section>
</section>     

  <!-- ======================================================== -->  
  
 <section id="random">
   <title>RANDOM</title>
   <p>Returns a pseudo random number.</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>RANDOM( )</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>N/A</p>
            </td>
            <td>
               <p>No terms.</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>Usage</title>
     <p>
Use the RANDOM function to return a pseudo random number (type double) greater than or equal to 0.0 and less than 1.0.
     </p>  
   </section>
</section>     
  
<!-- ======================================================== -->  
  
 <section id="round">
   <title>ROUND</title>
   <p>Returns the value of an expression rounded to an integer.</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>ROUND(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result is type float or double.</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>Usage</title>
     <p>
Use the ROUND function to return the value of an expression rounded to an integer (if the result type is float) or rounded to a long (if the result type is double).
     </p>
        <table>
       <tr>
            <td>
               <p>x</p>
            </td>
            <td>
               <p>CEIL(x)</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p> 4.6</p>
            </td>
            <td>
               <p> 5</p>
            </td>
         </tr>
        
        <tr>
            <td>
               <p> 3.5</p>
            </td>
            <td>
               <p> 4</p>
            </td>
         </tr>
        
         <tr>
            <td>
               <p> 2.4</p>
            </td>
            <td>
               <p> 2</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p>1.0</p>
            </td>
            <td>
               <p>1</p>
            </td>
         </tr>
        
              <tr>
            <td>
               <p>-1.0</p>
            </td>
            <td>
               <p>-1</p>
            </td>
         </tr>
        
                <tr>
            <td>
               <p>-2.4</p>
            </td>
            <td>
               <p>-2</p>
            </td>
         </tr>
        
         <tr>
            <td>
               <p>-3.5</p>
            </td>
            <td>
               <p>-3</p>
            </td>
         </tr>
        
                <tr>
            <td>
               <p>-4.6</p>
            </td>
            <td>
               <p>-5</p>
            </td>
         </tr>
        
   </table>
   </section>
</section>       
  
<!-- ======================================================== -->  
 <section id="sin">
   <title>SIN</title>
   <p>Returns the sine of an expression.</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>SIN(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result is double.</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>Usage</title>
     <p>
Use the SIN function to return the sine of an expession. 
     </p>
   </section>
</section>       
  
<!-- ======================================================== -->  
 <section id="sinh">
   <title>SINH</title>
   <p>Returns the hyperbolic sine of an expression.</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>SINH(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result is double.</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>Usage</title>
     <p>
Use the SINH function to return the hyperbolic sine of an expression. 
     </p>
   </section>
</section>


<!-- ======================================================== -->  
 <section id="sqrt">
   <title>SQRT</title>
   <p>Returns the positive square root of an expression.</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>SQRT(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result is double.</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>Usage</title>
     <p>
Use the SQRT function to return the positive square root of an expression. 
     </p>
   </section>
</section>

<!-- ======================================================== -->  
 <section id="tan">
   <title>TAN</title>
   <p>Returns the trignometric tangent of an angle.</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>TAN(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression (angle) whose result is double.</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>Usage</title>
     <p>
Use the TAN function to return the trignometric tangent of an angle.
     </p>
   </section>

</section>

<!-- ======================================================== -->  
 <section id="tanh">
   <title>TANH</title>
   <p>Returns the hyperbolic tangent of an expression. </p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>TANH(expression)</p>
            </td>
         </tr> 
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result is double.</p>
            </td>
         </tr>
        
   </table>
</section>
   
<section>
     <title>Usage</title>
     <p>
Use the TANH function to return the hyperbolic tangent of an expression. 
     </p>
   </section>
</section>
</section>
<!-- End Math Functions --> 


<!-- ======================================================== -->
<!-- ======================================================== -->   

<!-- String Functions -->
<section id="string-functions">
<title>String Functions</title>

<p>For general information about these functions, see the <a href="http://download.oracle.com/javase/6/docs/api/">Java API Specification</a>, 
<a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html">Class String</a>. Note the following:</p>

<ul>
	<li>
<p>Pig function names are case sensitive and UPPER CASE.</p>
	</li>
		<li>
<p>Pig string functions have an extra, first parameter: the string to which all the operations are applied.</p>
	</li>
		<li>
<p>Pig may process results differently than as stated in the Java API Specification. If any of the input parameters are null or if an insufficient number of parameters are supplied, NULL is returned.</p>
	</li>

</ul>
 
   <!-- ++++++++++++++++++++++++++++++++++++++++++++++ -->
 <section id="indexof">
   <title>INDEXOF</title>
   <p>Returns the index of the first occurrence of a character in a string, searching forward from a start index. </p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>INDEXOF(string, 'character', startIndex)</p>
            </td>
         </tr>
   </table>
 </section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>The string to be searched.</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>'character'</p>
            </td>
            <td>
               <p>The character being searched for, in quotes. </p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>startIndex</p>
            </td>
            <td>
               <p>The index from which to begin the forward search. </p>
               <p>The string index begins with zero (0).</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>
Use the INDEXOF function to determine the index of the first occurrence of a character in a string. The forward search for the character begins at the designated start index.
     </p>

</section>
</section> 

<!-- ======================================================== -->  
 <section id="last-index-of">
   <title>LAST_INDEX_OF</title>
   <p>Returns the index of the last occurrence of a character in a string, searching backward from a start index. </p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>LAST_INDEX_OF(expression)</p>
            </td>
         </tr>
   </table>
   </section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>The string to be searched.</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>'character'</p>
            </td>
            <td>
               <p>The character being searched for, in quotes.</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>startIndex</p>
            </td>
            <td>
               <p>The index from which to begin the backward search.</p>
               <p>The string index begins with zero (0).</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>
Use the LAST_INDEX_OF function to determine the index of the last occurrence of a character in a string. The backward search for the character begins at the designated start index.
     </p>
</section>
</section> 


<!-- ======================================================== -->  
 <section id="lcfirst">
   <title>LCFIRST</title>
   <p>Converts the first character in a string to lower case. </p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>LCFIRST(expression)</p>
            </td>
         </tr>
   </table>
 </section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result type is chararray.</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>
Use the LCFIRST function to convert only the first character in a string to lower case. 
     </p>
</section>
</section> 

<!-- ======================================================== -->  
 <section id="lower">
   <title>LOWER</title>
   <p>Converts all characters in a string to lower case. </p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>LOWER(expression)</p>
            </td>
         </tr>
   </table>
</section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result type is chararray.</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>
Use the LOWER function to convert all characters in a string to lower case. 
     </p>
</section>
</section> 


<!-- ======================================================== -->
 <section id="regex-extract">
   <title>REGEX_EXTRACT </title>
   <p>Performs regular expression matching and extracts the matched group defined by an index parameter. </p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>REGEX_EXTRACT (string, regex, index)</p>
            </td>
         </tr>
   </table>
 </section>

<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>The string in which to perform the match.</p>
            </td>
         </tr> 
        <tr>
            <td>
               <p>regex</p>
            </td>
            <td>
               <p>The regular expression.</p>
            </td>
         </tr> 
         
                <tr>
            <td>
               <p>index</p>
            </td>
            <td>
               <p>The index of the matched group to return.</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>
Use the REGEX_EXTRACT function to perform regular expression matching and to extract the matched group defined by the index parameter (where the index is a 1-based parameter.) The function uses Java regular expression form.
     </p>
     <p>
The function returns a string that corresponds to the matched group in the position specified by the index. If there is no matched expression at that position, NULL is returned.
     </p>
 </section>
 
 <section>
     <title>Example</title>
     <p>
This example will return the string '192.168.1.5'.
     </p>
 <source>
REGEX_EXTRACT('192.168.1.5:8020', '(.*)\:(.*)', 1);
</source>
     
 </section>

</section>

<!-- ======================================================== -->
 <section id="regex-extract-all">
   <title>REGEX_EXTRACT_ALL </title>
   <p>Performs regular expression matching and extracts all matched groups.</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>REGEX_EXTRACT (string, regex)</p>
            </td>
         </tr>
   </table>
 </section>

<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>The string in which to perform the match.</p>
            </td>
         </tr> 
         
                <tr>
            <td>
               <p>regex</p>
            </td>
            <td>
               <p>The regular expression.</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>
Use the REGEX_EXTRACT_ALL function to perform regular expression matching and to extract all matched groups. The function uses Java regular expression form.
     </p>
     <p>
The function returns a tuple where each field represents a matched expression. If there is no match, an empty tuple is returned.
     </p>
 </section>
 
 <section>
     <title>Example</title>
     <p>
This example will return the tuple (192.168.1.5,8020).
     </p>
 <source>
REGEX_EXTRACT_ALL('192.168.1.5:8020', '(.*)\:(.*)');
</source>
     
 </section>

</section>


<!-- ======================================================== -->  
 <section id="replace">
   <title>REPLACE</title>
   <p>Replaces existing characters in a string with new characters.</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>REPLACE(string, 'oldChar', 'newChar');</p>
            </td>
         </tr>  
   </table>
 </section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>The string to be updated.</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>'oldChar'</p>
            </td>
            <td>
               <p>The existing characters being replaced, in quotes. </p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>'newChar'</p>
            </td>
            <td>
               <p>The new characters replacing the existing characters, in quotes.</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>
Use the REPLACE function to replace existing characters in a string with new characters.
     </p>
     <p>
For example, to change "open source software" to "open source wiki" use this statement: 
REPLACE(string,'software','wiki');
     </p>
</section>
</section> 

<!-- ======================================================== -->  
 <section id="strsplit">
   <title>STRSPLIT</title>
   <p>Splits a string around matches of a given regular expression. </p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>STRSPLIT(string, regex, limit)</p>
            </td>
         </tr> 
        
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>The string to be split.</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>regex</p>
            </td>
            <td>
               <p>The regular expression.</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>Limit</p>
            </td>
            <td>
               <p>The number of times the pattern (the compiled representation of the regular expression) is applied.</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>
Use the STRSPLIT function to split a string around matches of a given regular expression.
     </p>
     <p>
For example, given the string (open:source:software), STRSPLIT (string, ':',2) will return ((open,source:software)) and STRSPLIT (string, ':',3) will return ((open,source,software)).
     </p>
</section>
</section> 

<!-- ======================================================== -->  
 <section id="substring">
   <title>SUBSTRING</title>
   <p>Returns a substring from a given string. </p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>SUBSTRING(string, startIndex, stopIndex)</p>
            </td>
         </tr> 
        
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
          <tr>
            <td>
               <p>string</p>
            </td>
            <td>
               <p>The string from which a substring will be extracted.</p>
            </td>
         </tr> 
       <tr>
            <td>
               <p>startIndex</p>
            </td>
            <td>
               <p>The index (type integer) of the first character of the substring.</p>
               <p>The index of a string begins with zero (0).</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>stopIndex</p>
            </td>
            <td>
               <p>The index (type integer) of the character <em>following</em> the last character of the substring.</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>
Use the SUBSTRING function to return a substring from a given string. 
     </p>
          <p>  
Given a field named alpha whose value is ABCDEF, to return substring BCD use this statement: SUBSTRING(alpha,1,4). Note that 1 is the index of B (the first character of the substring) and  4 is the index of E  (the character <em>following</em> the last character of the substring).
     </p>
</section>
</section> 

<!-- ======================================================== -->  
 <section id="trim">
   <title>TRIM</title>
   <p>Returns a copy of a string with leading and trailing white space removed.</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>TRIM(expression)</p>
            </td>
         </tr> 
        
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result is chararray. </p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>
Use the TRIM function to remove leading and trailing white space from a string.
     </p>
</section>
</section> 

<!-- ======================================================== -->  
 <section id="ucfirst">
   <title>UCFIRST</title>
   <p>Returns a string with the first character converted to upper case. </p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>UCFIRST(expression)</p>
            </td>
         </tr> 
        
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result type is chararray.</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>
Use the UCFIRST function to convert only the first character in a string to upper case. 
     </p>
</section>
</section>

<!-- ======================================================== -->  
 <section id="upper">
   <title>UPPER</title>
   <p>Returns a string converted to upper case. </p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>UPPER(expression)</p>
            </td>
         </tr> 
        
   </table></section>
   
<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression whose result type is chararray. </p>
            </td>
         </tr> 
   </table>
</section>
   
<section>
     <title>Usage</title>
     <p>
Use the UPPER function to convert all characters in a string to upper case.
     </p>
   </section>
</section>
 
</section>
<!-- End String Functions -->


<!-- ======================================================== -->
<!-- ======================================================== -->
<!-- Other Functions -->
<section id="bag-tuple-functions">
<title>Tuple, Bag, Map Functions</title>

<!-- ======================================================== -->  
 <section id="totuple">
   <title>TOTUPLE</title>
   <p>Converts one or more expressions to type tuple. </p>


<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>TOTUPLE(expression [, expression ...])</p>
            </td>
         </tr> 
        
   </table>
 </section>

<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression of any datatype.</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>Use the TOTUPLE function to convert one or more expressions to a tuple.</p>
        <p>See also: <a href="basic.html#tuple">Tuple</a> data type and <a href="basic.html#type-construction">Type Construction Operators</a></p>
 </section>
 
 <section>
     <title>Example</title>
     <p>
In this example, fields f1, f2 and f3 are converted to a tuple.
     </p>
 <source>
a = LOAD 'student' AS (f1:chararray, f2:int, f3:float);
DUMP a;

(John,18,4.0)
(Mary,19,3.8)
(Bill,20,3.9)
(Joe,18,3.8)

b = FOREACH a GENERATE TOTUPLE(f1,f2,f3);
DUMP b;

((John,18,4.0))
((Mary,19,3.8))
((Bill,20,3.9))
((Joe,18,3.8))
</source>
 </section>
</section>

<!-- ======================================================== -->
 <section id="tobag">
   <title>TOBAG</title>
   <p>Converts one or more expressions to type bag. </p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>TOBAG(expression [, expression ...])</p>
            </td>
         </tr> 
        
   </table>
 </section>

<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>expression</p>
            </td>
            <td>
               <p>An expression with any data type.</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>Use the TOBAG function to convert one or more expressions to individual tuples which are then placed in a bag.</p>
     <p>See also: <a href="basic.html#bag">Bag</a> data type and <a href="basic.html#type-construction">Type Construction Operators</a></p>
 </section>
 
 <section>
     <title>Example</title>
     <p>
In this example, fields f1 and f3 are converted to tuples that are then placed in a bag.
     </p>
 <source>
a = LOAD 'student' AS (f1:chararray, f2:int, f3:float);
DUMP a;

(John,18,4.0)
(Mary,19,3.8)
(Bill,20,3.9)
(Joe,18,3.8)

b = FOREACH a GENERATE TOBAG(f1,f3);
DUMP b;

({(John),(4.0)})
({(Mary),(3.8)})
({(Bill),(3.9)})
({(Joe),(3.8)})
</source>
     
 </section>

</section>


<!-- ======================================================== -->
 <section id="tomap">
   <title>TOMAP</title>
   <p>Converts key/value expression pairs into a map. </p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>TOMAP(key-expression, value-expression [, key-expression, value-expression ...])</p>
            </td>
         </tr> 
        
   </table>
 </section>

<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>key-expression</p>
            </td>
            <td>
               <p>An expression of type chararray.</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>value-expression</p>
            </td>
            <td>
               <p>An expression of any type supported by a map.</p>
            </td>
         </tr>
   </table>
</section>

<section>
     <title>Usage</title>
     <p>Use the TOMAP function to convert pairs of expressions into a map. Note the following:</p>
     <ul>
<li>You must supply an even number of expressions as parameters</li>
<li>The elements must comply with map type rules:
<ul>
<li>Every odd element (key-expression) must be a chararray since only chararrays can be keys into the map</li>
<li>Every even element (value-expression) can be of any type supported by a map. </li>
</ul>
</li>
     </ul>
 <p></p>    
 <p>See also: <a href="basic.html#map">Map</a> data type and  <a href="basic.html#type-construction">Type Construction Operators</a></p>  
 </section>
 
 <section>
     <title>Example</title>
     <p>
In this example, student names (type chararray) and student GPAs (type float) are used to create three maps.
     </p>
 <source>
A = load 'students' as (name:chararray, age:int, gpa:float);
B = foreach A generate TOMAP(name, gpa);
store B into ‘results’;

Input (students)
joe smith 20 3.5
amy chen 22 3.2
leo allen 18 2.1

Output (results)
[joe smith#3.5]
[amy chen#3.2]
[leo allen#2.1]
</source>
     
 </section>

</section>



 <!-- ======================================================== -->  
 <section id="topx">
   <title>TOP</title>
   <p>Returns the top-n tuples from a bag of tuples.</p>

<section>
   <title>Syntax</title>
   <table>
       <tr>
            <td>
               <p>TOP(topN,column,relation)</p>
            </td>
         </tr> 
        
   </table>
 </section>

<section>
   <title>Terms</title>
   <table>
       <tr>
            <td>
               <p>topN</p>
            </td>
            <td>
               <p>The number of top tuples to return (type integer).</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>column</p>
            </td>
            <td>
               <p>The tuple column whose values are being compared.</p>
            </td>
         </tr> 
                <tr>
            <td>
               <p>relation</p>
            </td>
            <td>
               <p>The relation (bag of tuples) containing the tuple column.</p>
            </td>
         </tr> 
   </table>
</section>

<section>
     <title>Usage</title>
     <p>
TOP function returns a bag containing top N tuples from the input bag where N is controlled by the first parameter to the function. The tuple comparison is performed based on a single column from the tuple. The column position is determined by the second parameter to the function. The function assumes that all tuples in the bag contain an element of the same type in the compared column
     </p>
</section>
 
 <section>
     <title>Example</title>
     <p>
In this example the top 10 occurrences are returned.
     </p>
 <source>
A = LOAD 'data' as (first: chararray, second: chararray);
B = GROUP A BY (first, second);
C = FOREACH B generate FLATTEN(group), COUNT(*) as count;
D = GROUP C BY first; // again group by first
topResults = FOREACH D {
    result = TOP(10, 2, C); // and retain top 10 occurrences of 'second' in first
    GENERATE FLATTEN(result);
}
</source>
     
 </section>
</section>
</section>
<!-- End Other Functions -->

  </body>
</document>
